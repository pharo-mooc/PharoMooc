1
00:00:01,400 --> 00:00:04,720
-この講義では、メソッドとメソッド

2
00:00:05,040 --> 00:00:06,560
その違いについて議論します。

3
00:00:07,120 --> 00:00:10,680
メソッドは名前がつけられた
一連の命令です。

4
00:00:11,000 --> 00:00:17,240
メソッド「makeCrepes」を定義しました。
レシピのようなものです。

5
00:00:17,560 --> 00:00:20,600
卵を取って
牛乳、小麦粉、砂糖を入れてると

6
00:00:20,920 --> 00:00:22,720
クレープが出来上がります。

7
00:00:23,040 --> 00:00:29,520
そういうわけで、メソッドはまさに
名前がつけられた一連の指示で

8
00:00:29,840 --> 00:00:33,440
メッセージに対する反応として
実行されます。

9
00:00:33,760 --> 00:00:37,080
つまり、ここにあるのは
ある1つのクラスの全てのインスタンスは

10
00:00:37,400 --> 00:00:38,560
同じ振る舞いを共有しますが

11
00:00:38,880 --> 00:00:43,520
それはなぜかというと、この振る舞いは
クラスの中にメソッドとして定義されているからです。

12
00:00:43,840 --> 00:00:48,520
つまり、クラス Rectangle のインスタンスに
メッセージを送る時

13
00:00:48,840 --> 00:00:51,200
例えば、メッセージ area を送る時には

14
00:00:51,520 --> 00:00:54,160
レシーバーのクラスの中で
メソッドを探します

15
00:00:54,480 --> 00:00:55,880
つまり、クラス Rectangle の中で、です。

16
00:00:56,200 --> 00:01:01,040
そして、この定義を適用します。
レシーバーのこのメソッドです。

17
00:01:01,360 --> 00:01:03,920
そして、そのメソッドはメッセージを受けた
インスタンスの

18
00:01:04,240 --> 00:01:07,440
データを使います。

19
00:01:07,760 --> 00:01:12,240
こういうわけで、メソッドは
クラスの全てのインスタンスに共有されます。

20
00:01:14,640 --> 00:01:17,480
振り返ると
メソッドには名前があります。

21
00:01:17,800 --> 00:01:19,920
そして手続きを定義します。

22
00:01:20,240 --> 00:01:23,600
処理や計算を定義します。

23
00:01:24,680 --> 00:01:28,480
さらに、そのオブジェクトの
プライベートなデータにアクセスします。

24
00:01:28,800 --> 00:01:30,360
ここがとても重要です。

25
00:01:30,680 --> 00:01:32,400
メッセージと比べると

26
00:01:32,720 --> 00:01:35,440
メソッドはオブジェクトの
プライベートなデータにアクセスします。

27
00:01:35,760 --> 00:01:39,360
計算に使ったり、あるいは、変更したりします。

28
00:01:41,520 --> 00:01:43,360
確認すると、まず一方は

29
00:01:43,680 --> 00:01:46,600
メッセージで
これは命令のようなものです。

30
00:01:46,920 --> 00:01:50,400
つまりオブジェクトに何をさせるのかを
宣言します。

31
00:01:50,720 --> 00:01:51,880
そしてもう一方はメソッドです。

32
00:01:52,200 --> 00:01:54,560
これはオブジェクトがメッセージへの反応として

33
00:01:54,880 --> 00:01:56,280
どのように計算を実行すべきかです。

34
00:01:58,240 --> 00:02:00,440
ここにあるのは、メッセージは

35
00:02:00,760 --> 00:02:03,040
オブジェクトの構造を知らない
ということです。

36
00:02:03,360 --> 00:02:04,840
実際、構造はメッセージを送るクライアントには

37
00:02:05,160 --> 00:02:08,040
重要ではないのです。

38
00:02:08,360 --> 00:02:16,720
一方メソッドは
オブジェクトのデータにアクセスします。

39
00:02:18,200 --> 00:02:19,520
さらに

40
00:02:20,520 --> 00:02:24,200
メソッドは動的に探索され
レシーバーのクラスに依存します。

41
00:02:24,520 --> 00:02:27,000
この点を説明する２つの例があります。

42
00:02:27,320 --> 00:02:30,200
１つは前回の講義で既に見ました。

43
00:02:30,520 --> 00:02:33,520
猫と犬と魚がいるとします。

44
00:02:33,840 --> 00:02:36,960
猫にメッセージを送ると
クラス「Cat」の中で探索して

45
00:02:37,280 --> 00:02:42,040
メソッドに結びつけられた振る舞いを

46
00:02:42,360 --> 00:02:43,800
インスタンス「aCat」に適用します。

47
00:02:44,120 --> 00:02:47,560
したがって、クラス「Cat」の全てのインスタンスが
同じ振る舞いを共有します。

48
00:02:47,880 --> 00:02:50,440
しかし、この振る舞いは
犬のものとは異なります。

49
00:02:50,760 --> 00:02:53,560
そしてこれは図形についても同様です。

50
00:02:53,880 --> 00:02:56,280
矩形、円、正方形といった

51
00:02:56,600 --> 00:02:58,960
幾何学図形があるとします。

52
00:02:59,280 --> 00:03:02,920
そして面積を計算したいとします。

53
00:03:03,240 --> 00:03:05,840
さて、メッセージ「area」を円に送る時には

54
00:03:06,160 --> 00:03:08,120
円に基づいた計算が

55
00:03:08,440 --> 00:03:10,520
このインスタンスで実行させたいのです。

56
00:03:10,840 --> 00:03:12,720
これが遅延束縛です。

57
00:03:13,040 --> 00:03:15,880
つまり、レシーバーのクラスの中を探索して

58
00:03:16,200 --> 00:03:17,720
対応するメソッドを見つけます。

59
00:03:18,040 --> 00:03:23,200
さて、さらに重要なことは
幾何学図形の一覧を用意して

60
00:03:23,520 --> 00:03:27,560
上から順に矩形だとか正方形だとかに
該当するかチェックしなくても良いのです。

61
00:03:27,880 --> 00:03:32,160
もし複数の図形を合成した図があって

62
00:03:32,480 --> 00:03:36,120
この図の総面積を知りたいとしたら

63
00:03:36,440 --> 00:03:38,920
合計はすぐに求まります。

64
00:03:39,240 --> 00:03:41,840
メッセージ「area」を全ての図形に
送れば良いのです。

65
00:03:42,160 --> 00:03:45,240
クライアント側が
図形を区別する必要はありません。

66
00:03:45,560 --> 00:03:47,440
単にメッセージ「area」を送るだけです。

67
00:03:47,760 --> 00:03:52,040
それでクラスに送られます。

68
00:03:52,360 --> 00:03:54,880
つまり、2つの矩形と1つの円があるとすると

69
00:03:55,200 --> 00:03:59,960
矩形では矩形の「area」を2回実行して

70
00:04:00,280 --> 00:04:05,240
円の「area」を1回実行します。

71
00:04:07,640 --> 00:04:09,040
これが遅延束縛です。

72
00:04:09,360 --> 00:04:12,800
遅延束縛では

73
00:04:14,040 --> 00:04:15,200
クライアント側は

74
00:04:16,160 --> 00:04:18,920
レシーバーの型やクラスを

75
00:04:19,240 --> 00:04:22,080
知らなくても良いのです。

76
00:04:22,400 --> 00:04:24,800
単にこのアクションをしたいのだと宣言すれば

77
00:04:25,120 --> 00:04:26,720
システムがレシーバーごとに
対応するメソッドを

78
00:04:27,040 --> 00:04:31,200
動的に探して実行します。

79
00:04:31,520 --> 00:04:33,000
これはとても強力です。

80
00:04:34,760 --> 00:04:37,840
遅延束縛という用語は

81
00:04:38,160 --> 00:04:40,360
コンパイル時には

82
00:04:40,680 --> 00:04:43,440
どのコードが実行するか知らない
ということです。

83
00:04:43,760 --> 00:04:46,880
プログラムの実行時に選択されます。

84
00:04:47,200 --> 00:04:48,120
これは本当に強力です。

85
00:04:48,440 --> 00:04:51,200
実行中にコードをロードして

86
00:04:51,520 --> 00:04:53,440
オブジェクトを生成して

87
00:04:53,760 --> 00:04:58,120
それに基づいて振る舞いが実行されるのです。

88
00:04:58,440 --> 00:05:01,240
この振る舞いはコードを書いて

89
00:05:01,560 --> 00:05:02,640
コンパイルした時点では知らなかったことです。

90
00:05:02,960 --> 00:05:06,440
しかしプログラムが実行される時には
正しいメソッドが見つかります。

91
00:05:06,760 --> 00:05:08,280
ここで強調しておきたいことは

92
00:05:08,600 --> 00:05:13,400
オブジェクトについての、このビジョンです。
データはプライベートです。

93
00:05:13,720 --> 00:05:17,720
メソッドはこのプライベートなデータにアクセスできます。
メッセージはプライベートなデータは知りません。

94
00:05:18,040 --> 00:05:22,040
メッセージは単にオブジェクトに語りかけます。

95
00:05:22,360 --> 00:05:25,720
メソッドが実行されます。
そしてメソッドがデータにアクセスします。

96
00:05:26,040 --> 00:05:29,120
これはとても重要な性質で
「カプセル化」と呼びます。

97
00:05:29,440 --> 00:05:31,240
カプセル化とは何でしょう？

98
00:05:31,560 --> 00:05:35,720
クライアントの視点からは
詳細は隠されています。

99
00:05:36,040 --> 00:05:40,000
これはとても大切なことです。
というのも

100
00:05:40,320 --> 00:05:42,480
同じ機能の

101
00:05:42,800 --> 00:05:45,240
2つの異なる実装があったとして

102
00:05:45,560 --> 00:05:50,360
実装が変わろうが
同じ結果が出れば構わないのです。

103
00:05:50,680 --> 00:05:55,320
例えば、
面積を計算する2つの異なる方法があります。

104
00:05:55,640 --> 00:05:58,160
矩形のクラスが２つあるとしましょう。

105
00:05:58,480 --> 00:06:01,240
例えば
1つは最適化されていて

106
00:06:01,560 --> 00:06:02,440
もう1つは最適化されていません。

107
00:06:02,760 --> 00:06:05,680
クライアントには
どちらでも構わないのです。

108
00:06:06,000 --> 00:06:09,960
クライアントが求める事はただ1つです。
メッセージ「area」を

109
00:06:10,280 --> 00:06:12,840
どちらの矩形に送ったとしても
正しい答えが得られることです。

110
00:06:13,160 --> 00:06:16,000
どう実装されているかは
知ったことではありません。

111
00:06:16,320 --> 00:06:17,840
それはメソッドの問題です。

112
00:06:18,160 --> 00:06:21,080
オブジェクトのカプセル化は
とても重要です。

113
00:06:21,400 --> 00:06:23,480
遅延束縛を使って

114
00:06:23,800 --> 00:06:26,280
プログラムを時と共に
進化させることができるからです。

115
00:06:26,600 --> 00:06:29,280
同じ責任を持つ同じAPIを満たすオブジェクトで

116
00:06:29,600 --> 00:06:32,880
オブジェクトを置き換えることができます。

117
00:06:33,200 --> 00:06:34,760
やり方が異なっていても。

118
00:06:35,080 --> 00:06:37,840
こうすることで
モジュール化されたシステムを構築できます。

119
00:06:38,160 --> 00:06:41,080
この視点では
遅延束縛とオブジェクトのカプセル化は

120
00:06:41,400 --> 00:06:45,200
システムの進化を支える
とても強力なものです。

121
00:06:46,080 --> 00:06:49,400
まとめると
覚えておくべきことは

122
00:06:49,720 --> 00:06:51,560
1つはメッセージで
オブジェクトに送られます。

123
00:06:51,880 --> 00:06:53,520
抽象的な命令です。

124
00:06:53,840 --> 00:06:55,720
もう1つはメソッドで

125
00:06:56,040 --> 00:06:59,560
一連の指示で
実行して

126
00:06:59,880 --> 00:07:02,800
オブジェクトのデータに
アクセスすることができます。

127
00:07:03,120 --> 00:07:05,680
そして詳細を処理します。

128
00:07:06,000 --> 00:07:09,200
さらに加えて、遅延束縛は
メッセージが送られた時に

129
00:07:09,520 --> 00:07:10,520
正しいメソッドを選択します。

130
00:07:10,840 --> 00:07:12,760
つまり、同じAPIやインターフェイスを持つ

131
00:07:13,080 --> 00:07:17,840
同じメッセージに反応する
オブジェクトが複数あった時に

132
00:07:18,160 --> 00:07:19,560
それらを混ぜて使うことができます。

133
00:07:19,880 --> 00:07:22,320
そしてクライアントは
気にする必要ありません。

134
00:07:22,640 --> 00:07:24,880
オブジェクトが正しいものかどうか
チェックする必要はありません。

135
00:07:25,200 --> 00:07:28,040
メッセージを送れば
システムが自動的に

136
00:07:28,360 --> 00:07:29,600
正しいメソッドを選択してくれます。

137
00:07:29,920 --> 00:07:31,560
つまりこの視点では

138
00:07:31,880 --> 00:07:34,720
オブジェクトを時が経つにつれて
進化させることができるということです。

139
00:07:35,040 --> 00:07:37,160
そしてシステムを
よりモジュール化することができます。
