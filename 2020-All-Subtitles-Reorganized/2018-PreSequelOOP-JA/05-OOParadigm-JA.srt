1
00:00:01,400 --> 00:00:03,200
-この講義で
お見せしたいのは

2
00:00:03,520 --> 00:00:07,840
オブジェクト指向設計は世界を
独特な方法でモデル化するということです。

3
00:00:08,160 --> 00:00:09,440
まず、知っておくべきことは

4
00:00:09,760 --> 00:00:12,560
世界の単一のモデルは存在しないことです。

5
00:00:12,880 --> 00:00:14,840
あなたが着目する焦点に依存します。

6
00:00:15,160 --> 00:00:18,040
例えば、銀行ではリスクを保険会社とは
異なる方法でモデル化しています。

7
00:00:18,360 --> 00:00:21,160
なぜなら、保険会社では

8
00:00:21,480 --> 00:00:26,400
リスクはビジネスの重要な側面であるのに
銀行ではリスクは副次的なものです。

9
00:00:26,720 --> 00:00:31,880
つまり、世界の単一のモデルがない一方

10
00:00:32,200 --> 00:00:35,840
世界をモデル化する手段や方法が

11
00:00:36,160 --> 00:00:37,840
複数あるのです。

12
00:00:38,160 --> 00:00:41,520
データ駆動型のモデルが

13
00:00:41,840 --> 00:00:46,080
データベースシステムで使われました。

14
00:00:46,400 --> 00:00:50,160
オブジェクト指向設計や
手続き型モデリング等も使うことができます。

15
00:00:50,480 --> 00:00:54,440
この講義では
手続き型モデリングと

16
00:00:54,760 --> 00:00:56,520
オブジェクト指向プログラミングを
比較します。

17
00:00:56,840 --> 00:00:58,720
オブジェクト指向とは何でしょう？

18
00:00:59,040 --> 00:01:03,120
実は、オブジェクト指向はパラダイムであって
技術ではありません。

19
00:01:03,440 --> 00:01:06,360
オブジェクト指向設計は
協調する脱中央化された実体の集合として

20
00:01:06,680 --> 00:01:09,640
世界をシミュレートすることで

21
00:01:09,960 --> 00:01:16,280
世界を表現するための方法です。

22
00:01:16,600 --> 00:01:20,400
モデル化する対象の複雑性を

23
00:01:20,720 --> 00:01:25,760
最小化したり対処したり

24
00:01:26,080 --> 00:01:30,760
また、再利用性を高め
メンテナンスコストを下げるという発想です。

25
00:01:31,080 --> 00:01:35,840
手続き型設計とオブジェクト指向設計を
比較してみましょう。

26
00:01:36,160 --> 00:01:37,760
手続き型設計では

27
00:01:38,080 --> 00:01:40,800
システムの焦点は
構造と手続きです。

28
00:01:41,120 --> 00:01:43,800
データは手続きの間で共有され

29
00:01:44,120 --> 00:01:47,520
すべての手順からアクセス可能です。
呼び出し側の手続きからも。

30
00:01:47,840 --> 00:01:51,960
そして手続きは
データ構造を知っています。

31
00:01:52,280 --> 00:01:54,880
遅延束縛はありません。

32
00:01:55,200 --> 00:01:57,640
これはどういうことかというと
模倣はできたとしても

33
00:01:57,960 --> 00:02:00,840
手続きはそれぞれ名前がつけられていて

34
00:02:01,160 --> 00:02:04,200
C言語のようにある種の単一の名前空間を持ちます。

35
00:02:04,520 --> 00:02:07,600
そして、メッセージとメソッドのような
分離はありません。

36
00:02:07,920 --> 00:02:10,320
単に、データにアクセスする手続きです。

37
00:02:10,640 --> 00:02:16,240
例を使って
手続き型のモデリングと

38
00:02:16,560 --> 00:02:18,120
オブジェクト指向モデリングを比較します。

39
00:02:18,440 --> 00:02:21,480
正方形や矩形、円などの
図形を組み合わせた

40
00:02:22,400 --> 00:02:24,960
図があるとしましょう。

41
00:02:25,280 --> 00:02:28,880
この図の面積を計算します。

42
00:02:29,200 --> 00:02:30,600
手続き型では

43
00:02:30,920 --> 00:02:33,160
Javaで書きました。

44
00:02:33,480 --> 00:02:36,800
オブジェクト指向言語で
手続き的に書くことができるからです。

45
00:02:37,120 --> 00:02:39,400
することは簡単です。

46
00:02:39,720 --> 00:02:43,680
図形のリストを列挙していきます。
それぞれの図形について

47
00:02:44,000 --> 00:02:47,000
1つ1つ、「正方形があれば
計算方法は

48
00:02:47,320 --> 00:02:48,920
幅と幅を掛ければよい。

49
00:02:49,240 --> 00:02:50,240
矩形があれば

50
00:02:50,560 --> 00:02:54,280
長さと高さを掛けなければならない

51
00:02:54,600 --> 00:02:59,160
そしてもし円があれば
円周率に半径の自乗を掛ける

52
00:02:59,480 --> 00:03:00,600
以上でおしまい。」

53
00:03:00,920 --> 00:03:03,400
これを Pharo で書くこともできます。

54
00:03:03,720 --> 00:03:06,440
図形を列挙していって
全く同じことをします。

55
00:03:06,760 --> 00:03:10,760
「もしこれのクラスがこれだったら
これをする」

56
00:03:11,080 --> 00:03:13,720
「もしこのクラスがあの種のものなら
あれをする。」

57
00:03:14,040 --> 00:03:16,080
さて、このやり方だと何が後退しているでしょう？
いくつかの点があります。

58
00:03:16,400 --> 00:03:18,680
まず、全てのロジックが
1箇所で定義されています。

59
00:03:19,000 --> 00:03:20,520
これ自体は悪いことではありませんが

60
00:03:20,840 --> 00:03:22,880
悪いことをもたらします。

61
00:03:23,200 --> 00:03:25,320
メインの機能を再利用できません。

62
00:03:25,640 --> 00:03:27,560
新しい図形を追加したい場合には
どうなるでしょう？

63
00:03:27,880 --> 00:03:30,640
新しい図形を追加するには
このメソッドあるいは手続きを変更して

64
00:03:30,960 --> 00:03:34,080
再コンパイルしなければなりません。

65
00:03:34,400 --> 00:03:36,680
メインの手続きさえ再利用できません。

66
00:03:37,000 --> 00:03:40,080
では、オブジェクト指向のやり方では
どうするのか見てみましょう。

67
00:03:40,400 --> 00:03:45,040
オブジェクト指向では、
クラス「Picture」に area を

68
00:03:45,360 --> 00:03:49,720
メソッドとして定義します。
そして図形を列挙していきます。

69
00:03:50,040 --> 00:03:56,760
それぞれの図形に
自分の面積を求めるように依頼します。

70
00:03:57,080 --> 00:03:59,960
そして、正方形、矩形、円に

71
00:04:00,280 --> 00:04:05,000
面積を計算するメソッド「area」を
定義します。

72
00:04:06,080 --> 00:04:08,840
どんな利点があるでしょう？
新しい図形を追加することが実に簡単です。

73
00:04:09,160 --> 00:04:11,840
単にそのクラスに
メッセージ「area」を追加するだけです。


74
00:04:12,160 --> 00:04:16,320
図形オブジェクトを何個も作って
図に追加して、それで終わりです。

75
00:04:16,640 --> 00:04:19,760
「Picture >> area」メソッドを
再利用できます。

76
00:04:20,080 --> 00:04:24,480
図形から独立しているから問題ないのです。

77
00:04:24,800 --> 00:04:30,880
そして、脱中央化された計算を
見てとることができます。

78
00:04:31,200 --> 00:04:33,920
それぞれの図形が
それぞれのデータやロジックを内部に持ち

79
00:04:34,240 --> 00:04:36,840
areaだけを露出させます。

80
00:04:38,320 --> 00:04:39,920
しかし落とし穴もあります。

81
00:04:40,240 --> 00:04:42,760
オブジェクト指向プログラミングでは

82
00:04:43,080 --> 00:04:47,480
メソッド「area」に同じ名前を与えなければ

83
00:04:47,800 --> 00:04:52,280
「Picture >> area」の機能を
再利用できません。

84
00:04:52,600 --> 00:04:54,880
というのも、メソッドの名前が異なっていた場合
クライアント側がチェックしなければならないからです。

85
00:04:55,200 --> 00:04:59,240
したがって
同じサービスを提供する全ての図形が


86
00:04:59,560 --> 00:05:04,480
同じAPI、同じインターフェイスを
公開することに同意します。

87
00:05:04,800 --> 00:05:06,680
これが「多態性(polymorphism)」
と呼ばれるものです。

88
00:05:07,000 --> 00:05:10,240
つまり、異なるオブジェクトが
同じメッセージに答えますが

89
00:05:10,560 --> 00:05:12,040
実行は異なるということです。

90
00:05:12,640 --> 00:05:14,840
これは本当に重要なことです。
こうすることで

91
00:05:15,160 --> 00:05:19,840
置き換え可能なオブジェクトを作り
良いオブジェクト指向設計を構築するからです。

92
00:05:21,560 --> 00:05:24,880
最後に、オブジェクト指向システムにおける
アプリケーションとは何でしょうか？

93
00:05:25,200 --> 00:05:29,760
アプリケーションとは、対話する実体
つまりオブジェクトの集合体です。

94
00:05:30,080 --> 00:05:33,880
オブジェクトは振る舞いと状態で
特徴付けられます。

95
00:05:34,200 --> 00:05:39,640
状態はプライベートで
メソッドからしか状態にアクセスできません。

96
00:05:39,960 --> 00:05:43,320
オブジェクトは
動的に解決されるメッセージで対話します。

97
00:05:43,640 --> 00:05:45,880
メッセージと実行されるメソッドは

98
00:05:46,200 --> 00:05:49,320
区別されます。

99
00:05:49,640 --> 00:05:51,360
メッセージ送信は遅延束縛であり

100
00:05:51,680 --> 00:05:54,280
それはつまりレシーバーのオブジェクトと

101
00:05:54,600 --> 00:05:58,040
オブジェクトにクラスを通して所属する
計算に依存します。

102
00:05:59,480 --> 00:06:02,680
オブジェクトは個別の実体であることを
見てきました。

103
00:06:03,000 --> 00:06:05,360
オブジェクトはプライベートな状態を持ち
メッセージに反応し

104
00:06:05,680 --> 00:06:09,080
オブジェクトのメソッドが
計算を実行します。

105
00:06:09,400 --> 00:06:13,880
キーポイントは、オブジェクトは
多態性のあるインターフェイスを提供すべきで

106
00:06:14,200 --> 00:06:17,160
そうすることでオブジェクトは
他のオブジェクトと混ぜて使うことができ

107
00:06:17,480 --> 00:06:19,880
多態性のあるインターフェイスを使ったコードを
再利用することができるようになります。

108
00:06:20,800 --> 00:06:23,120
さて、オブジェクト指向プログラミングの
3つの土台と

109
00:06:23,440 --> 00:06:27,280
それらの間の相互作用をお見せしましょう

110
00:06:27,600 --> 00:06:29,640
まず最初にカプセル化です。

111
00:06:29,960 --> 00:06:35,440
カプセル化は計算が行われる方法と

112
00:06:35,760 --> 00:06:36,840
データを隠す能力です。

113
00:06:37,160 --> 00:06:38,800
つまり、クライアントとして
メッセージを送る時には

114
00:06:39,120 --> 00:06:42,000
そのオブジェクトが
データをどうやって管理して

115
00:06:42,320 --> 00:06:44,360
どう計算するかは気にしません。

116
00:06:44,680 --> 00:06:46,560
つまり、この視点では

117
00:06:46,880 --> 00:06:50,640
オブジェクトが合成されていて
他のオブジェクトに委譲していても

118
00:06:50,960 --> 00:06:52,440
クライアントには影響ありません。

119
00:06:52,760 --> 00:06:55,760
これは、オブジェクトは自分の計算を

120
00:06:56,080 --> 00:07:01,680
脱中央化された方法でサブタスクに
自由に分割できるということです。

121
00:07:02,000 --> 00:07:06,080
カプセル化と合成の
この相互作用はとても重要です。

122
00:07:07,160 --> 00:07:10,720
次の土台は、責任の分散です。

123
00:07:11,040 --> 00:07:16,600
これはつまり、問題を計算する時に
問題をサブタスクに分解するということです。

124
00:07:16,920 --> 00:07:21,800
そしてこの分解は遅延束縛をつかうことで
際立たせられます。

125
00:07:22,120 --> 00:07:29,240
何をするのか決定するのはレシーバーだ
という考え方です。

126
00:07:29,560 --> 00:07:34,880
これらは多態性によって

127
00:07:35,200 --> 00:07:36,720
さらに際立ちます。

128
00:07:37,040 --> 00:07:40,440
同じインターフェイスを持つオブジェクトを

129
00:07:40,760 --> 00:07:42,360
混ぜ合わせることができるからです。

130
00:07:42,680 --> 00:07:46,040
遅延束縛があるので
多態性を手にすることができ

131
00:07:46,360 --> 00:07:51,080
それでオブジェクトを再利用することができ
アプリケーションをよりモジュール化することができます。

132
00:07:51,400 --> 00:07:54,920
3つ目の土台はまだ説明していませんが

133
00:07:55,240 --> 00:07:56,800
重要なものです。

134
00:07:57,120 --> 00:08:00,320
オブジェクト指向プログラミングでは

135
00:08:00,640 --> 00:08:02,960
抽象を他の抽象を拡張することで
構築することができる、ということです。

136
00:08:03,280 --> 00:08:07,360
つまりポイントは、クラスを
他のクラスからの差分で定義できるのです。

137
00:08:07,680 --> 00:08:10,320
例えば
「Collection」クラスは

138
00:08:10,640 --> 00:08:12,360
オブジェクトの集合体を管理します。

139
00:08:12,680 --> 00:08:16,040
そしてこのオブジェクトの集合体を

140
00:08:16,360 --> 00:08:18,920
「OrderedCollection」として再定義できます。
順序があるからです。

141
00:08:19,240 --> 00:08:22,960
例えば「Array」は
集合体の一種です。

142
00:08:23,280 --> 00:08:27,480
そしてこの
抽象を他の抽象からの

143
00:08:27,800 --> 00:08:31,520
差分で定義する機構は

144
00:08:31,840 --> 00:08:33,000
「継承(inheritance)」と呼ばれます。

145
00:08:33,320 --> 00:08:37,960
継承はコードをスーパークラスから
再利用する非常に強力なものです。

146
00:08:38,280 --> 00:08:40,960
例えばここで
Collectionのコードは

147
00:08:41,280 --> 00:08:44,040
「OrderedCollection」と「Array」
で再利用されています。

148
00:08:44,360 --> 00:08:48,200
しかし、この講義では説明しませんでした。
他の講義で説明します。

149
00:08:48,520 --> 00:08:50,240
さて、今まで何をお見せしたでしょうか？

150
00:08:50,560 --> 00:08:53,080
オブジェクト指向プログラミングでは

151
00:08:53,400 --> 00:08:58,560
プログラムはメッセージを交換して
協調する実体でできています。

152
00:08:58,880 --> 00:09:01,840
オブジェクトはプライベートなデータを
カプセル化します。

153
00:09:02,160 --> 00:09:07,520
オブジェクトは多態なAPIや
インターフェイスを公開して

154
00:09:07,840 --> 00:09:11,040
オブジェクトを他のオブジェクトと
混ぜて使うことができ

155
00:09:11,360 --> 00:09:13,560
クライアントコードを再利用できるようにします。

156
00:09:13,880 --> 00:09:17,400
そして遅延束縛は鍵となる特徴で

157
00:09:17,720 --> 00:09:19,560
これら全ての動的なものを可能にします。

158
00:09:19,880 --> 00:09:22,480
最終的に、よりモジュール化された
アプリケーションを得ることができます。