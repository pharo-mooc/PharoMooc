
DEBUT cours Pharo : 19/07/2020 - 10:13 - 


Mise à jour : 12:02 13/06/2021



SOMMAIRE
--------

RECHERCHE 

Commandes pharo stable 

MOOC

Autre lien

1 Semaine - Week 1
19/07/2020 - 10:13 - DEBUT - 1 Semaine - Week 1
20/07/2020 - 09:48 - DEBUT - 1 Semaine - Week 1
22/07/2020 - 10:07 - DEBUT - 1 Semaine - Week 1
23/07/2020 - 08:15 - DEBUT - 1 Semaine - Week 1
24/07/2020 - 08:36 - DEBUT - 1 Semaine - Week 1
25/07/2020 - 09:46 - DEBUT - 1 Semaine - Week 1

28/07/2020 - DEBUT - 1 Semaine - Week 1 - mail

02/08/2020 - D10:30 - F12:25 - "Pharo by example 5"
05/08/2020 - D09:58 - F12:04 - "Pharo by example 5"
06/08/2020 - D07:38 - F12:00 - "Pharo by example 5"

07/08/2020 - D08:47 - F12:25 - ProfStef - 2.13
08/08/2020 - D08:51 - F13:02 - ProfStef - 23/29-24/29
09/08/2020 - D10:35 - F13:56 - ProfStef - 24/29-29/29
11/08/2020 - D09:55 - F12:28 - ProfStef - 29/29 - "Pharo by example 5" 2.13 - TestShout

12/08/2020 - D10:14 - F12:34 - pharobyexample5 2.13 - TestShout
14/08/2020 - D12:16 - F12:43 - pharobyexample5 2.13 - Testrunner
18/08/2020 - D11:18 - F13:56 - pharobyexample5 2.13 - Testrunner

CHAP. 3
19/08/2020 - D11:20 - F13:00 - pharobyexample5 - Chap. 3 - Une première application - 3.5 Inspection d'un objet
20/08/2020 - D11:39 - F13:11 - pharobyexample5 - Chap. 3 - Une première application - 3.5 Inspection d'un objet - figure 3.9
21/08/2020 - D12:24 - F13:18 - 3.6 Définition de la classe LOGame - p. 57/376 EN.
23/08/2020 - D12:24 - F13:27 -  Chap. 3 - Une première application - figure 3.12 Initialize game - Pharo by example - p. 63/376 EN
24/08/2020 - D11:08 - F13:10 - Pharo by example - p. 45/259 - p. 63/376 EN
25/08/2020 - D10:06 - F11:33 - Pharo by example - p. 45/259 - p. 63/376 EN
26/08/2020 - D11:31 - F13:32 - Pharo by example - p. 46/259 - p. 64/376 EN
27/08/2020 - D12:35 - F13:52 - Une première application chapitre 3 p.36/259 FR - 50/376 EN
28/08/2020 - D08:02 - F12:33 - Une première application chapitre 3 p.43/259 FR - 59/376 EN
29/08/2020 - D12:22 - F13:49 - Chapitre 3 - 3.8 Terminer le jeu p.46/259 FR - 65/376 EN
30/08/2020 - D10:04 - F14:00 - Chapitre 3 - 3.8 Terminer le jeu p.48/259 FR - 66/376 EN
31/08/2020 - D16:56 - F17:45 - Chapitre 3 - 3.8 Terminer le jeu p.48/259 FR - 66/376 EN
01/09/2020 - D09:53 - F14:01 - Chapitre 3 - 3.8 Terminer le jeu p.39/259 FR - 53/376 EN	
02/09/2020 - D11:13 - F13:00 - Chapitre 3 - 3.4 Ajouter des méthodes à une classe p.38/259 FR - 52/376 EN
23/09/2020 - D11:10 - F12:46 - Chapitre 3 - 3.4 Ajouter des méthodes à une classe p.38/259 FR - 52/376 EN
24/09/2020 - D08:36 - F11:54 - Chapitre 3 - 3.4 Ajouter des méthodes à une classe p.42/259 FR - 58/376 EN
28/09/2020 - D10:39 - F13:53 - Chapitre 3 - 3.4 Ajouter des méthodes à une classe p.42/259 FR - 58/376 EN

CHAP. 4
03/10/2020 - D11:55 - F13:41 - Chapitre 4 - 4.1 Elements syntaxique p.54/259 FR - 77/376 EN
03/10/2020 - D11:55 - F13:41 - Chapitre 4 - 4.1 Elements syntaxique p.54/259 FR - 77/376 EN
05/10/2020 - D09:00 - F13:00 - Chapitre 4 - 4.1 Elements syntaxique p.54/259 FR - 77/376 EN

CHAP. 5
05/10/2020 - D09:00 - F13:00 - Chapitre 5 - Unaire> Binaire> Mots-clés p.65/259 93/376 EN
06/10/2020 - D10:30 - F13:40 - Chapitre 5 - Quand utiliser [] ou () p.69/259 FR 99/376 EN

CHAP. 6
07/10/2020 - D10:51 - F11:47 - Chapitre 6 - p.71/259 FR 103/376 EN
09/10/2020 - D10:33 - F13:45 - Chapitre 6 - p.71/259 FR 103/376 EN
12/10/2020 - D09:12 - F11:55 - Chapitre 6 - p.72/259 FR 104/376 EN
13/10/2020 - D09:52 - F12:10 - Chapitre 6 - p.73/259 FR 105/376 EN
14/10/2020 - D10:42 - F13:32 - Chapitre 6 - p.74/259 FR 107/376 EN
15/10/2020 - D11:19 - F12:10 - Chapitre 6 - p.75/259 FR 109/376 EN
16/10/2020 - D10:11 - F12:00 - Chapitre 6 - p.82/259 FR 117/376 EN
17/10/2020 - D10:01 - F13:07 - Chapitre 6 - p.83/259 FR 120/376 EN
18/10/2020 - D10:59 - F13:43 - Chapitre 6 - p.84/259 FR 122/376 EN
22/10/2020 - D09:59 - F13:31 - Chapitre 6 - p.85/259 FR 123/376 EN
23/10/2020 - D09:42 - F13:42 - Chapitre 6 - p.86/259 FR 124/376 EN
24/10/2020 - D09:42 - F13:50 - Chapitre 6 - p.86/259 FR 124/376 EN
25/10/2020 - D11:11 - F13:36 - Chapitre 6 - p.86/259 FR 124/376 EN
28/10/2020 - D11:04 - F14:04 - Chapitre 6 - p.86/259 FR 128/376 EN
30/10/2020 - D10:11 - F13:06 - Chapitre 6 - p.87/259 FR 125/376 EN
01/11/2020 - D10:43 - F13:42 - Chapitre 6 - p.87/259 FR 126/376 EN
02/11/2020 - D10:41 - F13:59 - Chapitre 6 - p.88/259 FR 127/376 EN
03/11/2020 - D11:39 - F13:47 - Chapitre 6 - p.89/259 FR 129/376 EN

CHAP. 7
04/11/2020 - D10:29 - F11:44 - Chapitre 7 - p.91/259 FR 132/376 EN
05/11/2020 - D09:27 - F13:21 - Chapitre 7 - p.94/259 FR 136/376 EN
06/11/2020 - D11:06 - F13:51 - Chapitre 7 - p.95/259 FR 138/376 EN
07/11/2020 - D08:39 - F13:37 - Chapitre 7 - p.97/259 FR 141/376 EN
08/11/2020 - D10:53 - F15:03 - Chapitre 7 - p.98/259 FR 143/376 EN
09/11/2020 - D10:17 - F14:02 - Chapitre 7 - p.98/259 FR 143/376 EN
10/11/2020 - D13:11 - F16:14 - Chapitre 7 - p.98/259 FR 143-144/376 EN
11/11/2020 - D10:57 - F14:18 - Chapitre 7 - p.99/259 FR 144/376 EN
12/11/2020 - D11:03 - F14:22 - Chapitre 7 - p.100/259 FR 146/376 EN
13/11/2020 - D11:50 - F14:03 - Chapitre 7 - p.100/259 FR 146/376 EN
14/11/2020 - D08:59 - F14:14 - Chapitre 7 - p.103/259 FR 151/376 EN
15/11/2020 - D12:23 - F14:07 - Chapitre 7 - p.104/259 FR 151/376 EN
16/11/2020 - D09:29 - F13:23 - Chapitre 7 - p.106/259 FR 154/376 EN
17/11/2020 - D08:59 - F13:56 - Chapitre 7 - p.107/259 FR 155/376 EN
18/11/2020 - D12:04 - F13:57 - Chapitre 7 - p.107/259 FR 156/376 EN
19/11/2020 - D11:06 - F13:15 - Chapitre 7 - p.108/259 FR 157/376 EN
20/11/2020 - D11:26 - F14:14 - Chapitre 7 - p.108/259 FR 157/376 EN
22/11/2020 - D11:58 - F13:44 - Chapitre 7 - p.109/259 FR 159/376 EN

CHAP. 8
D12:02 23/11/2020 - F13:34 - Chapitre 8 - p.111/259 FR 162/376 EN
D09:02 24/11/2020 - F12:20 - Chapitre 8 - p.118/259 FR 174/376 EN

CHAP. 9
D11:45 25/11/2020 - F14:02 - Chapitre 9 - p.121/259 FR 178/376 EN
D13:15 26/11/2020 - F13:43 - Chapitre 9 - p.121/259 FR 178/376 EN
D12:36 27/11/2020 - F15:04 - Chapitre 9 - p.121/259 FR 178/376 EN
D11:06 28/11/2020 - F13:40 - Chapitre 9 - p.123/259 FR 180/376 EN
D12:08 29/11/2020 - F14:03 - Chapitre 9 - p.124/259 FR 182/376 EN
D11:47 03/12/2020 - F13:53 - Chapitre 9 - p.125/259 FR 184/376 EN
D13:06 07/12/2020 - F13:45 - Chapitre 9 - p.125/259 FR 183/376 EN
D09:54 08/12/2020 - F12:30 - Chapitre 9 - p.126/259 FR 184/376 EN
D11:36 09/12/2020 - F13:58 - Chapitre 9 - p.126/259 FR 186/376 EN
D10:11 10/12/2020 - F12:36 - Chapitre 9 - p.127/259 FR 186/376 EN
D10:57 11/12/2020 - F13:38 - Chapitre 9 - p.127/259 FR 186/376 EN
D12:43 13/12/2020 - F13:40 - Chapitre 9 - p.127/259 FR 186/376 EN
D11:09 14/12/2020 - F13:02 - Chapitre 9 - p.128/259 FR 187/376 EN
D11:15 17/12/2020 - F13:36 - Chapitre 9 - p.129/259 FR 189/376 EN
D11:10 18/12/2020 - F13:51 - Chapitre 9 - p.129/259 FR 189/376 EN
D09:41 19/12/2020 - F13:44 - Chapitre 9 - p.129/259 FR 189/376 EN
D11:13 21/12/2020 - F13:35 - Chapitre 9 - p.129/259 FR 189/376 EN
D12:43 22/12/2020 - F13:22 - Chapitre 9 - p.129/259 FR 189/376 EN
D11:08 24/12/2020 - F13:13 - Chapitre 9 - p.131/259 FR 192/376 EN - ligne 134

CHAP. 10
D09:16 31/12/2020 - F12:52 - Chapitre 10 - p.133/259 FR 196/376 EN
D12:06 01/01/2021 - F13:11 - Chapitre 10 - p.133/259 FR 196/376 EN
D13:03 02/01/2021 - F13:33 - Chapitre 10 - p.133/259 FR 196/376 EN
D09:16 07/01/2021 - F13:27 - Chapitre 10 - p.134/259 FR 198/376 EN
D12:07 10/01/2021 - F13:15 - Chapitre 10 - p.135/259 FR 199/376 EN
D10:10 11/01/2021 - F12:02 - Chapitre 10 - p.135/259 FR 199/376 EN
D10:25 12/01/2021 - F13:11 - Chapitre 10 - p.136/259 FR 200/376 EN
D10:35 14/01/2021 - F12:45 - Chapitre 10 - p.136/259 FR 200/376 EN
D11:02 15/01/2021 - F11:27 - Chapitre 10 - p.136/259 FR 200/376 EN
D11:40 17/01/2021 - F14:23 - Chapitre 10 - p.137/259 FR 202/376 EN
D09:57 22/01/2021 - F13:12 - Chapitre 10 - p.138/259 FR 202/376 EN
D11:26 23/01/2021 - F13:10 - Chapitre 10 - p.138/259 FR 203/376 EN
D11:54 24/01/2021 - F11:56 - Chapitre 10 - p.138/259 FR 203/376 EN
D10:19 26/01/2021 - F11:46 - Chapitre 10 - p.138/259 FR 203/376 EN
D11:02 30/01/2021 - F13:30 - Chapitre 10 - p.139/259 FR 204/376 EN
D09:47 04/02/2021 - F10:20 - Chapitre 10 - p.139/259 FR 204/376 EN
D09:25 05/02/2021 - F13:00 - Chapitre 10 - p.140/259 FR 206/376 EN
D11:23 19/02/2021 - F13:52 - Chapitre 10 - p.143/259 FR 210/376 EN
D12:24 21/02/2021 - F16:50 - Chapitre 10 - p.144/259 FR 211/376 EN
D10:58 04/03/2021 - F13:41 - Chapitre 10 - p.145/259 FR 213/376 EN
D08:18 09/03/2021 - F13:43 - Chapitre 10 - p.147/259 FR 216/376 EN
D17:24 12/03/2021 - F18:07 - Chapitre 10 - p.152/259 FR 223/376 EN
D09:36 13/03/2021 - F10:56 - Chapitre 10 - p.152/259 FR 223/376 EN
D09:34 15/03/2021 - F13:23 - Chapitre 10 - p.152/259 FR 223/376 EN
D11:17 17/03/2021 - F13:10 - Chapitre 10 - p.152/259 FR 223/376 EN
D12:32 19/03/2021 - F13:45 - Chapitre 10 - p.153/259 FR 224/376 EN
D11:13 21/03/2021 - F13:47 - Chapitre 10 - p.154/259 FR 225/376 EN
D10:27 26/03/2021 - F12:25 - Chapitre 10 - p.154/259 FR 226/376 EN
D10:56 06/04/2021 - F12:20 - Chapitre 10 - p.155/259 FR 226/376 EN
D10:26 09/04/2021 - F13:14 - Chapitre 10 - p.157/259 FR 230/376 EN
D10:24 10/04/2021 - F13:23 - Chapitre 10 - p.158/259 FR 231/376 EN
D12:23 11/04/2021 - F13:40 - Chapitre 10 - p.160/259 FR 233/376 EN
D08:59 12/04/2021 - F12:34 - Chapitre 10 - p.162/259 FR 237/376 EN

CHAP. 11
D10:26 13/04/2021 - F13:01 - Chapitre 11 - p.163/259 FR 239/376 EN
D11:44 14/04/2021 - F13:42 - Chapitre 11 - p.165/259 FR 241/376 EN
D11:47 15/04/2021 - F13:53 - Chapitre 11 - p.165/259 FR 241/376 EN
D11:22 16/04/2021 - F13:58 - Chapitre 11 - p.165/259 FR 242/376 EN
D11:56 18/04/2021 - F18:34 - Chapitre 11 - p.165/259 FR 242/376 EN
D09:41 19/04/2021 - F13:50 - Chapitre 11 - p.166/259 FR 243/376 EN
D11:13 20/04/2021 - F11:57 - Chapitre 11 - p.166/259 FR 243/376 EN
D13:48 21/04/2021 - F14:02 - Chapitre 11 - p.166/259 FR 243/376 EN
D09:41 22/04/2021 - F12:35 - Chapitre 11 - p.167/259 FR 243/376 EN
D09:17 23/04/2021 - F12:59 - Chapitre 11 - p.169/259 FR 247/376 EN
D07:53 24/04/2021 - F10:22 - Chapitre 11 - p.169/259 FR 247/376 EN
D11:51 25/04/2021 - F16:44 - Chapitre 11 - p.172/259 FR 251/376 EN

CHAP. 12
D12:23 26/04/2021 - F15:55 - Chapitre 12 - p.174/259 FR 255/376 EN
D13:12 27/04/2021 - F13:25 - Chapitre 12 - p.175/259 FR 255/376 EN
D13:25 28/04/2021 - F14:12 - Chapitre 12 - p.175/259 FR 255/376 EN
D10:53 29/04/2021 - F13:22 - Chapitre 12 - p.177/259 FR 258/376 EN
D10:57 30/04/2021 - F13:53 - Chapitre 12 - p.179/259 FR 261/376 EN
D12:01 01/05/2021 - F14:38 - Chapitre 12 - p.179/259 FR 262/376 EN
D12:40 02/05/2021 - F13:35 - Chapitre 12 - p.180/259 FR 263/376 EN
D12:24 03/05/2021 - F13:51 - Chapitre 12 - p.180/259 FR 263/376 EN
D16:57 03/05/2021 - F17:59 - Chapitre 12 - p.184/259 FR 268/376 EN
D11:37 04/05/2021 - F13:57 - Chapitre 12 - p.186/259 FR 271/376 EN
D12:22 06/05/2021 - F13:41 - Chapitre 12 - p.187/259 FR 272/376 EN
D11:53 07/05/2021 - F14:13 - Chapitre 12 - p.187/259 FR 272/376 EN
D11:44 09/05/2021 - F12:18 - Chapitre 12 - p.187/259 FR 272/376 EN

CHAP. 13
D12:18 09/05/2021 - F00:00 - Chapitre 13 - p.188/259 FR 275/376 EN
D12:18 09/05/2021 - F13:20 - Chapitre 13 - p.194/259 FR 284/376 EN
D10:50 10/05/2021 - F11:49 - Chapitre 13 - p.194/259 FR 284/376 EN

CHAP. 14
D11:50 10/05/2021 - F00:00 - Chapitre 14 - p.214/259 FR 313/376 EN
D11:50 10/05/2021 - F13:45 - Chapitre 14 - p.215/259 FR 314/376 EN
D10:44 11/05/2021 - F13:52 - Chapitre 14 - p.215/259 FR 315/376 EN
D11:16 12/05/2021 - F13:23 - Chapitre 14 - p.216/259 FR 316/376 EN
D18:17 13/05/2021 - F20:00 - Chapitre 14 - p.216/259 FR 317/376 EN
D07:41 14/05/2021 - F12:39 - Chapitre 14 - p.216/259 FR 317/376 EN
D08:51 15/05/2021 - F10:16 - Chapitre 14 - p.218/259 FR 319/376 EN
D09:44 16/05/2021 - F12:50 - Chapitre 14 - p.220/259 FR 321/376 EN
D11:01 17/05/2021 - F13:34 - Chapitre 14 - p.221/259 FR 322/376 EN
D10:24 18/05/2021 - F13:15 - Chapitre 14 - p.221/259 FR 324/376 EN
D10:51 19/05/2021 - F13:32 - Chapitre 14 - p.224/259 FR 327/376 EN
D10:38 20/05/2021 - F13:48 - Chapitre 14 - p.225/259 FR 329/376 EN
D10:16 24/05/2021 - F00:00 - Chapitre 14 - p.226/259 FR 330/376 EN
D17:06 24/05/2021 - F17:26 - Chapitre 14 - p.226/259 FR 330/376 EN
D07:16 25/05/2021 - F11:27 - Chapitre 14 - p.231/259 FR 338/376 EN

CHAP. 15
D07:16 25/05/2021 - F11:27 - Chapitre 15 - p.232/259 FR 339/376 EN
D07:16 25/05/2021 - F13:28 - Chapitre 15 - p.235/259 FR 343/376 EN
D11:27 26/05/2021 - F13:49 - Chapitre 15 - p.236/259 FR 345/376 EN
D08:22 27/05/2021 - F09:54 - Chapitre 15 - p.237/259 FR 345/376 EN
D12:43 28/05/2021 - F13:28 - Chapitre 15 - p.237/259 FR 346/376 EN
D09:13 29/05/2021 - F10:10 - Chapitre 15 - p.237/259 FR 346/376 EN
D09:47 30/05/2021 - F13:20 - Chapitre 15 - p.249/259 FR 362/376 EN

CHAP. 16
D08:58 01/06/2021 - F00:00 - Chapitre 16 - p.250/259 FR 363/376 EN
D08:58 01/06/2021 - F13:34 - Chapitre 16 - p.251/259 FR 365/376 EN
D08:39 03/06/2021 - F13:38 - Chapitre 16 - p.251/259 FR 365/376 EN
D11:20 04/06/2021 - F13:50 - Chapitre 16 - p.253/259 FR 367/376 EN
D10:48 06/06/2021 - F13:11 - Chapitre 16 - p.254/259 FR 368/376 EN
D11:02 07/06/2021 - F14:17 - Chapitre 16 - p.254/259 FR 368/376 EN
D09:09 08/06/2021 - F12:58 - Chapitre 16 - p.254/259 FR 368/376 EN
D09:11 09/06/2021 - F14:28 - Chapitre 16 - p.257/259 FR 373/376 EN
D06:41 10/06/2021 - F12:13 - Chapitre 16 - p.257/259 FR 373/376 EN
D09:17 11/06/2021 - F12:17 - Chapitre 16 - p.257/259 FR 373/376 EN
D09:02 13/06/2021 - F11:53 - Chapitre 16 - p.258/259 FR 375/376 EN






























-------------------------------------------------------------------------------------------------------19/07/20 debut


RECHERCHE
---------

recherche : 
mathmorphs
phratch

MathMorphs is a new project where we combine Mathematics and Smalltalk.
http://www.dm.uba.ar/MathMorphs/


Commandes pharo stable 
-----------------------

Phratch, un autre langage de programmation open source a but éducatif, basé sur Pharo. 
sudo add-apt-repository ppa:pharo/stable
sudo apt-get update
sudo apt-get install phratch pharo-vm-desktop
http://www.phratch.com/phratch/phratchinstall
https://la-vache-libre.org/phratch-un-langage-de-programmation-a-but-educatif-base-sur-pharo/


MOOC
----

MOOC pharo - http://mooc.pharo.org/#week1 - FR
[PARENTDIR]	Parent Directory	 	- 	 
[DIR]	Teaser/	2019-12-16 11:04 	- 	 
[TXT]	VerificationLog.txt	2019-12-16 11:04 	1.9K	 
[DIR]	W1/	2019-12-16 11:04 	- 	 
[DIR]	W2/	2019-12-16 11:04 	- 	 
[DIR]	W3/	2019-12-16 11:04 	- 	 
[DIR]	W4/	2019-12-16 11:04 	- 	 
[DIR]	W5/	2019-12-16 11:04 	- 	 
[DIR]	W6/	2019-12-16 11:04 	- 	 
[DIR]	W7/	2019-12-16 11:04 	- 	 
Apache Server at rmod-pharo-mooc.lille.inria.fr Port 80
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Subtitles/

vidéo pharo - FR
[PARENTDIR]	Parent Directory	 	- 	 
[VID]	01-FirstLookAtClassObjectMethods.mp4	2018-06-19 16:09 	47M	 
[ ]	01-FirstLookAtClassObjectMethods.pdf	2019-12-16 11:09 	1.2M	 
[VID]	02-WhatisAnObject.mp4	2018-06-19 16:09 	48M	 
[ ]	02-WhatisAnObject.pdf	2019-12-16 11:09 	489K	 
[VID]	03-WhatisAClass.mp4	2018-06-19 16:09 	41M	 
[ ]	03-WhatisAClass.pdf	2019-12-16 11:09 	953K	 
[VID]	04-MethodVsMessages.mp4	2018-06-19 16:09 	51M	 
[ ]	04-MethodVsMessages.pdf	2019-12-16 11:09 	963K	 
[VID]	05-OOParadigm.mp4	2018-06-19 16:09 	72M	 
[ ]	05-OOParadigm.pdf	2019-12-16 11:09 	393K	 
Apache Server at rmod-pharo-mooc.lille.inria.fr Port 80
http://rmod-pharo-mooc.lille.inria.fr/MOOC/2018-PreSequelOOP-FR/


Autre lien : 
https://www.canal-u.tv/video/inria/redo_coding_a_counter.32705



1 Semaine - Week 1
==================

19/07/2020 - 10:13 - DEBUT - 1 Semaine - Week 1
--------------------------

Il m'aura fallu la fin des leçons de W1 pour comprendre comment ça fonctionne.

SOMMAIRE (créé le 20/07/2020 - 11:40- 12:18)

Page d'accueil : Semaines des cours : 
----------------
http://mooc.pharo.org/


Cours 1 Semaine :
----------------- 
http://mooc.pharo.org/#week1


Download the Slides :
---------------------
Les slides (HTML, PDF) sont similaires et également similaires aux cours (lecture de 1 à 6).
http://mooc.pharo.org/#week1
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/


Download the Videos : 
---------------------
Correspond aux live 7 à 10 (non triés)
7 [ ]	C019-W1S-Videos-SelectionExpression-2-FR-V2-HD_720p_4Mbs.m4v	2016-05-11 11:56 	1.8M
8 C019-Videos-ProfStef-V2-HD_720p_4Mbs.m4v	2016-05-11 11:46 	4.1M	 
8 [VID]	C019-Videos-ProfStef-V2-HD_720p_4MbsConvertedTrial.mp4	2016-08-29 10:45 	2.1M	 
9 [ ]	C019-W1S-Videos-ColoringExpression-FR-CM-v3-HD_720p_4Mbs.m4v	2016-05-12 15:37 	7.3M	 
10 [ ]	C019-W1S-Videos-Shortcuts-FR-IR-HD_720p_4Mbs.m4v
11 [ ]	C019-W1S-Videos-Redo-Counter-Traditional-FR-V3-HD_720p_4Mbs.m4v	2016-05-11 11:56 	27M	 
11 [VID]	C019-W1S-Videos-Redo-Counter-Traditional-FR-v4.mp4	2016-04-26 11:35 	156M	

Correspond aux lecture 1 à 6
[VID]	C019SD-W1-S1-v3.mp4	2016-03-07 17:06 	90M	 
[VID]	C019SD-W1-S2-v2.mp4	2016-02-29 16:15 	165M	 
[VID]	C019SD-W1-S3-v2.mp4	2016-02-29 16:15 	137M	 
[VID]	C019SD-W1-S4-v3.mp4	2016-03-07 17:06 	120M	 
[VID]	C019SD-W1-S5-v2.mp4	2016-02-29 16:15 	230M	 
[VID]	C019SD-W1-S6-v3.mp4
http://mooc.pharo.org/#week1 
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/


Download the subtitles in french, english, spanish and japanese :
---------------------------------
Fichiers str
http://mooc.pharo.org/#week1
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Subtitles/


Download the exercices : 
-----------------------
Exercices html, pdf, text (multilangue)
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Exercises/
http://mooc.pharo.org/#week1



19/07/2020 - 10:15 - DEBUT - 1 Semaine - Week 1
--------------------

Slides
-------
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/C019-W1S05-PharoSyntaxInANutshell.html#slide-4
ZnEasy -> Une classe commence toujours par une majuscule
getPng: -> Un message
'http://pharo.org/web/files/pharo.png' -> une chaîne
Le message getPng: est envoyé à la classe ZnEasy avec une chaîne 'http://pharo.org/web/files/pharo.png' comme argument
Les messages asMorph et openInWindow sont de gauche à droite ?

Synthaxe
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/C019-W1S05-PharoSyntaxInANutshell.html#slide-5

Priorité du message 
(Msg)> Unaire> Binaire> Mots clés
Cette commande minimise () les besoins
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/C019-W1S05-PharoSyntaxInANutshell.html#slide-9

Pas de parenthèse contrairement à slide "Synthaxe" ?
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/C019-W1S05-PharoSyntaxInANutshell.html#slide-13

Class Definition Template - Vide (Firefox browser 78.0.2 - Chrome Version 83.0.4103.61)
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/C019-W1S05-PharoSyntaxInANutshell.html#slide-21
Class Definition within the IDE - Vide
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/C019-W1S05-PharoSyntaxInANutshell.html#slide-22
Method Definition Example
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/C019-W1S05-PharoSyntaxInANutshell.html#slide-24
3 types de messages:
Unaire: Node new
Binary: 1+2,3@4
Mots clés: 2 between: 10 and: 20
Priorité du message:
(Msg)> unaire> binaire> mot clé
Messages de même niveau: de gauche à droite
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/C019-W1S05-PharoSyntaxInANutshell.html#slide-25


PDF 
***
reprend les slides ci-dessus de 1 à 25 : SyntaxInANutshell
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/C019-W1S05-PharoSyntaxInANutshell.pdf


Slides 
-------
Class Definition in Pharo - Vide
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/C019-W1S06-ClassAndMethodDefinition.html#slide-2
Method Definition in Pharo - Vide
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/C019-W1S06-ClassAndMethodDefinition.html#slide-4
Presentation Convention - Vide
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/C019-W1S06-ClassAndMethodDefinition.html#slide-7

Ce que vous devriez savoir
     Une classe est définie en envoyant un message à sa superclasse
     Les classes sont définies à l'intérieur des packages
     Les méthodes sont publiques
     Par défaut, une méthode renvoie le récepteur, self
     Les méthodes de classe ne sont que des méthodes du côté de la classe
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/C019-W1S06-ClassAndMethodDefinition.html#slide-11

Class Methods - Il manque quelque chose ? (blanc en haut)
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/C019-W1S06-ClassAndMethodDefinition.html#slide-10


PDF
*** 
reprend les slides ci-dessus de 1 à 10 : ClassAndMethodDefinition
les classes et les méthodes sont définies dans les outils 
il n'y a pas de syntaxe dédiée
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Slides/Week1/C019-W1S06-ClassAndMethodDefinition.pdf


[ ]	C019-Videos-ProfStef-V2-HD_720p_4Mbs.m4v	2016-05-11 11:46 	4.1M	 				//ProfStef identique
[VID]	C019-Videos-ProfStef-V2-HD_720p_4MbsConvertedTrial.mp4	2016-08-29 10:45 	2.1M	//ProfStef identique

http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/

19/07/2020 - 12:20 fin
Cours : C019SD-W1-S1-v3

Enfin présentation de pharo.
syntax (carte postal) + model ( )

Livres : 
-------
Livres pour débutant deux versions : 
Pharo by example 2011 FR et Pharo by example 5 2018 EN : http://books.pharo.org EN 
(bas de page pharo par l'exemple pourquoi il n'est pas à côté de celui en anglais ?) 
http://books.pharo.org/pharo-par-lexemple/ FR 

1 EN Pharo by exemple (29.09.2018) 
http://books.pharo.org/updated-pharo-by-example/pdf/2018-09-29-UpdatedPharoByExample.pdf - Traduction Pharo by exemple

2 FR Pharo par l'exemple (20.06.2011) 
https://gforge.inria.fr/frs/download.php/28665/PharoParLExemple-20-06-2011.pdf


pdf to docx - pdf2docx.com/fr
docx to html - https://convertio.co/download/4cf1d3dfe3306369e84408086ec3bb4acaed9b/ (La marge de droite cache des mots)

Liens autres livres 
http://books.pharo.org

http://pharo.org/download
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/C019SD-W1-S1-v3.mp4
-------------------------------------------------------------------------------------------------------19/07/20 fin

-------------------------------------------------------------------------------------------------------20/07/20 debut
20/07/2020 - 09:48 - DEBUT - 1 Semaine - Week 1
---------------------------

1 Lecture Objectives of this MOOC
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/

2 Lecture Pharo: an Immersive Object-Oriented System
Similaire à W1-S1-v3.mp4
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/C019SD-W1-S2-v2.mp4

3 Lecture Pharo Vision
Pharo vision
http://pharo.org/success
http://consortium.pharo.org (list sociétés)
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/C019SD-W1-S3-v2.mp4

4 Lecture Pharo Object Model in a Nutshell
Pharo object model in a nutshell
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/C019SD-W1-S4-v3.mp4

5 Lecture Pharo Syntax in a Nutshell
Pharo syntax in a nutshell - FIN 11:16
	The complet syntax on a postcard
	
	définit une méthode 					: exampleWithNumber:x (<- x est l'argument)
											"This method illustrates the complete syntax."
											<aMethodAnnotation>
							
	définition locale de variable 			: |y|
												true & false not & (nil isNil)
												ifFalse: [self halt].
	
	affectation - = 						: y:= self size + super size. (<- le point "." est un séparateur d'instruction)
				
	boucle 									: do: [:each | Transcript
													show: (each class name);
													show: (each printString);
													show: ''].
	return - permet de rendre une valeur 	: ^
	
'Hello World" as Morph openInWindow	-> 'Hello Wordl" = chaîne

(ZnEasy getPng: 'http://pharo.org/web/files/pharo.png')
asMorph openInWindow

La classe commence toujours avec une majuscule : ZnEasy
La méthode le message : getPng		
Un argument ":" en attente : :
La chaine : 'http://pharo.org/web/files/pharo.png' 		

chaine argument de la méthode getpng.	

4:46 Essential Constructs
	Déclaration d'une variable temporaire : [var]
	Assigner une variable : var:=aValue
	Séparateur : message.message
	Retour : ^expression
	Bloc
	
Browser : Nautilus
-------

Fenetre 1 : Package	Fenetre 2 : Class	Fenetre 3 : 

Fenetre 4 du bas : Template (corps et code de la méthode)

Package 									Class					Method	
											Integer					Factorial

ZincHTTP									Zneasy					
				
[Method] ->		[Messages] -> 				[Objets] 						-> Temporaire [Block]
				Unary	(factorial			Blocks (fonction anonyme)
				Binary (=,>,*,-)
				Keyword (iftrue, error
				Conditions
				Boucles
				Itérateurs

Priorité du message 
(Msg)> Unaire> Binaire> Mots clés
Cette commande minimise () les besoins

L'argument ":" de la fonction "each" : [:each
14:55 -
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/C019SD-W1-S5-v2.mp4

6 Lecture Class and Method Definitions
Class and method - D 11:16 - F 11:36 - FIN W1
5:15 bouton class avant de créer la méthode ?
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/C019SD-W1-S6-v3.mp4

7 Live Selecting and executing expressions
Définitions classes et méhtodes
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/C019-W1S-Videos-SelectionExpression-2-FR-V2-HD_720p_4Mbs.m4v

8 Live Learn Pharo with Prof Stef
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/C019-Videos-ProfStef-V2-HD_720p_4Mbs.m4v

9 Live Syntax Highlighting gives Feedback
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/

10 Live Learn Keyboard Shortcuts
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/


11 Redo Coding a Counter
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/


12 Exercise Expressions and Messages
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Exercises/
-------------------------------------------------------------------------------------------------------20/07/20 fin

-------------------------------------------------------------------------------------------------------22/07/20 debut
--------------- DEBUT 12 Exercise Expressions and Messages ---------------------- DEBUT 12 Exercise Expressions and Messages

22/07/2020 - 10:07 - DEBUT - 1 Semaine - Week 1
---------------------

http://pharo.org/download
PharoLauncher version 64bits (pharo-launcher-2.2.msi) - il a fallu lire un message (3) et lire la documentation.
Alors qu'il aurait été plus simple de mettre "Windows 64 bits" sur le bouton de téléchargement.

Installation de pharo - depuis un compte User
1 C:\Users\Utiwin\AppData\Local\PharoLauncher\ ? (en user)
C:\Program Files\Pharo (demande les droits mais le programme ne propose rien)
2 Pas assez de privilège. (Ca commence bien)
3 Cette application ne peut pas s'exécuter sur ce pc. (Mdr ! )
C:\Users\[User]\AppData\Local\PharoLauncher\
pharo-users@list.pharo.org (mail programme "pharolauncher v.2.2")

Installation de pharo - depuis un compte Admin
1 Installer information - Error writing to file :
D:\Liberkeys\MyApps\Pharo\FileAttributesPlugin.dll_Zone.Identifier. 
Verify that you have access to that directory.
2 Installer Information - The installer has insufficient privileges to access this directory :
C:\Program Files\PharoLauncher.
The installation cannot continue. Log on as administrator or contact your system administrator.(Ca devient moin marrant cette merde)
3 Cette application ne peut pas s'exécuter sur ce pc.
C:\Users\[Admin]\AppData\Local\PharoLauncher\

(22/07/2020 - 11:15)
1 Télécharger les deux packages "pharo image" et "pharo vm".
 You can download the Pharo VM and image as separated packages.
    Pharo image: 64bit (default) | 32bit
	https://files.pharo.org/get-files/80/pharo.zip
    PharoVM 8.0 for Windows: 64bit | 32bit (default)
	https://files.pharo.org/get-files/80/pharo-win-stable.zip
Extraire les deux zip dans : 
D:\Liberkeys\MyApps\Pharo
-------------------------------------------------------------------------------------------------------22/07/20 fin

-------------------------------------------------------------------------------------------------------23/07/20 debut
23/07/2020 - 08:15 - DEBUT - 1 Semaine - Week 1
Je cherche une solution pour résoudre l'exercice "12 Exercise Expressions and Messages".
Exercice 12 - 27. Défi 0
Relecture des moocs.

Pharo 8.0> Tools> System Browser> 
	* Fenêtre package en haut aucun cadre de recherche ?
	* La fenêtre package ne prend pas en compte l'affectation d'une lettre à un package, 
	obligé de descendre l'ascenseur pour atteindre le packet "Zinc HTTP" (programme archaique)

Menu Word
---------
Pharo> fermeture welcome> 2 clic gauche pour faire apparaitre le menu word.

ProfStef avec Playground
------------------------

ProfStef> Tools> Playground ou 2 clic gauche sur l'espace de travail pharo> Word> Tools> Playground //CTRL + O + W

Playground> Respecter les majuscules/minuscules sinon ça ne fonctionne pas.

ProfStef au lieu de profstef (= en rouge ne fonctionne pas)

Playground (CTRL+O+W)> ProfStef go


ProfStef avec Transcript
------------------------

Transcript (CTRL+O+T)> ProfStef go


Exercice à faire EN
La fenêtre présente les commentaires sur l'exercice et touches raccourcies
Exercices : 
1.+2 (Clique à droite du chiffre 2 puis Touche clavier CTRL + P pour afficher le résultat).
ProfStef next. (Clique à droite du point puis Touche clavier CTRL + D pour passer à la leçon suivante)
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/C019-Videos-ProfStef-V2-HD_720p_4Mbs.m4v

System browser 09:00 - 09:39 Mycounter - 10:08 Transcript 
 
00:12 - 14:56 - Moins complet sous Windows (captures systbrow00120-00121) (Exemple : systbrow00120_2020-07-23.png)
00:28 - Impossible de filtrer (captures systbrow00280-00281) - 

"La fenêtre "Filtrage" n'est plus en haut et en blanc mais en bas avec une couleur identique à la liste des packages".
	Filter....

02:24 - Commentaire, enregistrement, message "Author identification".


1 Solution Exercice 12 - 27. Défi 0
Author identification. Please type your full name.
It will be used to sign the changes you make to the image.
Spaces, accentes, dashes, underscore and similar characters are not allowed (systbrow2020-07-23_102903.png)
Solution : mettre un prenom et un nom.
Pour FirstnameLastname mettre LObjetVivantcoule


2 Solution Exercice 12 - 27. Défi 0
05:19 - Use assert:equals:instead of asser and = (or deny//identicalTo: and ==) (systbrow0519_xxxx et systbrow0519_2xxxx)


23/07/2020 - 11:27 (Reprise Solution Exercice 12 - 27. Défi 0)
8:27 / 15:52 - 14/28 - 
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/C019SD-W1-S5-v2.mp4 


23/07/2020 - Debut 11:35 Fin 12:01 - 1 Semaine - Week 1
-------------------------

3 Solution Exercice 12 - 27. Défi 0
En passant par le browsersystem, j'arrive à :
Trouver "sans filtre" le serveur "HTTP Zinc",
Lancer la classe "ZnEasy",
Inst. side method,
messageSelectorAndArgumentNames
Coller le code ci-dessous : 
(ZnEasy getPng: 'http://pharo.org/web/files/pharo.png')
asMorph openInWindow
Message "[ZnEasy] Refers to class name instead of "self class"

4 Solution Exercice 12 - 27. Défi 0 - (La méthode ?)
Serveur "HTTP Zinc",
Classe "ZnEasy",
Ismethod, //effacer contenu
Code : 
(ZnEasy getPng: 'http://pharo.org/web/files/pharo.png')
asMorph openInWindow
Message "[ZnEasy] Refers to class name instead of "self class" 

5 Solution Exercice 12 - 27. Défi 0 - (La méthode ?)
Serveur "HTTP Zinc",		//Ajout "ZnEasy", Variable "easy".
Classe "ZnEasy",
Code : 
(ZnEasy getPng: 'http://pharo.org/web/files/pharo.png')
asMorph openInWindow
Message 
Message pattern expected ->(ZnEasy getPng: 'http://pharo.org/web/files/pharo.png')
asMorph openInWindow
"[ZnEasy] Refers to class name instead of "self class"

6 Solution Exercice 12 - 27. Défi 0 - (La méthode ?)
Serveur "HTTP Zinc",		//Ajout "ZnEasy"
Classe "ZnEasy",
Code : 
(ZnEasy getPng: 'http://pharo.org/web/files/pharo.png')
asMorph openInWindow
Message 
 Message pattern expected ->(ZnEasy getPng: 'http://pharo.org/web/files/pharo.png')
asMorph openInWindow
"[ZnEasy] Refers to class name instead of "self class"

7 Solution Exercice 12 - 27. Défi 0 - (La méthode ?)
Serveur "HTTP Zinc",		//Ajout "ZnEasy"
Classe "ZnEasy",
Ismethod,
Code : 
(ZnEasy getPng: 'http://pharo.org/web/files/pharo.png')
asMorph openInWindow
Message 
Message pattern expected ->(ZnEasy getPng: 'http://pharo.org/web/files/pharo.png')
asMorph openInWindow
"[ZnEasy] Refers to class name instead of "self class"

8 Solution (Grosse galère) Exercice 12 - 27. Défi 0 - (La méthode ?)
Serveur "HTTP Zinc",
Classe "ZnEasy",
New protocol,
"morph",
Code : 
(ZnEasy getPng: 'http://pharo.org/web/files/pharo.png')
asMorph openInWindow
Sauvegarde,
Message "This smell arises when a method is implemented but never sent. If a method is not sent, it can be removed. This rule pays attention not to identify as unsent methods, methods with pragmas and test methods since they are likely to be sent through reflection.
Now if your code is used and extended by others better use a deprecation mechanism. To define a deprecate method follow the pattern: "
Suppression methode Message "Message pattern expected"	

9 Solution Exercice 12 - 27. Défi 0 - (Zinc-HTTP ?)
Playground
Collage du code : (fonctionne en cinq cinq)
(ZnEasy getPng: 'http://pharo.org/web/files/pharo.png')
asMorph openInWindow
Do it (flèche verte),
Le logo apparaît.
-------------------------------------------------------------------------------------------------------23/07/20 fin

-------------------------------------------------------------------------------------------------------24/07/20 debut
24/07/2020 - 08:36 - DEBUT - 1 Semaine - Week 1
Pharo launcher - down 64bit
http://pharo.org/download

reprise 8:27 / 15:52 - 14/28 -
9/28 - 05:35 messages unaire, binaire, clé
8/40 - 16:28 methode "factorial"
24/28 - 14:26 definition d'une methode "factorial"
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/C019SD-W1-S5-v2.mp4

08:45 - 09:44 
wget -O- | bash				//ne fonctionne pas
? https://github.com/pharo-project/pharo-zeroconf
09:44 - 10:07 Installation pharolauncher, prend en compte l'image sur le disque mais
veut impérativement se connecter sur le web bloquant l'utilisation du programme. :-(

10:08 - 10:40 Exercice 12 - 27. Défi 0
1 Affiche le logo
(ZnEasy getPng: 'http://pharo.org/web/files/pharo.png')
asMorph openInWindow
2 CTRL + P à droite du point pour lancer le test de connexion.
ZnEasy get: 'http://zn.stfx.eu/zn/small.html'.

10:40 - 
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Videos/W1/C019-W1S-Videos-Redo-Counter-Traditional-FR-v4.mp4
-------------------------------------------------------------------------------------------------------24/07/20 fin

-------------------------------------------------------------------------------------------------------25/07/20 debut
25/07/2020 - 09:46 - DEBUT - 1 Semaine - Week 1
Recherche startpage : tuto pharo Zinc-HTTP ZnEasy asMorph openInWindow
Recherche st : online pharo
[faut pas se prendre la tête]
https://www.fun-mooc.fr/courses/course-v1:inria+41010+self_paced/about

Solution : 10:
----------
(ZnEasy getPng: 'http://pharo.org/web/files/pharo.png')
asMorph openInWindow
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Exercises/Challenge0-Solution-FR.html

12 Exercise Expressions and Messages
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Exercises/
http://mooc.pharo.org/#week1
--------------- FIN 12 Exercise Expressions and Messages ---------------------- FIN 12 Exercise Expressions and Messages - 1 Semaine - Week 1

13 Exercise TinyBlog: Presentation and Model
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Exercises/

14 Challenge Challenge 0
http://rmod-pharo-mooc.lille.inria.fr/MOOC/Exercises/


1 Semaine - Week 1 : standby exercice 12 internet HS
==================

Mail "Pharo_negatfis_positifs.txt"
25/07/2020 : +2 heures
-------------------------------------------------------------------------------------------------------25/07/20 fin


28/07/2020 : +2 heures

"Pharo by example 5"
Standby "12 Exercise Expressions and Messages"
Lecture du pdf "Pharo by example 5".


02/08/2020 - D10:30 - F12:25 - "Pharo by example 5"


05/08/2020 - D09:58 - F12:04 - "Pharo by example 5"


-------------------------------------------------------------------------------------------------------05/08/20 debut
05/08/2020 - D09:58 - F12:04 - "Pharo by example 5"  
12 Le navigateur système - The system browser
Système : Windows 10, 32 bits
Programme : Pharo 8.0 

"Pharo by example 5" - 2.10 The system browser
 The system browser
execute the following code snippet:
Nautilus openOnMethod: Integer>>#factorial
Fenêtre : Unknown variable: Nautilus please correct, or cancel:

Le Nautilus est absent, aurait-il coulé ?

Navigateur : 
-----------
Réponse pour « System Browser ».
System Browser openOnMethod: Integer>>#factorial
Fenêtre : Unknown variable: Nautilus please correct, or cancel:

Donc, le nom du navigateur n'est pas celui que l'on voit, mais celui que l'on signe.
Cela revient à appeler le navigateur « Goggle chrome », mais son nom serait « quatre couleurs », 
ce n'est pas cohérent cette histoire. 

Je m'appelle : System Browser 		Mon nom est : ClyFullBrowser

						Classe	Methode
System Browser -> ClyFullBrowser openOnMethod: Integer>>#factorial - CTRL + P -> ouvre System Browser
-------------------------------------------------------------------------------------------------------05/08/20 fin

-------------------------------------------------------------------------------------------------------06/08/20 debut
06/08/2020 - D07:38 - F12:00 - "Pharo by example 5"

Création d'une carte correspondant aux itinéraires empruntés avec ou sans embûches.
Nom carte "Ph_itineraires_gng_p43.png".

2.16
System Browser -> ClyFullBrowser openOnMethod: Object>>#printString - CTRL + P -> ouvre System Browser


Playground
"Pharo by example 5" - 2.11
Ne rappelle pas la commande précédente.
1. Commande
Playground -> ClyFullBrowser openOnMethod: Point>># -> sélectionne "Point" -> CTL + B -> ouvre System Browser classe point (kernel)
2. Commande
Playground -> Point browse -> CTRL + B -> similaire à dessus -> ouvre System Browser classe point (kernel)
3. Commande : rappel de la commande impossible.
Playground -> ClyFullBrowser openOnMethod: Point>>#
Playground -> Play pages : commandes ci-dessus non enregistrées.

Sinon CTRL + Z -> rappels les précédentes commandes.

Note : 
------
CTRL + P - CTRL + B
"Pharo by example 5" - 2.11
Playground -> Point browse -> CTRL + P -> System browser affiche la classe Point rattaché à kernel.
Playground -> Point browse -> CTRL + B -> System browser affiche 1 première fenêtre avec la classe ClyFullBrowser et une seconde avec Point.


Spotter
Schift + Entrée - ouvre spotter

Note : 
------
"Pharo by example 5" - 2.16 - 2.17
Affiche la liste des classes "Point" mais pas la classe "Object" rattachée à la méthode "printString".
ClyFullBrowser openOnMethod: Object>>#printString

Note : 
------
"Pharo by example 5" - 2.17 Using Spotter
#imple printString 	//imple pour "implementors -	Playground> #imple printString CTRL+M>
# 			//recherche générique
#class

N'affiche pas "AJInstruction>>printStringLimitedTo:"
Les lignes se terminant par ... impossible d'afficher le nom complet.

"Pharo by example 5" - 2.18 Using Spotter
Les autres catégories sont le menu, les packages
 
#implementor 		//la méthode - Pourquoi implementor plutôt que #methode ?
#example		//les exemples
#pragma			//le pragma
#sender			//les expéditeurs
#reference		//les références de classe
#playground		//terrain de jeu - affiche l'historique de certaines commandes.

Exemple :
---------  
Playground > #ref Point (CTRL+M) > (C)Point 			//Affichera la classe Point.
Playground > #ref Point (CTRL+N) > Senders of Point [93]	//Afficheront tous les codes Point rattachés aux classes.

Playground > #implementor and: (CTRL+M) > Implementors of and:[5] 	//Afficheront les packages et classes rattachés à la méthode and:.


15. Pharo_neg_pros.png
Itinéraire d'un enfant non gâté.
Itinéraire d'un enfant gâté.
Les Videos/W1 n'ont aucune correspondance avec la page d'accueil « MOOC ».
Répertoire limité.
Répertoire à créer.
Messages d'erreurs impossibles à résoudre.
Réponses à certaines de mes questions/interrogations.
Incohérences, cassures.
-------------------------------------------------------------------------------------------------------06/08/20 fin

-------------------------------------------------------------------------------------------------------07/08/20 debut
1 Semaine - Week 1

07/08/2020 - D08:47 - F12:25 - ProfStef - 2.13
ProStef - D08:53 - 17/29 - F12:25 23/29
solution : ProfStef next next.

Aller à la prochaine étape : avancer
ProfStef next.
Retourner à l'étape précédente : reculer
ProfStef previous.

ProfStef - Description
Message syntax: Cascade (17/29)
La première étape consiste à ouvrir une fenêtre "Transcript",
La seconde étape indique un code afin que le mot "hello" et "Pharo" s'affiche,
La troisième étape indique un code plus simple, mais similaire au second,
Donc, dans les trois cas j'appuie sur les touches CTRL + P comme précédemment pour valider les exercices.
À la première étape, je ferme la fenêtre afin de valider l'exercice.
Les suivants, apparaît "Transcript" à droite du point, mais je ne comprends pas ce qu'il se passe.
Le dernier exercice consiste à mettre deux fois "next".
Or je ne comprends pas pourquoi "ProfStef" est là.
J'ai relancé "ProfStef" afin de copier/coller le code permettant de passer à la prochaine étape.
Ensuite, j'ai compris la liaison entre le code et la fenêtre "Transcript".
Alors faut-il coller le code dans "Transcript" ? Cela ne me permet pas de passer à l'étape suivante.
On me montre un code (Transcript, show, '', ;, cr.) et s'oppose le mot "ProfStef" 
mais pour passer à l'étape suivante je dois mettre en cascade deux fois 'next' ?

Réponse : 1
Transcript
	   show: 'ProfStef';
	   show: 'next';
	   show: 'next' ;
	   cr.
Réponse : 2
Transcript 
	   show: 'next';
	   show: 'next' ;
	   cr.
Réponse : 3
Transcript 
	   show: 'next';
	   show: ' ';	
	   show: 'next' ;
	   cr.
Réponse : 4
ProfStef ProfStef.
Réponse : 5
{ ProfStef } first next.
				a ProfStef"Hey, you should not be here!! 
				Go back and use a cascade!"
				ProfStef previous.
Réponse : 6
ProfStef perform: #next.
Réponse : 7
ProfStef 'next' 'next'.
Réponse : 8
ProfStef next next.
-------------------------------------------------------------------------------------------

1 Semaine - Week 1

Playground (CTRL+O+W)> ProfStef go
Transcript (CTRL+O+T)> ProfStef go
ProfStef next. (CTRL+D) leçon suivante)
ProfStef previous. (CTRL+D) leçon précédente - antérieur)

ProfStef suite....
18/29
19/29
[ProfStef next] value.
21/29
1 < 2
  ifTrue: [100]
  ifFalse: [42]. 
Pourquoi mettre les chiffres 100 et 42 dans un bloc ? Alors qu'ils sont déclarés après deux points.
Est-ce que cela fonctionne lorsque j'enlève les crochets, l'ajout de guillemets, sans espaces ?
1 < 2
  ifTrue: 100
  ifFalse: 42. OUI
1 < 2
  ifTrue: '100'
  ifFalse: '42'. OUI 
1 < 2
  ifTrue:100
  ifFalse:42. OUI

ProfStef Conditionals 21/29
Lorsque la fenêtre "Transcript" est ouverte, il faut retourner sur "Playground" pour sélectionner le code. (Transcript open.)
Or, la fenêtre "Transcript" est :
 1. Derrière "Playground", (Idem exercice 17/21)
 2. La sélection du code et l'envoi du message CTRL + P n'affichent pas la fenêtre "Transcript",
 3. Lorsque la fenêtre "Transcript" est fermée, la réponse devrait ouvrir la fenêtre "Transcript",
 4. Obligé de rappeler la fenêtre cachée derrière "Playground",
 5. En tant que débutant non familiarisé, ce n'est pas pratique.
 6. En tant que débutant, pas encore d'automatisme à regarder les onglets ouverts en bas de Pharo,
 7. L'onglet en cours devrait clignoter ou apparaître. (Point n°3)

ProfStef 21/29
3 = 3 ifTrue: [ProfStef next].

ProfStef 22/29
1 to: 1 do: [:i | ProfStef next].

ProStef - 1 Semaine - Week 1
07/08/2020 D08:53 - F12:25 - 17/29-23/29
-------------------------------------------------------------------------------------------------------07/08/20 fin

-------------------------------------------------------------------------------------------------------08/08/20 debut
08/08/2020 - D08:51 - F13:02 - ProfStef - 23/29-24/29

Playground (CTRL+O+W)> ProfStef go
Transcript (CTRL+O+T)> ProfStef go
ProfStef next. (CTRL+D) leçon suivante)
ProfStef previous. (CTRL+D) leçon précédente - antérieur)

ProfStef 23/29
ProfStef allInstances do: [:aPharoTutorial | aPharoTutorial next].

Au dernier exercice d'"iterators" ce qui m'a "sauté aux yeux" c'est le doublement de "Transcript".
J'ai repensé à l'exercice "17/29" évitant la répétition de "Transcript".
Les résultats retournés sont équivalents dans "Playground - ProfStef", mais pas dans "Transcript" ?
Un point "." supplémentaire apparaît après le chiffre 10 ? 
C’est une boucle qui se finit par '.', l'autre aussi encadré par un bloc.

#(11 38 3 -2 10) do: [:each | Transcript show: each printString; show: '.'; cr].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; show: '.';].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; show: '.'].
#(11 38 3 -2 10) do: [show: each | Transcript show: printString; show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: printString; show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; show: each '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; show: '.';cr].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; show: '.';cr ].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; show: '.';cr] 
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; show: '.';cr ] 
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; show: '.';cr.]
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; show: '.'];cr.
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; show: '.']cr.
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString ; show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString ; show: '.' ].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; show: '.' ]. 
#(11 38 3 -2 10) do: [:each | Transcript show: each printString | show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString | show: each '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString | Transcript show: each '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString self add show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString self show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; self show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; separatedBy: show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; separatedBy:; show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; :; show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; : show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString separatedBy:; show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString separatedBy: show: '.']. 
#(11 38 3 -2 10) do: [:each | Transcript show: each printString separatedBy: ; show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; separatedBy:; show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; separatedBy: ; show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString ; separatedBy: ; show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString :; show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; separatorBlock show: '.'.]
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; show: '.';.] 
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; show: '.'; .] 
#(11 38 3 -2 10) do: [:each | 
	 Transcript show: each printString]
     separatedBy: [Transcript show: '.'] 
     separatedBy: [Transcript  show: '?'].
#(11 38 3 -2 10) do: [:each | 
	 Transcript show: each printString];
     separatedBy: [Transcript show: '.'] ; 
     separatedBy: [Transcript  show: '?'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString]; separatedBy: #show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString]; #show: '.'].
#(11 38 3 -2 10) do: [:each | Transcript show: each printString; #show: '.'].


ProfStef allInstances do: [:aPharoTutorial | aPharoTutorial next].

18. ProfStef Iterators 23/29 point neg/positif
Où se trouve "Workspace, Playground" comme annoncé ?
C'est ce que j'attendais lorsque j'ai visionné la vidéo "https://www.canal-u.tv/video/inria/redo_coding_a_counter.32705".
D'un côté le code et de l'autre le projet dynamique (résultat).
Car, je suis obligé de m'arranger de la fenêtre "Transcript" pour voir le résultat.

ProfStef 24/29 point neg/positif
19. ProfStef Iterators 24/29
Je ne comprends pas l'intérêt d'exécuter "Do it" ou "Print it" sur cette page 
alors que depuis le début j'utilise "CTRL+P" ? Bizarre !

08/08/2020 - D08:51 - F13:02 - 23/29-24/29
-------------------------------------------------------------------------------------------------------08/08/20 fin

-------------------------------------------------------------------------------------------------------09/08/20 debut
09/08/2020 - D10:35 - F13:56 - ProfStef - 24/29-29/29

Playground (CTRL+O+W)> ProfStef go
Transcript (CTRL+O+T)> ProfStef go
ProfStef next. (CTRL+D) leçon suivante)
ProfStef previous. (CTRL+D) leçon précédente - antérieur)

ProfStef 24/29 point neg/positif
20. ProfStef Iterators 24/29
20.1 Comment faire pour aller à un exercice précis sans passer toutes les étapes ? (par exemple exercice 24/29)
It's coool : -) ouf enfin.

20.2 L'exercice "A nice button" fait apparaître la couleur vert et blanc pourquoi celles-ci ?

20.3 Alors que la couleur "Cyan" est définie lors de l'exercice "ProfStef is cooxxl!", 
est-ce qu'une couleur est définie par défaut par Pharo ?

20.4 En fin de compte, la couleur "Cyan" m'empêche de lire le contenu du bouton.
Comment faire apparaître une liste de couleur ?
Il faut connaître les noms des couleurs par coeur et en anglais s.v.p., sinon tu es à la rue. :-(

20.5 Les deux boutons se chevauchent et m'empêche sa lecture : "ProfStef is cooooool!", 
lorsque je mets le curseur à droite du point et que j'appuie sur les touches clavier CTRL + P pourquoi ?
(curseur + CTRL+P fait chevaucher les boutons alors que Print it le remplace/l'efface ?)
(En général, c'est "Do it" qui fait chevaucher les boutons).
20.5.1 Le second bouton "ProfStef is cooooool!" remplace le premier "A nice button" grâce à "Print it", 
alors qu'avec "CTRL+P" c'est dû côte à côte ?
Un coup c'est bon, puis le suivant c'est autre chose. Cette histoire n'est pas très stable.

20.7 Est-ce qu'il y aurait une astuce pour réduire toutes les fenêtres et afficher "World" ? (3 clics+1+1)
Exemple : Alt+TAb

20.8 J'aimerai remettre l'exercice à "zéros" et que les boutons disparaissent de "Word", comment faire ?
Réponse : Exercice suivant : SimpleButtonMorph allInstances last delete.

(Prochain exercice )
ProfStef goToNextLesson 19
ProfStef goToNextLesson 24/29.
ProfStef goToNextLesson Iterators.
ProfStef next 24 @ 29.
ProfStef perform: #next.
[ProfStef next] value.
[ProfStef next] value:Iterators.
ProfStef next Iterators (24/29).
ProfStef next value:Iterators (24/29).
ProfStef next Basic types: Iterators.
ProfStef next Basic types: Iterators(24/29).
ProfStef next Basic types: Iterators (24/29).
ProfStef Iterators (24/29) go

Playground> SimpleButtonMorph new
	label: 'Go to next lesson';
	target: [ProfStef next. 
			   SimpleButtonMorph allInstances last delete];
	actionSelector: #value;
	openCenteredInWorld.

12:38 09/08/2020
ProfStef Reflection 25/29
ProfStef selectors. 
keys
#(
#player 
#previous 
#close 
#goOn: 
#helpBrowserWindow 
#go 
#tutorial:lesson: 
#showCurrentLesson 
#open 
#lessonView 
#next 
#player: 
#tutorialPositionString 
#last 
#tutorialSizeString 
#tutorial:lessonAt: 
#first 
#lessonView:)

ProfStef goToNextLesson.

12:44 09/08/2020
ProfStef Reflection 26/29
ProfStef default executeMethod: (ProfStef lookupSelector:#next).

12:45 09/08/2020
ProfStef Reflection 27/29

12:50 09/08/2020
09/08/2020 - D10:35 - F13:56 - 24/29-29/29
-------------------------------------------------------------------------------------------------------09/08/20 fin


-------------------------------------------------------------------------------------------------------11/08/20 debut
11/08/2020 - D09:55 - F12:28 - ProfStef - 29/29 - "Pharo by example 5" 2.13 - TestShout

ProfStef Debugger 28/29
Playground> PharoSyntaxTutorial new divideTwoByZero.

Playground (CTRL+O+W)> ProfStef go
Transcript (CTRL+O+T)> ProfStef go
ProfStef next. (CTRL+D) leçon suivante)
ProfStef previous. (CTRL+D) leçon précédente - antérieur)
ProfStef previous. 	//Revenir en arrière (exercice précédent)
(CTRL + Z) 		//Revenir en arrière (exercice précédent) ou rappeler les modifications de l'exercice en cours)


Pharobyexample 5 FR page 32/259, EN page 44/376.
La page d'accueil du MOOC est très bien réalisé et c'est par là que j'ai commencé.
Lire 376 pages s'est moins entrainant qu'un MOOC.
Mais, le hasard a fait qu'internet sois coupé alors je me suis rabbatu vers le livre pharo by example 5.
Du coup, heureusement que j'avais télécharger et lancé une traduction du livre avant la coupure ce qui
m'a permis d'avoir des réponses.
De plus, j'étais bloqué avec ProfStef niveau 17/29.
Je constate que ce soit le MOOC W1 et ProfStef tous converge vers "pharo by example".

ProfStef : Aller à une page précise ? (ci-dessous rien ne fonctionne)
ProfStef nextPage:29.
ProfStef nextPage:29/29.
ProfStef nextPage:(29/29).
ProfStef nextLink: 29.
ProfStef nextLink: 29/29.
ProfStef nextLink: (29/29).
ProfStef nextId 29/29.
ProfStef nextId (29/29).
ProfStef nextNumber 29.
ProfStef nextNumber 29/29.
ProfStef nextNumber (29/29).
ProfStef nextNumber: 29.
ProfStef nextNumber: 29/29.
ProfStef nextNumber: (29/29).
ProfStef nextNumber: 29 put: .
ProfStef next: 29 into: 29 startingAt: 29/29 .

10:27 11/08/2020 (reprise lecture pharo by example 5)
Pharobyexample 5 
FR page 32/259, 
EN page 44/376.
Je ne trouve pas la classe "StringTest".

"Pharo by example 5" - Utilisation de Spotter - Using Spotter -  2.18 -  p. 29 FR 39 EN
Les autres catégories sont le menu, les packages, 
#implementor 	la méthode		//Pourquoi 'implementor' plutôt que #methode ?
#example	les exemples		
#pragma		le pragma		 
#sender		les expéditeurs 	
#reference	les références de classe//Pourquoi 'reference' plutôt que #classe ?
#playground	terrain de jeu		//affiche l'historique de certaines commandes.

#ref Point  		<exemple  	//donnera toute la référence à la classe Point.
#imple printString	<exemple	//pharobyexample5 - spotter - page 40/376
	
KEYS
#player 
#previous 
#close 
#goOn: 
#helpBrowserWindow 
#go 
#tutorial:lesson: 
#showCurrentLesson 
#open 
#lessonView 
#next 
#player: 
#tutorialPositionString 
#last 
#tutorialSizeString 
#tutorial:lessonAt: 
#first 
#lessonView:

11/08/2020 - D09:55 - F12:28 -p. 29 FR - 39 EN - pharobyexample5 2.13 - TestShout
-------------------------------------------------------------------------------------------------------11/08/20 fin


12/08/2020 - D10:14 - F12:34 - pharobyexample5 2.13 - TestShout


-------------------------------------------------------------------------------------------------------14/08/20 debut
14/08/2020 - D12:16 - F12:43 - pharobyexample5 2.13 - Testrunner

23.1. "Pharo by example 5" - 2.13 Définition d'une nouvelle méthode
Compiler et enregistrer la méthode, une fenêtre apparaît "Author identification", 
ce n'est pas similaire à ce qui est indiqué dans le livre.
Tu aurais pu l'indiquer avant.
TestShout ????
Bon je vais relire 12:28 à table.
Solution : CTRL + S > Author id > mettre un prénom/nom> Testshout apparaît.

23.2. "Pharo by example 5" - 2.13 Exécution de votre méthode de test
Lorsqu'on exécute un clic droit dans l'espace "Package" ou "Protocol", 
une fenêtre permet de créer un "New package" ou un "New protocol".
C'est une source de confusion de modifier un "protocol" pour créer une méthode.
Créer une "New classe" ou une "New methode", serait plus simple et moins emmêlant.

23.3. "Pharo by example 5" - 2.13 Implémentation de la méthode testée
Le message " MessageNotUnderstood: ByteString >> shout" se situe sur le bandeau de la fenêtre.
Or, je cherchais cette erreur dans la fenêtre.

23.4. "Pharo by example 5" - 2.13 Implémentation de la méthode testée
"Test Runner" n'affiche pas "Collections-Test", pourquoi ? Et alors, "StringTest" est rattaché à quoi ? 
Est-ce que cela signifie que chaque "Collections-xxx" rattachée à "TestRunner" possède un "StringTest" ?
Comment être sûr que "StringTest" rattaché à "Collections-Tests" n'a pas d'erreur ?
(À ce stade, ce n'est pas sur puisque l'icône de la classe "StringTest" est jaune au lieu de vert).
J'ai déjà modifié en "^ self asUppercase,'!'" - C'est pas bon cette histoire.

14/08/2020 D12:16 - F12:43 pharobyexample5 2.13 - Testrunner
23.5. "Pharo by example 5" - 2.13 Implémentation de la méthode testée
???? le test passe !
shout
^ self asUppercase,'!'
mais le code est : 
testShout
self assert: 'No panic' shout = 'NO PANIC!'
Incompréhensible !
-------------------------------------------------------------------------------------------------------14/08/20 fin

-------------------------------------------------------------------------------------------------------18/08/20 debut
18/08/2020 - D11:18 - F13:56 - pharobyexample5 2.13 - Testrunner
18/08/2020 - D11:27 - F13:56 - pharobyexample5 - Chap. 3 - Une première application
3.1 Le jeu lights out p.36/259 FR 49 EN
Lights Out  est composé de deux types d'objets: le plateau de jeu lui-même et 100 objets cellulaires individuels. Le code
Pharo pour implémenter le jeu contiendra deux classes: une pour le jeu et une pour les cellules.
Ojets = classes ! 



Pharo envoie message > classe SimpleSwitchMorph > Création sous classe LOCell avec l'argument # > variable d'instance mouseAction
			superclass ????
Ajouts de méthodes à la classe "Locell" :

Protocol "no message" (n'existe pas) "Initialization" > Une méthode se créé automatiquement lorsque CTRL+S nommé "Initialize".


24. Listing 3-4 LOCell class definition
Le "listing 3-4" n'est pas à sa place, de plus c'est la figure 3-5 qui affiche le code.
Donc, lorsque je lis le livre, je me demande ce que vient faire ce code. 

25. 3.3 Définition de la classe LOCell - CTRL + S - figure 3.5
Message envoyé à "SimpleSwitchMorph" et compilation de la nouvelle classe.
Situation illustrée à la figure 3.5 = Je n'obtiens pas la situation illustrée.
La seconde fois, c'est la bonne.

26. 3.4 Ajouter des méthodes à une classe
Le protocole "no message" est introuvable.
?????

26.1. 3.4 Ajouter des méthodes à une classe - No message vs Initialize
Il faut le décoder votre livre ?
Je dois SELECTIONNER un protocole "no messages" qui n'existe pas.
Lorsque je continue la lecture du document et que je décrypte la figure 3.-7 c'est alors que je réalise
qu'il s'agit d'un protocole "initialization" et une méthode "initialize".
Dans la rubrique "protocol", il y a "initialization" et "initialize".
CTRL + S

27. Initialisez les méthodes - p. 54/376 EN.
Ce n'est pas clair du tout votre truc.
"Si une classe définit une méthode nommée "initialize" ? La classe ne définit rien du tout là.
						Classe > Protocol > Method
					classe SimpleSwitchMorph aucun initialize
					sous classe LOCell = Protocol > Initialization et initialize
					Protocol : Initialisation > CTRL+S
					Method : initialize
new ?

28. Appel de l'initialisation de la superclasse - p. 54/376 EN.
En tant que lecteur vous m'embrouillez avec votre vocabulaire, 
mais surtout lorsque vous renommez ou changez quelque chose.
Ce n'est pas clair, on s'y perd.
Exemple : 
Avant d'arriver à la lecture de "Appel de l'initialisation de la superclasse.",
SimpleSwitchMorph est une "Classe" puis devient une "superclasse" ?

Sous-classe SimpleSwitchMorph:
 classe existante  SimpleSwitchMorph 

18/08/2020 - D11:18 - F13:56 - pharobyexample5 2.13 - Testrunner
18/08/2020 - D11:27 F13:56 - pharobyexample5 - Chap. 3 - Une première application
-------------------------------------------------------------------------------------------------------18/08/20 fin

-------------------------------------------------------------------------------------------------------19/08/20 debut
19/08/2020 - D11:20 - F13:00 - pharobyexample5 - Chap. 3 - Une première application - 3.5 Inspection d'un objet

0@0 représente un objet Point (objet ou classe) dont les  coordonnées x et y sont toutes deux définies sur 0.
En fait, 0@0 envoie le message @ au numéro 0 avec l'argument 0. 

L'effet sera que le nombre 0 demandera à la classe Point (classe ou objet) 
de créer une nouvelle instance avec les coordonnées (0,0).

Maintenant, nous envoyons ce point nouvellement créé au coin du message : 
16@16, ce qui l'amène à créer un rectangle avec les coins 0@0 et 16@16.

Ce rectangle nouvellement créé sera affecté à la variable des limites, héritée de la superclasse (SimpleSwitchMorph).

29. Inspection d'un objet - À propos du reste -  p. 55/376 EN.	
Je suis plutôt en mesure d'attendre un "Workspace/Playground", d'un côté me montrant le code et de
l'autre le résultat qui peut être modifié à la volée.
Ce qui a été très justement publicité dans des vidéos Pharos.
Donc ?			
(Une (classe, objet) "Point" imaginaire c'est déjà bien suffisant)

p.40/259 FR - p.55/376 EN
30. Inspection d'un objet - À propos du reste -  p. 55/376 EN.
La flèche verte à côté de la méthode "initialize". 
Cela signifie :
la méthode existe dans la superclasse "SimpleSwitchMorph" et qu'elle est remplacée dans votre classe "LOCell".
									----------?
Pourquoi faire compliquer quand on peut faire simple ? Et pourquoi remplacer dans la classe ?
Dans Pharo, visuellement c'est simple.
------------------------------------------------------------------
   Package	| Classe	    | Protocol	     | Method	  |	
PBE-LightsOut	| LOCell	    | initialization | initialize |
------------------------------------------------------------------
		| SuperClasse	    |
		| SimpleSwitchMorph |
De mon point de vue, le package est rattaché à classe, superclasse au protocole et enfin la méthode. (remplacée ?)
LOCell est "Parents" alors que "SimpleSwitchMorph" est superclasse.
1 Superclasse		1 Admin	
	1.1 classe		1.1 utilisateur
Ce n'est pas cohérent cette histoire.
-------------------------------------------------------------------------------------------------------19/08/20 fin


-------------------------------------------------------------------------------------------------------20/08/20 debut
20/08/2020 - D11:39 - F13:11 - pharobyexample5 - Chap. 3 - Une première application - 3.5 Inspection d'un objet - figure 3.9

31. Inspection d'un objet - Figure 3.10 An LOCell -  p. 57/376 EN.
Super et ?
Pourquoi "openInWorld" n'a pas été mis dans le code "initialize" ?
Exemple :  
initialize
super initialize.
self label: ''.
self borderWidth: 2.
self openInWorld			//???
bounds := 0 @ 0 corner: 16 @ 16.
offColor := Color paleYellow.
onColor := Color paleBlue darker.
self useSquareCorners.
self turnOff

32. Inspection d'un objet - Figure 3.10 An LOCell -  p. 57/376 EN.
Le volet de gauche ou de droite ? Volet de gauche, le carré apparaît.
bounds: (200@200 corner: 250@250)
Je ne sais pas si c'est bon ! 
Volet gauche - test
bounds: (0@0 corner: 16@16)
bounds: (200@200 corner: 250@250)
Volet droit - test
"(0@0) corner: (16@16)"
"(200@200) corner: (250@250)"

12:32 20/08/2020
33. Inspection d'un objet - Figure 3.10 An LOCell -  p. 57/376 EN.
La cellule doit apparaître près du coin supérieur gauche de l'écran (comme illustré dans la figure 3-10) 
NON, aucune cellule n'apparaît dans la figure 3-10 !! 

34. Inspection d'un objet - Cellule - poignée brune - poignée jaune - p. 57/376 EN. 
Impossible de déplacer la cellule ou de la redimensionner avec les poignées.
3 cliques = 3 fenêtres :-(
minuscule
:-(( ?

35. Inspection d'un objet - Cellule - poignée rose - p. 57/376 EN.
Supprimez la cellule en cliquant sur le  x  dans la poignée rose.
La poignée rose ?
20/08/2020 -D11:39 - F13:11- pharobyexample5 - Chap. 3 - Une première application - 3.5 Inspection d'un objet - figure 3.9
-------------------------------------------------------------------------------------------------------20/08/20 fin


-------------------------------------------------------------------------------------------------------21/08/20 debut
21/08/2020 - D12:24 - F13:18 - 3.6 Définition de la classe LOGame - p. 57/376 EN.

36. 3.6 Définition de la classe LOGame - p. 57/376 EN.
* L'icône de la classe "LOCell" est un carré au lieu d'un rond bleu contenant la lettre "c".
Dans la fenêtre, il n'apparaît pas alors que sur l'onglet il est disponible ? (contradictoire)
* (ou cliquez avec le bouton droit sur le volet Classe et sélectionnez "Ajouter une classe" )
Ajouter une classe n'existe pas ! 
Une seconde ligne "PBE-LightsOut", se crée ?
Note : En mettant bout à bout les "points négatifs", cela devient vite agaçant.
Mdr, le déplacement.
La capture d'écran n'est pas adapté au résultat.
Impossible
-------------------------------------------------------------------------------------------------------21/08/20 fin


-------------------------------------------------------------------------------------------------------23/08/20 debut
23/08/2020 - D12:24 - F13:27 - Chap. 3 - Une première application - figure 3.12 Initialize game - Pharo by example - p. 63/376 EN

37. Chap. 3 - Une première application - figure 3.12 Initialize the game
Création d'une seconde ligne "PBE-LightsOut" et déplacement de "Logame" dans la première ligne "PBE-LightsOut".
Listing 3.12 - ajout du code, une fenêtre m'invite à choisir différentes possibilités, non renseignées dans le livre.
Livre -> une variable inconnue "Cells",
Pharo -> une variable inconnue "Matrix" ?
Figure 3.13 Declaring cells as a new instance variable -> aucune ligne similaire à "new instance variable".
Quelle galère !

12:55 23/08/2020
38. Chap. 3 - Une première application - figure 3.13 Declaring cells as a new instance variable
Ha ba voilà !
Il faut cliquer sur "Leave variable undeclared".
Franchement, au petit bonheur la chance.
Décrypter, tâtonner.
13:27 23/08/2020 J'arrête la lecture, car c'est compliqué et il se complique la vie, c'est tordu, et fatigant. 
Pharo by example - p. 63/376 EN
-------------------------------------------------------------------------------------------------------23/08/20 fin


-------------------------------------------------------------------------------------------------------24/08/20 debut
24/08/2020 - D11:08 - F13:10 - Pharo by example - p. 45/259 - p. 63/376 EN
Retour en arrière afin de bien comprendre les tenants et aboutissants de ces enchevêtrements tordus.
Ainsi que ces cadeaux-surprises qui s'ajoutent au fil de la lecture.
p. 45/259 FR 
", le volet protocole nous permet de catégoriser les méthodes afin que nous ne soyons pas submergés 
par une très longue liste de noms de méthodes dans le volet méthodes."

	* protocoles = méthodes et méthodes = méthodes

Cela revient à penser qu'il y a deux méthodes nommées "initialize",
l'une dans le volet protocole et l'autre dans méthode. (C'est complètement tordu cette histoire).

Franchement, c'est déjà difficile de s'approprier un langage de programmation, et ce qui est extraordinaire 
c'est qu'il rajoute des difficultés dans l'utilisation du programme. 

" une syntaxe si simple qu'il peut tenir sur une carte postale "

En fin de compte, la syntaxe est tellement simple qu'il balance un gros menhir, 
qui atterrit en pleine gueule de l'utilisateur afin de corser un peu le tout.

---------------------------------------------------------------------------------
   Package	| Classe	    	| Protocol	     	| Method	|	
PBE-LightsOut	| LOCell	    	| initialization 	|initialize	|
		|			| initialize		| 	|
		|		    	| as yet unclassified 	|		|
		|		    	| Catégorise 		|		|
		|		    	|	\/		|		|
		|		    	|  Method		| Method	|
		  LOGame					  cellsPerSide
---------------------------------------------------------------------------------
		| SuperClasse	    |
		| SimpleSwitchMorph |
		| Initialize-method |p45/259 FR

Classe 		Methode	p45/259 FR
LOGame 	>> 	cellsPerSide 


39. Chap. 3 - Une première application - 3.7 Organisation des méthodes en protocoles 
"déplacez la méthode initial-ize  vers un nouveau protocole appelé initialisation."
Les protocoles sont déjà créés, c'est quoi la finalité ?
"categorize all uncategorized" -> cette option ne fait rien.

40. Chap. 3 - Une première application - 3.7 Organisation des méthodes en protocoles - initialize  
" ... Pharo ne peut pas savoir exactement.... "
Pharo ne le sait pas, ce n'est pas étonnant avec toutes ces pirouettes.
" ... une initialize méthode dans la superclase, ..."

page 78/259 FR
41. À force je m'y perds, je dois faire une recherche pour un rappel de ce qu'est une "superclasse". 
"une  initialize  méthode dans la superclasse" -> page 45 -> 78/259 FR
"superclasse" -> page 78/259 FR
"Chaque classe de Pharo hérite de son comportement et de la description de sa structure d'une seule superclasse. 
Cela signifie que Smalltalk a un héritage unique."
Ce n'est pas clair.
	* une seule superclasse - NON -> SimpleSwitchMorph, Initialize
 	* Chaque classe hérite de son comportement, donc une méthode et un protocole aussi ? (initialize-methode)
	* classe <-> superclasse <-> méthode
	* classe <-> superclasse <-> protocole

42. Chap. 3 - Une première application - 3.8 Terminer le jeu
"Faites attention, le code suivant n'est pas entièrement correct. Par conséquent, 
il produira une erreur et c'est exprès."
À mon avis, il ne faut pas mettre la charrue avant les boeufs. 
Je m'étais déjà interrogé sur un précédent exercice.
Parce que même si soi-disant la syntaxe est facile, 
il y a tout le Mac-micmac logiciel à s'approprier et donc essayer de comprendre comment tous s'imbriquent dans Pharo.
Donc, on balance du code qui n'est pas évident à comprendre 
puis des catégories (volets) qui peuvent être créées, déplacées, etc.
Pour couronner tout ça, on agrémente le code d'erreurs alors qu'on ne sait même pas encore marcher.
Balancer plusieurs projets simples permettant de s'approprier le code et les volets (packages, classes, méthodes, protocoles).
Puis, tout en progressant, mettre en place par intermittence des projets contenant des "bogues".
24/08/2020 - D11:08 - F13:10 - Pharo by example - p. 45/259 - p. 63/376 EN
--------------------------------------------------------------------------------------------------------24/08/20 fin



--------------------------------------------------------------------------------------------------------25/08/20 debut
25/08/2020 - D10:06 - F11:33 - Pharo by example - p. 45/259 - p. 63/376 EN 
		     F11:33 - Pharo by example - p. 46/259 - p. 64/376 EN 
Quel bordel§ 
Rien, c'est chiant.
2 lignes supplémentaires : newCellAt:at: et toggleNeigxxxxx ????? C'est quoi ce truc ?
Bon je laisse tomber.

43. Chap. 3 - Une première application - 3.8 Terminer le jeu - nouveau LOCell
Je suis complètement perdu après la commande "CTRL+Shift+F -> cela formatera votre méthode." 

Mode gros bourrin :
Depuis l'onglet "initialization", j'ai copié le code ci-dessous : 

newCellAt: i at: j
"Create a cell for position (i,j) and add it to my on-screen
representation at the appropriate screen position. Answer the
new cell"
| c origin |
c := LOCell new.
origin := self innerBounds origin.
self addMorph: c.
c position: ((i - 1) * c width) @ ((j - 1) * c height) + origin.
c mouseAction: [ self toggleNeighboursOfCellAt: i at: j ].

En m'appuyant sur la capture "Figure 3.20", le nom correspond à "newCellAt:at:.
Or, le programme m'indique une erreur et il faut laisser les lettres "i" et "j". (newCellAt: i at: j)
Alors, la méthode sera enregistrée avec le nom "newCellAt:at:". 
Perturbant.
Sans doute bon. À suivre.

44. Chap. 3 - Une première application - 3.8 Terminer le jeu - Figure 3-20
En m'appuyant sur la capture "Figure 3.20", le nom correspond à "newCellAt:at:.
Or, le programme m'indique une erreur et il faut laisser les lettres "i" et "j". (newCellAt: i at: j)
Alors, la méthode sera enregistrée avec le nom "newCellAt:at:". 
Perturbant.
Idem pour "toggleNeighboursOfCellAt:at:".

45. Chap. 3 - Une première application - 3.8 Terminer le jeu - Figure 3-20
Les quatres lignes sont dans "initialization" au lieu de "all".
"all", n'a pas été trouvé. (3.7 Organisation des méthodes en protocoles - protocole virtuel --all--)
p.45/259 (all) FR - p.64/376 EN (figure 3-20)
Je ne sais pas.

Je pense que c'est bon puisque : LOGame>>cellsPerSide, LOGame>>initialize, LOGame>>newCellAt:at:, LOGame>>toggleNeighboursOfCellAt:at:
undeclared -> initialize ?
as yet unclassified -> cellsPerSide ?

46. Chap. 3 - Une première application - 3.8 Terminer le jeu - Figure 3-20
Il y a un problème entre :
"La méthode définie ci-dessus a créé un nouveau LOCell, initialisé à la position (i, j) 
dans la matrice des cellules. La dernière ligne définit l'action mouseAction de la nouvelle cellule à"
et 
"Listing 3-21 Une méthode de setter typique 
LOCell >> mouseAction: aBlock 
mouseAction: = aBlock"
Je ne sais pas de ce que je dois en faire de ce code "Listing 3-21" ?
Je vais arrêter là, j'en ai marre.
25/08/2020 - D10:06 - F11:33 - Pharo by example - p. 46/259 - p. 64/376 EN
--------------------------------------------------------------------------------------------------------25/08/20 fin


--------------------------------------------------------------------------------------------------------26/08/20 debut
26/08/2020 - D11:31 - F13:32 - Pharo by example - p. 46/259 - p. 64/376 EN
x2 Reprise du début - Une première application chapitre 3 p.35/259 FR  - 49/376 EN

Pharo > classe> variables d'instance> méthodes> "traditionnelle".
Pharo > variables d'instance à la volée> méthodes à la volée. "productif".
Pharo > débogueur						"productif".

Jeu > Package > 2 classes

System browser : 
Clic droit nouveau package >  PBE-LightsOut >  Onglet comment> Onglet New class

Listing 3-4 Définition de la classe LOCell //trop tôt dans le document.

System browser : 
Clic droit nouveau package >  
PBE-LightsOut>  Onglet Comment> Onglet New class
				< REMPLACER PAR >
	Object subclass: #NameOfSubclass	SimpleSwitchMorph subclass: #LOCell	//Classe simpleswitchmorph - sous-classe Locell
	instanceVariableNames: ''		instanceVariableNames: 'mouseAction'	//Variables d'instance
	classVariableNames: ''			classVariableNames: ''
	package: ' PBE-LightsOut'		package: 'PBE-LightsOut'

Notes : 
------
(En fait, puisque  LOCell  n'existe pas encore, nous avons passé le symbole #LOCell  comme argument, représentant le nom de la classe à créer.) 			
Donc, "Locell" ne sera plus ou sous-classe mais une classe.
En cliquant sur "PBE-LightsOut", un onglet "New class" est apparu.

PBE-LightsOut> Onglet Comment> Onglet (C) LOCell			> Onglet Inst. side method
		\/		\/					
		! = mettre	SimpleSwitchMorph subclass: #LOCell	Lights Out  est composé de deux types d'objets: le plateau de jeu lui-même et 100 objets cellulaires individuels.
		Un 		instanceVariableNames: 'mouseAction'	Le code Pharo pour implémenter le jeu contiendra deux classes: une pour le jeu et une pour les cellules.
		Commentaire	classVariableNames: ''
				package: 'PBE-LightsOut'

Note : 
------
P. 38/259 - Figure 3-5
Création automatique de l'onglet "Inst. side method" suite à l'enregistrement de la classe "Locell".

PBE-LightsOut> Onglet Comment				> Onglet (C) LOCell			> Onglet Inst. side method
		\/					\/					
	Lights Out est composé de deux types d'objets:	SimpleSwitchMorph subclass: #LOCell	
	le plateau de jeu lui-même et 100 objets	instanceVariableNames: 'mouseAction'	
	cellulaires individuels. Le code Pharo pour	classVariableNames: ''
	implémenter le jeu contiendra deux classes:	package: 'PBE-LightsOut'
	une pour le jeu et une pour les cellules.

Notes : 
------
* 1 problème : 3.4 Ajouter des méthodes à une classe : aucun protocole "no messages". p. 53/376 EN
* 2 problèmes : 3.4 Ajouter des méthodes à une classe : "remplacez-le par le texte suivant:" c'est une devinette ? Un coup le code est en haut puis en bas. p. 53/376 EN
* 3 problèmes : 3.4 Ajouter des méthodes à une classe : le lecteur se débrouille à décoder "no messages" par "initialization"> figure 3-7. p. 53/376 EN
* 4 problèmes : Dois-je passer par 1 "instance side> initialization> initialize > copie du code ? 
				Ou
				   2 Ongelt "Inst. side method" > copie du code ?
				Dans les deux cas, le résultat est le même.

Note : 
------
Lorsque le code "initialize" est enregistré alors une méthode "initialize" apparaît en face du protocole "initialization".

PBE-LightsOut> Onglet Comment				> Onglet (C) LOCell			> Onglet Inst. side method
		\/					\/					\/
	Lights Out est composé de deux types d'objets:	SimpleSwitchMorph subclass: #LOCell	initialize
	le plateau de jeu lui-même et 100 objets	instanceVariableNames: 'mouseAction'	super initialize
	cellulaires individuels. Le code Pharo pour	classVariableNames: ''			self label: ''.
	implémenter le jeu contiendra deux classes:	package: 'PBE-LightsOut'		self borderWidth: 2.
	une pour le jeu et une pour les cellules.						bounds := 0 @ 0 corner: 16 @ 16.
												offColor := Color paleYellow.
												onColor := Color paleBlue darker.
												self useSquareCorners.
												self turnOff

Package 				Class				Protocol		Method
PBE-LightsOut> 				LOCell				initialization		initialize

		Onglet Comment				> Onglet (C) LOCell			> Onglet initialize			> Onglet Inst. side method
		\/					\/					\/					
	Lights Out est composé de deux types d'objets:	SimpleSwitchMorph subclass: #LOCell	initialize
	le plateau de jeu lui-même et 100 objets	instanceVariableNames: 'mouseAction'	super initialize
	cellulaires individuels. Le code Pharo pour	classVariableNames: ''			self label: ''.
	implémenter le jeu contiendra deux classes:	package: 'PBE-LightsOut'		self borderWidth: 2.
	une pour le jeu et une pour les cellules.						bounds := 0 @ 0 corner: 16 @ 16.
												offColor := Color paleYellow.
												onColor := Color paleBlue darker.
												self useSquareCorners.
												self turnOff
Notes : 
------
* 1 problème :  PBE-LightsOut> "Objet" = classe remplacé par "SimpleSwitchMorph" = classe existante> 
		enregistrement de "#Locell" = classe.
Question : Après l'enregistrement de "Locell", il y a donc deux classes : "Locell" et "SimpleSwitchMorph" ?

Alors, cela devient plus tordu à la page 54/376 EN, puisque la classe n'est plus nommée classe, mais superclasse. 
Exécution de la méthode "initialize" de sa superclasse "SimpleSwitchMorph" ?
Donc, "Locell" c'est une classe tandis que "SimpleSwitchMorph" s’est transformé en superclasse ?
(Pourquoi faire simple quand on peut faire compliqué ?)

* 2 problèmes : " C'est toujours une bonne idée d'initialiser l'état hérité" : C'est quoi un état hérité ?

26/08/2020 - D11:31 - F13:32 - Pharo by example - p. 46/259 - p. 64/376 EN
Reprise du début - Une première application chapitre 3 p.36/259 FR - 50/376 EN

-------------------------------------------------------------------------------------------------------26/08/20 fin


-------------------------------------------------------------------------------------------------------27/08/20 debut
27/08/2020 - D12:35 - F13:52 - Une première application chapitre 3 p.36/259 FR - 50/376 EN
			F13:52 - p.43/259 FR - 59/376 EN
" Cela signifie que la méthode existe dans la superclasse et qu'elle est remplacée dans votre classe." p.55/376 EN
Encore une fois - (Pourquoi faire simple quand on peut faire compliqué ?)

Package 				Class				Protocol		Method
PBE-LightsOut> 				LOCell				initialization		initialize

		Onglet Comment				> Onglet (C) LOCell			> Onglet initialize			> Onglet Inst. side method
		\/					\/					\/					
	Lights Out est composé de deux types d'objets:	SimpleSwitchMorph subclass: #LOCell	initialize
	le plateau de jeu lui-même et 100 objets	instanceVariableNames: 'mouseAction'	super initialize
	cellulaires individuels. Le code Pharo pour	classVariableNames: ''			self label: ''.
	implémenter le jeu contiendra deux classes:	package: 'PBE-LightsOut'		self borderWidth: 2.
	une pour le jeu et une pour les cellules.						bounds := 0 @ 0 corner: 16 @ 16.
												offColor := Color paleYellow.
												onColor := Color paleBlue darker.
												self useSquareCorners.
												self turnOff

Playground> LOCell new> bounds> 
volet de gauche coller code : self bounds: (200@200 corner: 250@250)> Do it> "Update" icône deux flèches bleues en haut à droite.
volet de gauche coller code :  self openInWorld> Do it "un carré bleu doit apparaîte".

Note :
------
* 1 problème : "La cellule doit apparaître près du coin supérieur gauche de l'écran (comme illustré dans la figure  3-10)"
Rien n'apparaît dans la figure 3-10.  
* 2 problèmes : "Déplacez la cellule avec la poignée brune (en haut à droite)"
Impossible de déplacer la cellule.
* 3 problèmes : "redimensionnez-la avec la poignée jaune (en bas à droite)."
Impossible de redimensionner.
* 4 problèmes : "Vous devrez peut-être cliquer sur Actualiser pour voir la nouvelle valeur des limites."
Ce n'est pas "Actualiser" mais "Update", c'est à l'image du cours cette confusion, changement de mot.
* 5 problèmes : "Supprimez la cellule en cliquant sur le x dans la poignée rose."
Impossible de supprimer la cellule.

Notes : 
------
Ajout d'une nouvelle classe "LOGame", cliqué sur "PBE-LightsOut" afin de faire apparaître un onglet "New Class".

* 1 problème : "Figure 3-13 Déclaration de cellules comme nouvelle variable d'instance".
La figure 3-13 ne complète pas le fait qu'il faut cliquer sur "Leave variable undeclared", 
vous abandonnez le lecteur à son sort.
Ce qui implique qu'une première fenêtre s'affiche, puis une seconde permettant de cliquer sur "Declare new instance variable".
* 2 problèmes : "Tapez ce qui suit dans le navigateur comme méthode pour LOGame et essayez de l'accepter."
Étant donné que le code est disponible, le copier et coller est plus simple, plus rapide qu'un "Taper", 
source d'erreur et archaïque.
"ce qui suit", rien ne suit, c'est le problème du lecteur qui doit décrypter le contenu en plus du programme, 
code, interrelations des classes, protocole, sous-classe, superclasse, etc.
* 3 problèmes : "At this stage if you open a Playground, type LOGame new, and Do it, " et "Now let us do it: type LOGame new and Do it."
C'est une répétition !
* 4 problèmes : "Cliquez sur le bouton "Créer" du débogueur, lorsque vous êtes invité, sélectionnez "LOGame", 
la classe qui contiendra la méthode, cliquez sur "OK", puis lorsque vous êtes invité à un protocole de méthode 
entrez "accessing". Le débogueur créera la méthode "cellsPerSide" à la volée et l'appellera immédiatement."
Bouton "Créer" du débogueur c'est juste,
Apparaît la fenêtre "Define" et sélectionner "Logame" c'est juste, mais je n'ai pas cliqué sur "OK", 
ce qui m'a induit en erreur pour la suite.
Apparaît la fenêtre "New Protocol Name" contenant "as yet unclassified" que je remplace par "accessing" puis "OK".

Playground> BorderedMorph CTRL + I (inspect it)
	    SimpleSwitchMorph
	    LOGame

Package --------------------------------------------	Class		Protocol		Method
PBE-LightsOut> -------------------------------------	LOCell		initialization		initialize

		Onglet Comment				> Onglet (C) LOCell			> Onglet initialize			
		\/					\/					\/					
	Lights Out est composé de deux types d'objets:	SimpleSwitchMorph subclass: #LOCell	initialize
	le plateau de jeu lui-même et 100 objets	instanceVariableNames: 'mouseAction'	super initialize
	cellulaires individuels. Le code Pharo pour	classVariableNames: ''			self label: ''.
	implémenter le jeu contiendra deux classes:	package: 'PBE-LightsOut'		self borderWidth: 2.
	une pour le jeu et une pour les cellules.						bounds := 0 @ 0 corner: 16 @ 16.
												offColor := Color paleYellow.
												onColor := Color paleBlue darker.
												self useSquareCorners.
												self turnOff
							
							> Onglet (C) LOGame			> Onglet initialize				> Onglet Inst. side method
							\/					\/
							BorderedMorph subclass: #LOGame		initialize
							instanceVariableNames: ''		| sampleCell width height n |
							classVariableNames: ''			super initialize.
							package: 'PBE-LightsOut'		n := self cellsPerSide.		//Message Pharo, non implemented - cellsPerSide est une méthode qui n'est pas encore créée.
												sampleCell := LOCell new.
												width := sampleCell width.
												height := sampleCell height.
												self bounds: (5 @ 5 extent: (width * n) @ (height * n) + (2 * self borderWidth)).
												cells := Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]

27/08/2020 - D12:35 - F13:52 - Une première application chapitre 3 p.36/259 FR - 50/376 EN
		     F13:52 - Une première application chapitre 3 p.43/259 FR - 59/376 EN
------------------------------------------------------------------------------------------------------27/08/2020 fin


------------------------------------------------------------------------------------------------------28/08/2020 debut
28/08/2020 - D08:02 - F12:33 - Une première application chapitre 3 p.43/259 FR - 59/376 EN
		     F12:33 - Chapitre 3 - 3.8 Terminer le jeu p.46/259 FR - 65/376 EN

Note : 
------
Playground> LOGame new> Create> select Logame> New protocol name : accessing : ok> method : cellsPerSide> defaut code : cellsPerSide		> modif code : 	cellsPerSide
															self shouldBeImplemented.		"The number of cells along each side of the game"
																				^ 10

Package --------------------------------------------	Class		Protocol		Method
PBE-LightsOut> -------------------------------------	LOCell		initialization		initialize

		Onglet Comment				> Onglet (C) LOCell			> Onglet initialize			
		\/					\/					\/					
	Lights Out est composé de deux types d'objets:	SimpleSwitchMorph subclass: #LOCell	initialize
	le plateau de jeu lui-même et 100 objets	instanceVariableNames: 'mouseAction'	super initialize
	cellulaires individuels. Le code Pharo pour	classVariableNames: ''			self label: ''.
	implémenter le jeu contiendra deux classes:	package: 'PBE-LightsOut'		self borderWidth: 2.
	une pour le jeu et une pour les cellules.						bounds := 0 @ 0 corner: 16 @ 16.
												offColor := Color paleYellow.
												onColor := Color paleBlue darker.
												self useSquareCorners.
												self turnOff
							
							> Onglet (C) LOGame			> Onglet initialize				> Onglet cellsPerSide (playground Logame new)					> Onglet Inst. side method
							\/					\/						\/					
							BorderedMorph subclass: #LOGame		initialize					cellsPerSide	//Ajout variable d'instance classe logame : cells
						>cells	instanceVariableNames: 'cells'		| sampleCell width height n |			"The number of cells along each side of the game"
							classVariableNames: ''			super initialize.				^ 10
							package: 'PBE-LightsOut'		n := self cellsPerSide.
												sampleCell := LOCell new.
												width := sampleCell width.
												height := sampleCell height.
												self bounds: (5 @ 5 extent: (width * n) @ (height * n) + (2 * self borderWidth)).
												cells := Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]
Notes : 
-----
p. 44/259 FR - p.62/376 EN
"The next three lines create a new LOCell object, "
Pourquoi créer un nouvel objet "locell" alors qu'il est déjà créé ?

* 1 problème : p. 45/259 FR - p.62/376 EN
"Ces groupes de méthodes sont appelés «protocoles»."
Le lecteur est mené en bateau pour utiliser le volet "protocole " mais en cours de route ça évolue.
L'annonce a pour effet similaire à un coup de tonnerre, et un protocole c'est une méthode.
Ou bien un groupe de protocoles sont des méthodes.
Comment ne pas perdre le lecteur avec tous ces micmacs ? (Situation confuse, embrouillée. Quel micmac !)

Package --------------------------------------------	Class		Protocol		Method
									Method
* 2 problèmes : p. 45/259 FR - p.62/376 EN
"Le navigateur nous propose également le protocole virtuel --all--"
Aucun protocole virtuel --all--. 

* 3 problèmes : p. 45/259 FR - p.62/376 EN
"le volet de protocole peut contenir le protocole as yet unclassified".
À la première lecture du document, ce protocole était présent "situation confuse", mais à la seconde (lecture) non.

p. 45/259 FR - p.63/376 EN
Convention typographique.
Class >> method 	-> LOGame >> cellsPerSide
Class >> someClass	-> LOGame Class >> someClass SideMethod 

* 4 problèmes : p. 45/259 FR - p.63/376 EN
Le code "listing 3-18" est dans le chapitre "3.7 Organizing methods into protocols - Organisation des méthodes en protocoles", 
donc il est très loin du chapitre "3.8 Finishing the game - Terminer le jeu".
Comment ça se passe exactement, est-ce que je dois créer une variable dans mon petit cerveau reptilien pour stocker ce code ?
Puis décrypter que "Pharo ne peut pas savoir", compléter par une "convention" et le "code suivant n'est pas entièrement correct".
J'ai l'impression qu'on n'a pas la même conception du mot "suivant".
Dictionnaire : "Suivant" : Qui vient après, qui suit. La semaine suivante. Dans la pièce suivante.
Or, le code "listing 3-18" n'est pas après, mais bien avant même très en avant.
Précédemment, c'était contrariant, mais cette fois-ci c'est enquiquinant. 

* 5 problèmes : p. 45/259 FR - p.63/376 EN
Dans le "listing 3-18", il y a une "concaténation" de la convention typographique et du code.
Je m'explique : 
La classe est "LOGame" et la méthode est ? (question pour un champion)
Roulement de tambour, la réponse est : newCellAt:at:
C'est le nom de la méthode que Pharo a créé, je ne l'ai pas inventé.
Donc, c'est incohérent d'écrire "LOGame >> newCellAt: i at: j", 
alors que la convention typographique est "LOGame >> newCellAt:at:" sinon la nommer "newCellAt" serait plus cohérent. 

Chapitre "3.7 Organizing methods into protocols" - "Listing 3-18"
LOGame >> newCellAt: i at: j
Chapitre "Finishing the game"
LOGame >> newCellAt: at: 
(Situation confuse, embrouillée. Quel micmac !)

* 6 problèmes : p. 45/259 FR - p.63/376 EN
"vous pouvez cliquer droit sur la méthode zone d'édition et cliquez sur Format (ou utilisez CMD-Shift-f raccourci)."
Dans la zone d'édition aucun "Format", ni de touche de raccourcie correspondant à "CTRL-Shift-F". (cmd=Mac, ctrl=win)

* 7 problèmes : p. 46/259 FR - p.64/376 EN
Dans le "listing 3-19", c'est le même problème que celui du 5e problème.
"The method toggleNeighboursOfCellAt:at:"
LOGame >> toggleNeighboursOfCellAt: i at: j i> 1
LOGame >> toggleNeighboursOfCellAt:at:

Note : 
------
Dans le volet protocole, une liste est disponible, mais peut-être complétée par l'option "New protocol".


* 8 problèmes : p. 46/259 FR - p.64/376 EN
"Place this method in a new protocol called game logic. (Right-click in the protocol pane to add a new protocol.)"
Ça se complique, car il faut mettre la méthode "toggleNeighboursOfCellAt:at:" dans une autre méthode "logic game".
Au début, la présentation du programme Pharo était cohérente, mais plus j'avance dans le livre et plus cela devient confus.
Donc, c'est difficile de s'approprier le langage, mais en plus on rajoute une couche de complexité, complication, confusion, subtilité, intrication dans l'utilisation du programme Pharo.
(Ce n'est plus une couche c'est une dalle de béton :-)
(Situation confuse, embrouillée. Quel micmac !)
"Je me demande "est-ce que ceux qui ont créé le programme Pharo et le livre se rendent compte de tous ce micmac ?"
D'ailleurs, c'est en relisant le chapitre que je décrypte mieux la "Figure 3-20 Drag a method to a protocol".

-----------------------------------------------------
Protocol	  >	Method	    		     |
Method					    	     |
   \/			   \/	    		     |
-----------------------------------------------------
undeclared 	  >	initialize	    	     |
accessing	  >	cellsPerSide	    	     |
game logic	  >	toggleNeighboursOfCellAt:at: |
initialization	  >	initialize	    	     |
instance creation >	newCellAt:at:	    	     |
overrides	  >	initialize	    	     |
------------------------------------------------------

Instance side		cellsPerSide initialize newCellAt:at: toggleNeighboursOfCellAt:at:

Package --------------------------------------------	Class		Protocol		Method
PBE-LightsOut> -------------------------------------	LOCell		initialization		initialize

		Onglet Comment				> Onglet (C) LOCell			> Onglet initialize			
		\/					\/					\/ (protocol - methode initialization > initialize)					
	Lights Out est composé de deux types d'objets:	SimpleSwitchMorph subclass: #LOCell	initialize
	le plateau de jeu lui-même et 100 objets	instanceVariableNames: 'mouseAction'	super initialize
	cellulaires individuels. Le code Pharo pour	classVariableNames: ''			self label: ''.
	implémenter le jeu contiendra deux classes:	package: 'PBE-LightsOut'		self borderWidth: 2.
	une pour le jeu et une pour les cellules.						bounds := 0 @ 0 corner: 16 @ 16.
												offColor := Color paleYellow.
												onColor := Color paleBlue darker.
												self useSquareCorners.
												self turnOff
							
							> Onglet (C) LOGame			> Onglet initialize				> Onglet cellsPerSide (playground Logame new)				> newCellAt:at: (Pharo ne prend pas le nom "newCellAt:at:" mais transforme "newCellAt: i at: j" en nom de méthode "newCellAt:at:")		>Onglet Inst. side method
							\/					\/ (Playground > Logame new)			\/ (protocol - methode accessing > cellsPerside)			\/ (protocol - methode instance creation > newCellAt:at:)											\/					
							BorderedMorph subclass: #LOGame		initialize					cellsPerSide	//Ajout variable d'instance classe logame : cells	newCellAt: i at: j
			   Playground logame new >cells	instanceVariableNames: 'cells'		| sampleCell width height n |			"The number of cells along each side of the game"			"Create a cell for position (i,j) and add it to my on-screen
							classVariableNames: ''			super initialize.				^ 10									representation at the appropriate screen position. Answer the
							package: 'PBE-LightsOut'		n := self cellsPerSide.													new cell"
												sampleCell := LOCell new.												
												width := sampleCell width.												| c origin |
												height := sampleCell height.												c := LOCell new.
												self bounds: (5 @ 5 extent: (width * n) @ (height * n) + (2 * self borderWidth)).					origin := self innerBounds origin.
												cells := Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]							self addMorph: c.
																											c position: ((i - 1) * c width) @ ((j - 1) * c height) + origin.
																											c mouseAction: [ self toggleNeighboursOfCellAt: i at: j ].
												> New protocol game logic
												> Onglet toggleNeighboursOfCellAt:at:
												(Pharo ne prend pas le nom "toggleNeighboursOfCellAt:at:" mais transforme "toggleNeighboursOfCellAt: i at: j" en nom de méthode "toggleNeighboursOfCellAt:at:")
												(New protocol - methode game logic > toggleNeighboursOfCellAt:at:)
												\/
												toggleNeighboursOfCellAt: i at: j
												i > 1
												ifTrue: [ (cells at: i - 1 at: j) toggleState ].
												i < self cellsPerSide
												ifTrue: [ (cells at: i + 1 at: j) toggleState ].
												j > 1
												ifTrue: [ (cells at: i at: j - 1) toggleState ].
												j < self cellsPerSide
												ifTrue: [ (cells at: i at: j + 1) toggleState ]

28/08/2020 - D08:02 - F12:33 - Une première application chapitre 3 p.43/259 FR - 59/376 EN
		     F12:33 - Chapitre 3 - 3.8 Terminer le jeu p.46/259 FR - 65/376 EN
-------------------------------------------------------------------------------------------------------28/08/20 fin

-------------------------------------------------------------------------------------------------------29/08/20 debut 
29/08/2020 - D12:22 - F13:49 - Chapitre 3 - 3.8 Terminer le jeu p.46/259 FR - 65/376 EN
		   - F13:49 - Chapitre 3 - 3.8 Terminer le jeu p.48/259 FR - 66/376 EN
Note : 
------

* 1 problème : Le code "MouseAction" et "MouseUp" est identique aux problèmes ci-dessous.
(* 4 problèmes : p. 45/259 FR - p.63/376 EN, * 7 problèmes : p. 46/259 FR - p.64/376 EN)

* 2 problèmes : "Add the method LOCell >> mouseUp: and then Categorize automatically the methods."
Dès que j'ai aperçu les codes, j'ai fait des copiés et collés puis Pharo a complété automatiquement.
Donc, il y a un gros décalage entre le code et l'annonce de "Categorize automatically the methods."

p. 47/259 FR - 66/376 EN.
Le jeu LightsOut est composé de 2 classes et 7 méthodes = NON = 2 classes et 14 méthodes.

Package --------------------------------------------	Class		Protocol		Method
PBE-LightsOut> -------------------------------------	LOCell		initialization		initialize
																		Pharo mis automatiquement dans accessing
		Onglet Comment				> Onglet (C) LOCell			> Onglet initialize				> Onglet mouseAction:				> Onglet mouseUp:
		\/					\/					\/ (protocol-methode initialization>initialize)	\/ (protocol-methode accessing>mouseAction	\/	
	Lights Out est composé de deux types d'objets:	SimpleSwitchMorph subclass: #LOCell	initialize					mouseAction: aBlock				mouseUp: anEvent
	le plateau de jeu lui-même et 100 objets	instanceVariableNames: 'mouseAction'	super initialize				mouseAction := aBlock				mouseAction value
	cellulaires individuels. Le code Pharo pour	classVariableNames: ''			self label: ''.
	implémenter le jeu contiendra deux classes:	package: 'PBE-LightsOut'		self borderWidth: 2.
	une pour le jeu et une pour les cellules.						bounds := 0 @ 0 corner: 16 @ 16.
												offColor := Color paleYellow.
												onColor := Color paleBlue darker.
												self useSquareCorners.
												self turnOff
																		Déplacement vers accessing
							> Onglet (C) LOGame			> Onglet initialize				> Onglet cellsPerSide (playground Logame new)				> newCellAt:at: (Pharo ne prend pas le nom "newCellAt:at:" mais transforme "newCellAt: i at: j" en nom de méthode "newCellAt:at:")		>Onglet Inst. side method
							\/					\/ (Playground > Logame new)			\/ (protocol - methode accessing > cellsPerside)			\/ (protocol - methode instance creation > newCellAt:at:) devrait être dans "initialization" pourquoi est-il ailleurs ?											\/					
							BorderedMorph subclass: #LOGame		initialize					cellsPerSide	//Ajout variable d'instance classe logame : cells	newCellAt: i at: j
			   Playground logame new >cells	instanceVariableNames: 'cells'		| sampleCell width height n |			"The number of cells along each side of the game"			"Create a cell for position (i,j) and add it to my on-screen
							classVariableNames: ''			super initialize.				^ 10									representation at the appropriate screen position. Answer the
							package: 'PBE-LightsOut'		n := self cellsPerSide.													new cell"
												sampleCell := LOCell new.												
												width := sampleCell width.												| c origin |
												height := sampleCell height.												c := LOCell new.
												self bounds: (5 @ 5 extent: (width * n) @ (height * n) + (2 * self borderWidth)).					origin := self innerBounds origin.
												cells := Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]							self addMorph: c.
																											c position: ((i - 1) * c width) @ ((j - 1) * c height) + origin.
																											c mouseAction: [ self toggleNeighboursOfCellAt: i at: j ].
												> New protocol game logic
												> Onglet toggleNeighboursOfCellAt:at:
												(Pharo ne prend pas le nom "toggleNeighboursOfCellAt:at:" mais transforme "toggleNeighboursOfCellAt: i at: j" en nom de méthode "toggleNeighboursOfCellAt:at:")
												(New protocol - methode game logic > toggleNeighboursOfCellAt:at:)
												\/
												toggleNeighboursOfCellAt: i at: j
												i > 1
												ifTrue: [ (cells at: i - 1 at: j) toggleState ].
												i < self cellsPerSide
												ifTrue: [ (cells at: i + 1 at: j) toggleState ].
												j > 1
												ifTrue: [ (cells at: i at: j - 1) toggleState ].
												j < self cellsPerSide
												ifTrue: [ (cells at: i at: j + 1) toggleState ]

p. 47/259 FR - 66/376 EN
12:53 29/08/2020 - 3.9 Essayons notre code - Let's try our code
Le débogueur affiche une erreur "LOGame>>initialize", n'a rien à voir avec "LOGame >> toggleNeighboursOfCellAt: at:".

#Matrix is missing, and does not understand #new:tabulate:
LOGame>>initialize
cells := Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]

Le code est similaire à la capture d'écran.

Relecture du chapitre : 
p. 44/259 FR - 61/376 EN

Solution éventuelle : p. /259 FR - 59/376 EN
Je vais reproduire ce qui est indiqué dans le chapitre "Taking advantage of the debugger - Tirer parti du débogueur ".
"Cliquez sur le bouton "Créer" du débogueur, lorsque vous êtes invité, sélectionnez "LOGame", 
la classe qui contiendra la méthode, cliquez sur "OK", 
puis lorsque vous êtes invité à un protocole de méthode entrez "accessing". 
Bon et bien "Proceed".
J'ai supprimer "initialize", le gros bourrin.
En tous cas le carré s'affiche.
Du coup, il n'y a plus de bogue. :-) MDR ! 
SUppression ?
Aucun : Fixing the bug. ????
A suivre : mdr !
Prise en compte des bogues qu'il faudra réparer, certains faits et certaines commandes à réaliser :
 1 Pro-ceed , 
 2 CMD- Alt-Shift  et cliquez), et créez-en un nouveau. 
 3 Exécutez à  nouveau LOGame new openInWorld)

29/08/2020 - D12:22 - F13:49 - Chapitre 3 - 3.8 Terminer le jeu p.46/259 FR - 65/376 EN
		   - F13:49 - Chapitre 3 - 3.8 Terminer le jeu p.48/259 FR - 66/376 EN
-------------------------------------------------------------------------------------------------------29/08/20 fin


-------------------------------------------------------------------------------------------------------30/08/20 debut
30/08/2020 - D10:04 - F14:00 - Chapitre 3 - 3.8 Terminer le jeu p.48/259 FR - 66/376 EN

50. 3.9 Essayons notre code - Let's try our code
Le jeu est composé de 2 classes et 7 méthodes = NON (p. 47/259 FR - 66/376 EN.) 
Le jeu est composé de 2 classes et 14 méthodes.

Rappel : 
-------

p. 45/259 FR - 62/376 EN
"le volet protocole nous permet de catégoriser les méthodes afin que nous ne soyons pas submergés 
par une très longue liste de noms de méthodes dans le volet méthodes. 
Ces groupes de méthodes sont appelés «protocoles».

	* protocoles = méthodes et méthodes = méthodes

Package ------ Class ---- Protocols ------------ Methods
		 	  (Methods)		    
		\/	     \/			    \/
PBE-LightsOut  
	|----- 1 LOCell - 1 accessing ---------- 2 mouseAction:
	|	  |------ 3 event handing ------ 4 mouseUp:
	|	  |------ 5 initialization ----- 6 initialize
	|
	------ 2 LOGame - 7 accessing ---------- 8 cellsPerSide
		  |------ 9 game logic --------- 10 toggleNeighboursOfCellAt:at: (toggleNeighboursOfCellAt: i at: j)
		  |------ 11 initialization ---- 12 initialize (erreur = suppression)
		  |------ 13 instance creation - 14 newCellAt:at: (newCellAt: i at: j)


Package --------------------------------------------	Class	-----	Protocols     -------	Methods
PBE-LightsOut --------------------------------------	LOCell		accessing    		mouseAction:
									event handing		mouseUp:
  									initialization		initialize
  
  							LOGame		accessing		cellsPerSide
									game logic		toggleNeighboursOfCellAt:at: (toggleNeighboursOfCellAt: i at: j)
									initialization		initialize (erreur = suppression)
									instance creation	newCellAt:at: (newCellAt: i at: j)

Package --------------------------------------------	Class	----------------------------	Protocols     -------	Methods
PBE-LightsOut-----------------------------------------------------------------------------------------------------------
\/							|					|			|
Objet subclass: #NameOfSubclass				|					|			|
instanceVariableNames: ''				|					|			|
classVariableNames: ''					|					|			|
package: ''						\/					\/			\/
												Il manque des Protocoles						Pharo création auto protocol accessing		Pharo création auto protocol event handing
		Onglet Comment				> Onglet (C) LOCell			>Initialization		> Onglet initialize				> Onglet mouseAction:				> Onglet mouseUp:
		\/					\/					>accessing		\/ (protocol-methode initialization>initialize)	\/ (protocol-methode accessing>mouseAction:)	\/ (protocol-method event handing>mouseUp:)	
	Lights Out est composé de deux types d'objets:	SimpleSwitchMorph subclass: #LOCell				initialize					mouseAction: aBlock				mouseUp: anEvent
	le plateau de jeu lui-même et 100 objets	instanceVariableNames: 'mouseAction'				super initialize				mouseAction := aBlock				mouseAction value
	cellulaires individuels. Le code Pharo pour	classVariableNames: ''						self label: ''.
	implémenter le jeu contiendra deux classes:	package: 'PBE-LightsOut'					self borderWidth: 2.
	une pour le jeu et une pour les cellules.									bounds := 0 @ 0 corner: 16 @ 16.
															offColor := Color paleYellow.
															onColor := Color paleBlue darker.
															self useSquareCorners.
															self turnOff
																					Déplacement vers accessing
		Onglet Comment				> Onglet (C) LOGame			>"playground"		> Onglet initialize				> Onglet cellsPerSide (playground Logame new)				> newCellAt:at: (Pharo ne prend pas le nom "newCellAt:at:" mais transforme "newCellAt: i at: j" en nom de méthode "newCellAt:at:")		>Onglet Inst. side method
		\/					\/					>accessing		\/ (Playground > Logame new)			\/ (protocol - methode accessing > cellsPerside)			\/ (protocol - methode instance creation > newCellAt:at:) devrait être dans "initialization" pourquoi est-il ailleurs ?											\/					
	Suite du jeu Lights Out				BorderedMorph subclass: #LOGame		>instance creation	initialize					cellsPerSide	//Ajout variable d'instance classe logame : cells	newCellAt: i at: j
			   Playground logame new >cells	instanceVariableNames: 'cells'					| sampleCell width height n |			"The number of cells along each side of the game"			"Create a cell for position (i,j) and add it to my on-screen
							classVariableNames: ''						super initialize.				^ 10									representation at the appropriate screen position. Answer the
							package: 'PBE-LightsOut'					n := self cellsPerSide.													new cell"
															sampleCell := LOCell new.												
															width := sampleCell width.												| c origin |
															height := sampleCell height.												c := LOCell new.
															self bounds: (5 @ 5 extent: (width * n) @ (height * n) + (2 * self borderWidth)).					origin := self innerBounds origin.
															cells := Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]							self addMorph: c.
																														c position: ((i - 1) * c width) @ ((j - 1) * c height) + origin.
																														c mouseAction: [ self toggleNeighboursOfCellAt: i at: j ].
												>game logic		> Onglet toggleNeighboursOfCellAt:at:
															(Pharo ne prend pas le nom "toggleNeighboursOfCellAt:at:" mais transforme "toggleNeighboursOfCellAt: i at: j" en nom de méthode "toggleNeighboursOfCellAt:at:")
															(New protocol - methode game logic > toggleNeighboursOfCellAt:at:)
															\/
															toggleNeighboursOfCellAt: i at: j
															i > 1
															ifTrue: [ (cells at: i - 1 at: j) toggleState ].
															i < self cellsPerSide
															ifTrue: [ (cells at: i + 1 at: j) toggleState ].
															j > 1
															ifTrue: [ (cells at: i at: j - 1) toggleState ].
															j < self cellsPerSide
															ifTrue: [ (cells at: i at: j + 1) toggleState ]

Suite du 29/08/20
Prise en compte des bogues qu'il faudra réparer, certains faits et certaines commandes à réaliser :
 1 Pro-ceed , 
 2 CMD- Alt-Shift  et cliquez), et créez-en un nouveau. 
 3 Exécutez à  nouveau LOGame new openInWorld)

10:21 30/08/2020
ReLecture 3.9 Essayons notre code p. 47/259 FR - 66/376 EN.
Ajout de la méthode : Locell>>mouseUp:, ne fait rien de plus : LOGame new openInWorld
Test : 
PBE-LightsOut new openInWorld -> ouvre une fenêtre "variable inconnue".
LOCell new openInWorld -> ouvre un carré jaune taille 5/5.
LOGame new openInWorld -> ouvre un carré bleu taille 10/10.

Interrogation ? 
--------------

Pourquoi dans Playground taper "LOGame new openInWorld" au lieu de "PBE-LightsOut new openInWorld" contenant les deux classes "LOCell" et "LOGame" ?

51. 3.9 Essayons notre code - Let's try our code
"le message "toggleState" a été envoyé à une instance de "LOGame", alors qu'il aurait clairement dû être 
une instance de "LOCell". Le problème est très probablement lié à l'initialisation de la matrice de cellules. 
Parcourez le code de "LOGame >> initialize les spectacles."
 * Je parcours le code et la suite ?
 * Pharo affichait une erreur de "LOGame>>initialize" qui a été supprimée.
 * Précédemment, j'ai supprimé "LOGame>>initialize", et je ne peux plus le recréer en tant que "new instance variable".
 * Revenue comme au début.
 * Donc, je vais devoir encore recommencer. (x4)
 * Ou bien terminer le débogage "Listing 3-24 et Listing 3-25".

52. 3.9 Essayons notre code - Let's try our code 
"Listing 3-25 Remplacer les actions de déplacement de la souris
LOCell >> mouseMove: anEvent"

"We can fix this simply by overriding mouseMove: to do nothing:"
"Nous pouvons résoudre ce problème simplement en remplaçant mouseMove: pour ne rien faire :"

L'auteur n'indique à aucun moment la création de cette méthode, mais le remplacement des actions de déplacement 
de la souris.
Donc, est-ce que je dois remplacer "mouseAction:" par "mouseMove :" ?
(:-? - Situation confuse, embrouillée. Quel micmac !)
Au final, il manque une ou des captures d'écran parce que la manière d'expliquer est tarabiscotée.

53. 3.9 Essayons notre code - Let's try our code - execution context  
"L'avantage de ceci est que vous voyez la méthode que vous écrivez car elle sera exécutée, 
avec des paramètres réels dans le contexte d'exécution réel." (p. 47/259 FR)
"The advantage of this is that you see the method that you are writing as it will be executed, 
with real parameters in the actual execution context." (p. 66/376 EN) 

C'est ce que j'attends depuis le début du Week 1 et qui a été montré dans les vidéos, au lieu d'être bombardé 
par du vocabulaire au milieu d'une phrase qui ne me dit rien et ne m'avance à rien.
Je me fonde sur l’action, les résultats concrets et l’efficacité. (pragmatique) 

Exemples : simple
"La méthode "toggleNeighboursOfCellAt:at:" fait basculer l'état des quatre cellules vers le nord, le sud, l'ouest 
et l'est de la cellule (i, j)." (p. 46/259 FR - p. 64/376 EN)
"paramètres réels dans le contexte d'exécution réel" -> Non

"Par exemple, il est assez clair que les lignes de la matrice: 5 colonnes: 2  ont 5 lignes et 2 colonnes, 
et non 2 lignes et 5 colonnes." (p. 44/259 FR - p. 62/376 EN)
C'est sans doute clair, mais cela a été souligné.
"exécution réel."  -> Non

47/259 - 66/376 LOGame>>initialize
48/259 - 67/376 lu
30/08/2020 - D10:04 - F14:00 - Chapitre 3 - 3.8 Terminer le jeu p.48/259 FR - 66/376 EN
-------------------------------------------------------------------------------------------------------30/08/20 fin

-------------------------------------------------------------------------------------------------------31/08/20 debut
31/08/2020 - D16:56 - F17:45 - Chapitre 3 - 3.8 Terminer le jeu p.48/259 FR - 66/376 EN

Note :
------
54. 3.9 Essayons notre code - Let's try our code - debogage
"initialize" est toujours "undeclared" dans "LOGame".
J'ai créé une classe "Matrix" et en parallèle lancé "LOGame new", "Restart", "Proced", "CTRL + Shift + F".
Tout un tas de commandes pour qu'il accepte "Matrix".
J'ai ajouté la méthode "mousemouve:" dans "LOCell".
J'ai lancé "LOGame new openInWorld" et un gros carré bleu est apparu.
Ce n'est pas du tout ce à quoi je m'attendais.
"un jeu simple appelé Lights Out", c'est autant la merde, je n'ose même pas imaginer le reste.
Super le jeu ! 

31/08/2020 - D16:56 - F17:45 - Chapitre 3 - 3.8 Terminer le jeu p.48/259 FR - 66/376 EN
-------------------------------------------------------------------------------------------------------31/08/20 fin


-------------------------------------------------------------------------------------------------------01/09/20 debut
01/09/2020 - D09:53 - F00:00 - Chapitre 3 - 3.8 Terminer le jeu p.48/259 FR - 66/376 EN
01/09/2020 - D09:53 - F14:01 - Chapitre 3 - 3.8 Terminer le jeu p.39/259 FR - 53/376 EN	

Création d'un fichier carte afin de créer une image mentale de tous ces processus complexes.
Nom carte : "Ph_jeux_LightsOut.png"

Sauvegarde du jeu "CTRL + Shift + S", et redémarrage de Pharo.
Toujours les carrés bleu et même carré que précédemment.

Suppression de "PBE-LightsOut", enregistrement, redémarrage de Pharo.
Les carrés sont toujours présent.

55. 3.9 Essayons notre code - Let's try our code -  
Suppression du package "PBE-LightsOut", enregistrement et redémarrage de Pharo.
Les carrés sont toujours présents.
Comment est-ce que je fais pour supprimer tous ces carrés ? 
La solution serait de re-installer Pharo. Pfff !!!!

10:33 01/09/2020
Solution : 
Copier, remplacer les fichiers depuis le zip "pharo_images.zip". 

10:40 01/09/2020
x3 Reprise du début - Une première application chapitre 3 p.35/259 FR - 49/376 EN
(26/08/2020 -D11:31 -F13:32  - Pharo by example - p. 46/259 - p. 64/376 EN
x2 Reprise du début - Une première application chapitre 3 p.35/259 FR - 49/376 EN)

Mspaint création d'un organigramme du jeu "-LightsOut" code.

56. Chapitre 3 Créer une nouvelle application - 3.2 Créer un nouveau package
Il n'est pas possible de faire "New package" alors qu'il y a un mot dans la case "filtre".

01/09/2020 - D09:53 - F14:01 - Chapitre 3 - 3.8 Terminer le jeu p.39/259 FR - 53/376 EN			
-------------------------------------------------------------------------------------------------------01/09/20 fin


-------------------------------------------------------------------------------------------------------02/09/20 debut
02/09/2020 - D11:13 - F13:00 - Chapitre 3 - 3.4 Ajouter des méthodes à une classe p.38/259 FR - 52/376 EN	

57. Chapitre 3 Créer une nouvelle application - 3.4 Ajouter des méthodes à une classe - bug
Dans volet "Protocol" quand une liste s'affiche, il n'y a pas de visibilité sur la case "Filter...".
Idem dans le voltet "Method".
Les lettres "st" affichent la ligne "geometry testing". Ouah !
J'ai compris : 
Il y avait deux fenêtres "LOCell" et c'est sur la seconde qu'il n'a pas affiché correctement les mots.
Parce que sur la première fenêtre ça fonctionne. < NON ne fonctionne pas
Mais bon, ce n'est quand même pas normal que ça arrive lors de la création d'un petit jeu.
Ça y est, j'ai trouvé le "bug".

Il suffit de cliquer sur les différents protocoles, ainsi les lignes cliquées sont chargées en mémoire 
et provoque une saturation.
Ensuite, la recherche "Filter..." par mot est "kapout".

Tiens, j'ai trouvé un projet "bug" sur Pharo.
Tu utilises Pharo ou alors une version "Pharo" pour débutant et espérer que le code ne soit pas compliqué 
pour chercher et corriger ce bug.
Idem pour les cases "Filter...", à ajouter.
Il faudrait également l'appliquer à Pharo ce concept :
"L'avantage de ceci est que vous voyez la méthode que vous écrivez car elle sera exécutée, 
avec des paramètres réels dans le contexte d'exécution réel."

Protocol> "Instance side" = "côté instance"

Figure 3-5 The newly-created class LOCell
no message
p.52/376

p53/376 39/259
02/09/2020 - D11:13 - F13:00 - Chapitre 3 - 3.4 Ajouter des méthodes à une classe p.38/259 FR - 52/376 EN
-------------------------------------------------------------------------------------------------------02/09/20 fin


-------------------------------------------------------------------------------------------------------23/09/20 debut
23/09/2020 - D11:10 - F12:46 - Chapitre 3 - 3.4 Ajouter des méthodes à une classe p.38/259 FR - 52/376 EN

Ajout du commentaire class locell.
Actualisation fichier "Ph_jeux_LightsOut.png".
Dans packages, il a créé deux lignes : PBE-LightOut" ???? l'une contenant "LOCell" et l'autre "LOGame".

23/09/2020 - D11:10 - F12:46 - Chapitre 3 - 3.4 Ajouter des méthodes à une classe p.42/259 FR - 58/376 EN
-------------------------------------------------------------------------------------------------------23/09/20 fin


-------------------------------------------------------------------------------------------------------24/09/2020 début
24/09/2020 - D08:36 - F11:54 - Chapitre 3 - 3.4 Ajouter des méthodes à une classe p.42/259 FR - 58/376 EN
15 mns pause.

p.55/376 EN - 3.5 Inspecting an object : 
Sending self label:'',
p.39/259 FR - 3.5 Inspection d'un objet : 
Envoi de l'auto-étiquette:'',

58. Lorsque la souris est mise sur une option et que celle-ci est liée à un raccourci clavier alors, 
la surbrillance (bleu) efface le raccourci clavier tandis que l'option s'affiche clairement.

24/09/2020 - D08:36 - F11:54 - Chapitre 3 - 3.4 Ajouter des méthodes à une classe p.42/259 FR - 58/376 EN
-------------------------------------------------------------------------------------------------------24/09/2020 fin


-------------------------------------------------------------------------------------------------------28/09/2020 début
28/09/2020 - D10:39 - F13:53 - Chapitre 3 - 3.4 Ajouter des méthodes à une classe p.42/259 FR - 58/376 EN

Le 24/09/20 sortit du programme en passant par la croix.
"Pharo Virtual Machine" - Quit Pharo Virtual Machine without saving? [Oui - Non]
D'ailleurs, c'est marrant, car le message est en anglais, mais les boutons (oui-non) sont en français.

Retour sur les pages 52/259 et 59/376, "cellsPerSide".
La classe "Matrix" n'existe pas !

p.63/376, ce n'est pas cohérent.
"Définissons  LOGame >> newCellAt: at:  dans le   protocole d' initialisation ."
PBE-LightsOut>LOGame>initialization>"newCellAt:at:"
Or, "newCellAt:at:" n'est pas dans "initialization" qui est inconnue dans le bandeau de pharo.
LOGame >> newCellAt: at:
Le plus simple, clic droit dans la rubrique "method" et "New method".

28/09/2020 - D10:39 - F13:53 - Chapitre 3 - 3.4 Ajouter des méthodes à une classe p.42/259 FR - 58/376 EN
-------------------------------------------------------------------------------------------------------28/09/2020 fin


-------------------------------------------------------------------------------------------------------03/10/2020 début
03/10/2020 - D11:55 - F13:41 - Chapitre 3 - 3.4 Ajouter des méthodes à une classe p.42/259 FR - 58/376 EN
03/10/2020 - D11:55 - F13:41 - Chapitre 4 - 4.1 Elements syntaxique p.54/259 FR - 77/376 EN
Avec des interruptions.
Chapitre 4 - 13:00
Chapitre 4 - 4.1 Elements syntaxique p.54/259 FR - 77/376 EN


03/10/2020 - D11:55 - F13:41 - Chapitre 3 - 3.4 Ajouter des méthodes à une classe p.42/259 FR - 58/376 EN
-------------------------------------------------------------------------------------------------------03/10/2020 fin

-------------------------------------------------------------------------------------------------------05/10/2020 début
05/10/2020 - D09:00 - F13:00 - Chapitre 4 - 4.1 Elements syntaxique p.54/259 FR - 77/376 EN
05/10/2020 - D09:00 - F13:00 - Chapitre 5 - Unaire> Binaire> Mots-clés p.65/259 93/376 EN

Blablablabla - beaucoup de commandes mais concrètement ça donne quoi ?
Ca part dans tous les sens, l'argument va aller vers machin truc much ...........
10:17 05/10/2020 - Chap. 5 - syntaxe des messages - p.61/259 FR - 87/376 EN
p.88 - Figure 5-1 EN Deux messages envoyés (pour bien comprendre l'image lire le texte en anglais....
p.88 - Figure 5-2 EN couleur aMorph et yellow (pour bien comprendre l'image lire le texte en anglais car en francais la
traduction a décalé les :.)
p.62 FR 89 EN - Tableau présente plusieurs caractéristiques des envois de messages.

Or, il s'avère que l'on peut combiner par exemple unaire et message cle ou message clé et binaire alors il n'est plus
question de priorité unaire, binaire, messageclé.
Pen new go: 100 et aPen go: 100 + 20.
p.64 FR - 92 EN
"Les messages unaires sont toujours envoyés en premier, puis les messages binaires et enfin les messages de mots-clés."

P. 62 FR 89 EN - Il rabache encore unaire, binaire, message.

Unaire :
--------
Ce sont des messages qui ne nécessitent aucun argument. Ils suivent le modèle syntaxique : 
receiver selector (réception de la sélection)

Binaire :
--------- 
10 + 20 = + est un message binaire envoyé au récepteur 10 avec l'argument 20. (p.88/376 EN - Figure 5-2)

En me référent à la Figure 5-1, il y a un problème.
On considère : 10 + 20
(p.88/376 EN - Figure 5-2)
			message					message
		----------------				-------
		|		|				|     |
	total		<= max				total	 + 20 (10 ne peut pas être le total, il manque quelque chose)
    /		   |	         \	    		/	 |   \
receiver     message selector message arguments      receiver	m.s.   m.a.
  		|   / |   /  \  /		                 |     |
    \		ms ma ms ma ms ma			\       ms     ma
	        |  |  |  |  |  |				 |     |
	Color 	r: 1  g: 0  b: 0 		   10 # Somme    +  1: 10 2: 20 (ajouts 1: et 2:)
	       |		| 		  Pourtant : .. un message binaire envoyé au récepteur 10 ?
		----------------
Notes : 
------
Color -> r:, g:, b: sont des sélecteurs et 1, 0, 0 des arguments
Il y a quelque chose qui ne va pas avec ce schéma et le fait que 10 soit récepteur (Figure 5.1 Two message sends ..)


Message clé :
-------------
Nécessites un ou plusieurs arguments et plusieurs mots pour le sélecteur.
receiver selectorWordOne: argumentOne WordTwo: argumentTwo
 
p.64 FR - 92 EN
"Les messages unaires sont toujours envoyés en premier, puis les messages binaires et enfin les messages de mots-clés."

60. Chapitre 4 - Unaire> Binaire> Mots-clés - p.65/259 93/376 EN
Les listings 5-4 et 5-5 font ressortir exactement ce que je pensais précédemment.
 * Quel est l'intérêt d'avoir "color:" et "Color yellow" ?
 * Les résultats ne sont pas similaires.

Listing 5-4 : 

[1) aPen color: Color yellow (< Pourquoi "color:" et "Color" ?)
		    \/
(2) aPen color: Color yellow (aColor = erreur tandis que "Color yellow" = correct)

(1) aPen go: 100 + 20 (Ici est-ce qu'on indique "Chiffre 100 + 20" ? ou "Addition 100 + 20" ? )	 
  		\/
(2) aPen go:    120 (Ici 120 au lieu de "aChiffre")

Dans ce cas :
(1) aPen color: yellow	
   		  \/
(2) aPen color: yellow  (Pourquoi "aColor" ? dans ce cas, au lieu de "120" mettre "aChiffre")



05/10/2020 - D09:00 - F13:00 - Chapitre 5 - Unaire> Binaire> Mots-clés p.65/259 FR 93/376 EN
-------------------------------------------------------------------------------------------------------05/10/2020 fin

-------------------------------------------------------------------------------------------------------06/10/2020 debut
06/10/2020 - D10:30 - F13:40 - Chapitre 5 - Unaire> Binaire> Mots-clés p.65/259 FR 93/376 EN
		             - Chapitre 5 - Quand utiliser [] ou () p.69/259 FR 99/376 EN

* Comparaison entre la Figure 5-2 p.88/376 EN et Figures 5-4, 5-5 p.93/376 EN

			message					message binary
		----------------				-------
		|		|				|     |
	total		<= max				total	 + 20 (10 ne peut pas être le total, il manque quelque chose)
    /		   |	         \	    		/	 |   \
receiver     message selector message arguments      receiver	m.s.   m.a.
  		|   / |   /  \  /		                 |     |
    \		ms ma ms ma ms ma			\       ms     ma
	        |  |  |  |  |  |				 |     |
	Color 	r: 1  g: 0  b: 0 		   10 # Somme    +  1: 10 2: 20 (ajouts 1: et 2:)
	       |		| 		  Pourtant : .. un message binaire envoyé au récepteur 10 ?
		-----------------


* Comparaison entre la Figure 5-2 p.88/376 EN et les Figures 5-4, 5-5 + Exemples 1 et 2 p.93/376 EN

		message unary yellow				    message binary + 20
	      ----------------					 -------------------
	      |	      	      |					 |                  |
objet->	  aPen    X  aColor <-			   objet->   aPen      X     120 <-	  
    /		  X	      \	    			/	       X   	    \     
receiver     message selector message argument      	receiver   m.selector  	 message argument
    |	   	  X   	        |     X   		|	       X     	     |      X
    |		 ms             |      ma 		|	       ms     	     |       ma
  color:(2)       X ---->----->--        X  		go:(2)	       X ---->----->--         X
    |		  X/		         X		|	       X/		       X
(keymessage) (1) Color <- (class send) <- yellow     (keymessage) (1) 100 <- (objet send) <- + 20 
      	     |				     | 		  	 |				 |
	     ----------------------------------			 ---------------------------------
	           a message send					a message send


	 aPen color: Color yellow				 aPen go: 100 + 20
	|------------------------|				|-----------------|
	        a message					     a message

Note : 
p.70/259 FR : ..., dont le sélecteur est composé d'un ou plusieurs caractères : +, -, *, etc.

Exemple 1. Dans le message aPen color: Color yellow, il y a un message unaire jaune envoyé à la classe Color et 
un message clé color: envoyé à aPen. 
Les messages unaires sont envoyés en premier afin que le message envoyé Color jaune soit envoyé (1). 
Cela renvoie un objet couleur qui est passé comme argument du message aPen color: aColor (2) 
comme indiqué dans le script suivant. 
La Figure 5-3 montre graphiquement comment les messages sont envoyés.

Example 1. In the message aPen color: Color yellow, there is one unary message yellow sent to the class Color and 
a keyword message color: sent to aPen. 
Unary messages are sent first so the message send Color yellow is sent (1). 
This returns a color object which is passed as argument of the message aPen color: aColor (2) 
as shown in the following script. 
Figure 5-3 shows graphically how messages are sent. 

Exemple 2. Dans le message aPen go: 100 + 20, il y a un message binaire + 20 et un message clé go:. 
Les messages binaires sont envoyés avant les messages de mots-clés, donc 100 + 20 sont envoyés en premier (1): 
le message + 20 est envoyé à l'objet 100 et renvoie le nombre 120. 
Ensuite, le message aPen go: 120 est envoyé avec 120 comme argument (2).

Example 2. In the message aPen go: 100 + 20, there is a binary message + 20 and a keyword message go:. 
Binary messages are sent prior to keyword messages so 100 + 20 is sent first (1): 
the message + 20 is sent to the object 100 and returns the number 120. 
Then the message aPen go: 120 is sent with 120 as argument (2).   


p.92/376 EN
Important règle un : Les messages unaires sont envoyés en premier, puis les messages binaires et enfin les messages
basés sur des mots clés. Unaire> Binaire> Mot-clé
p.93/376 EN
Important règle deux : Les messages entre parenthèses sont envoyés avant les autres messages. 
(Msg)> Unaire>Binaire> Mot-clé 
p.95/376 EN
Importante règle trois : Lorsque les messages sont de même nature, l'ordre d'évaluation est de gauche à droite.

Figure 5-16 - Equivalent messages using parentheses - p.97/376 EN
	(1)					   (3)					     (2)
 Bot new go: 100 + 20	is equivalent to (Bot new) go: (100 + 20) is equivalent to (Bot new) go: 100 + 20
|-------|   |--------|			|--------|    |--------|		   |-------|	 |-------|
     1		2			     1		   2				1	     2
|--------------------|			|----------------------|		   |---------------------|	
	  3					   3					      3

Notes : 
-----
p.98/376 EN, se répète "Parentheses or not?" et "Note".
La programmation devrait être simple, rapide et efficace (pragmatique).
Or, à partir de "5.4 Hints for identifying keyword messages" ont complexifie.
	* Identifier les messages clés,
	* Caractères : , ; () [],
	* Trop de chose à se rappeler (Recall from Chapter : Syntax in a that an expression can -p. 53/259 FR p. 75/376 EN)
	* 

06/10/2020 - D10:30 - F13:40 - Chapitre 5 - Quand utiliser [] ou () p.69/259 FR 99/376 EN
-------------------------------------------------------------------------------------------------------06/10/2020 fin 


-------------------------------------------------------------------------------------------------------07/10/2020 debut
07/10/2020 - D10:16 - F10:50 - Chapitre 5 - Quand utiliser [] ou () p.69/259 FR 99/376 EN
07/10/2020 - D10:51 - F11:47 - Chapitre 6 - p.71/259 FR 103/376 EN
07/10/2020 - D10:51 - F11:47 - Chapitre 6 - p.78/259 FR 113/376 EN

C'est tout simplement soporiphique avec trop de blabla.
Encore une fois "Situation confuse, embrouillée. Quel micmac !"
Méthodes abstraites et classes abstraites p.78/259 FR 113/376 EN.

07/10/2020 - D10:51 - F11:47 - Chapitre 6 - p.78/259 FR 113/376 EN
-------------------------------------------------------------------------------------------------------07/10/2020 fin


-------------------------------------------------------------------------------------------------------09/10/2020 debut
09/10/2020 - D10:33 - F00:00 - Chapitre 6 - p.78/259 FR 113/376 EN
09/10/2020 - D10:33 - F13:45 - Chapitre 6 - p.71/259 FR 103/376 EN

11:15 - Relecture - Chapitre 6 - p.71/259 FR 103/376 EN en mettant des mots et une représentation sur une carte.
Nom carte : Ph_chapitre 6.png

Rappel : 
--------
" une syntaxe si simple qu'il peut tenir sur une carte postale "

Au fur et à mesure de l'avancement du livre "pharo by example", je pense qu'étant donné que la syntaxe est si simple 
alors ils ont augmenté les difficultés dans ce programme "Pharo" et toutes ces classes et autres méthodes "tournicotit".

"Tourner en divers sens. Vous voulez bien cesser de tournicoter autour de moi, vous m’étourdissez !"
C'est exactement ce que je ressens depuis un bon moment et c'est très net lorsque j'ai arrêté la lecture 
au Chapitre 6 - p.71/259 FR 103/376 EN. 
12:10 09/10/2020

Difficulté : Anglais
Difficulté : Programme Pharo (La création se fait en décalé, "New xx" apparaît une fois sur deux, Protocole=méthode, etc..)
Difficulté : Syntaxe de la carte postale (C'est quand même compliqué, s'ajoute à cela : "U, B, MK" et "Syntaxe 2")
Difficulté : Unaire, binaire, message clé (Chaque ligne de code courte ou longue, il faudra décrypter à quoi cela correspond U, B, MK, chap.4)
Difficulté : Syntaxe 2 (Crochets, parenthèses, priorité opérations, chap. 5) 
Difficulté : Objet (L'objet est un mot représentant un code donc aucun intérêt d'appeler ce mot objet, qu'est-ce qui n'est pas objet ?)
11:55 09/10/2020

A la fin du chapitre 5, le concept "d'objet" répété en boucle, n'a aucun sens.

09/10/2020 - D10:33 - F13:45 - Chapitre 6 - p.71/259 FR 103/376 EN
-------------------------------------------------------------------------------------------------------09/10/2020 fin


-------------------------------------------------------------------------------------------------------12/10/2020 debut
12/10/2020 - D09:12 - F00:00 - Chapitre 6 - p.71/259 FR 103/376 EN
12/10/2020 - D09:12 - F11:55 - Chapitre 6 - p.72/259 FR 104/376 EN

Reprise p. 71/103.
p. 104 EN
playground> 1 class> clic droit "print it" = SmallInteger"

11:11 12/10/2020 "Pharo_negatifs_positifs.txt"
4. À partir de Playground, une ligne de code peut avoir plusieurs espaces entre les mots, ça ne provoque aucune erreur.
(p.72/259 FR 104/376 EN)
Exemple : 
Entre le mot "new" et "class", il y a trois espaces.
Playground> Object new class -> "CTRL + P" -> affiche "Objet".


12/10/2020 - D09:12 - F11:55 - Chapitre 6 - p.72/259 FR 104/376 EN
-------------------------------------------------------------------------------------------------------12/10/2020 fin


-------------------------------------------------------------------------------------------------------13/10/2020 debut
13/10/2020 - D09:52 - F00:00 - Chapitre 6 - p.72/259 FR 104/376 EN
13/10/2020 - D09:52 - F12:10 - Chapitre 6 - p.73/259 FR 105/376 EN

Interrogation : 
---------------

Chaque méthode a un nom, appelé son sélecteur, qui est unique dans la classe.(p.72/259 FR)

Donc, prenons comme exemple la méthode "initialize" qui est unique dans la classe.
Cette méthode a un sélecteur nommé "initialize" qui est unique, mais pas son contenu !

Comme présenté dans les codes ci-dessous : 
------------------------------------------

Le code "LOCell>>initialize" : "LOCell> initialization> initialize"
initialize
super initialize.
self label: ''.
self borderWidth: 2.
bounds := 0 @ 0 corner: 16 @ 16.
offColor := Color paleYellow.
onColor := Color paleBlue darker.
self useSquareCorners.
self turnOff

Est différent de "LOGame>>initialize" : "LOGame> initialization> initialize"
initialize
| sampleCell width height n |
super initialize.
n := self cellsPerSide.
sampleCell := LOCell new.
width := sampleCell width.
height := sampleCell height.
self bounds: (5 @ 5 extent: (width * n) @ (height * n) + (2 * self borderWidth)).
cells := Matrix new: n tabulate: [ :i :j | self newCellAt: i at: j ]

10:47 13/10/2020
Donc, concernant "initialize" on ne peut pas dire que c'est un nom unique alors qu'il a des contenu différent.


p.40/259 FR - p.55/376 EN
30. Inspection d'un objet - À propos du reste -  p. 55/376 EN.
La flèche verte à côté de la méthode "initialize". 
Cela signifie :
la méthode existe dans la superclasse "SimpleSwitchMorph" et qu'elle est remplacée dans votre classe "LOCell".

11:21 13/10/2020
Une classe dont les instances sont des classes s'appelle une métaclasse. p.72 104.

11:30 13/10/2020
6.4 Structure et comportement de l'instance

Interrogation : ? 
---------------
"Nous disons que la limite d'encapsulation des objets en Java et C ++ est la classe, alors que dans Pharo c'est l'instance." 
Si tout est objet et instance d'une classe alors "instance" est une instance d'une classe et parmi celles-ci la "classe".
Donc, ce n'est pas limité à la "classe - instance d'une classe", mais à toutes instances d'une classe.

Mise à jour du Fichier "Ph_chap.6.png". (D:\Documents de user\Documents\INFORMATIQUE\PROGRAMMATION\Pharo)

À tête reposée, il faudra relire : p.73/259 Variables d'instance.
13/10/2020 - D09:52 - F12:10 - Chapitre 6 - p.73/259 FR 105/376 EN
-------------------------------------------------------------------------------------------------------13/10/2020 fin


-------------------------------------------------------------------------------------------------------14/10/2020 debut
14/10/2020 - D10:42 - F00:00 - Chapitre 6 - p.73/259 FR 105/376 EN
14/10/2020 - D10:42 - F13:32 - Chapitre 6 - p.74/259 FR 107/376 EN

10:52 14/10/2020 - p.73 FR 105 EN
Exemple d'encapsulation d'instance, ce n'est pas très clair. (dessin)

Point>> dist:

1@1 dist: 4@5
>>> 5.0

récepteur --calcul--- point
  / \		      x  y (<- variables d'instance accessible en envoyant les messages x et y)	
 x   y (<- acces direct corps méthode)

p.73 FR 106 EN
	     (1)						(2)
encapsulation basée sur l'instance		encapsulation basée sur la classe
	     \/
Coexistence de l'implémentation
de la même abstraction.

Exemple d'encapsulation : 
------------------------

Point >> dist: aPoint
"Answer the distance between aPoint and the receiver." (Répondez à la distance entre aPoint et le récepteur.)
| dx dy |
dx := aPoint x - x.
dy := aPoint y - y.
^ ((dx * dx) + (dy * dy)) sqrt
p.73 FR 106 EN
La méthode dist: n'a pas besoin de savoir ou de l'argument aPoint est une instance de la même classe que le récepteur.

11:58 14/10/2020
61. Chap. 6 6.4 Methods - p.74 FR 106 EN
"Cette pratique a une certaine valeur, mais elle encombre également l'interface de vos classes, 
et pire, elle expose son état privé au monde."
Parce que le fait qu'une méthode soit publique et qu'elle puisse accéder à toutes les variables d'instance "privées"
c'est ne pas exposer son état privé au monde ?

12:28 14/10/2020 - p.74 FR 106 EN
On est loin de la simple syntaxe qui peut tenir sur une carte postale.

13:31 14/10/2020
62. Chap. 6 Figure 6-2 - p.74 FR 107 EN 
Côté instance "Int. side" et côté classe "Class side".
Ce n'est pas particulièrement flagrant cette différence et surtout, 
on est loin de la simple syntaxe qui peut tenir sur une carte postale.
"Vous trouverez donc la méthode blue définie du côté classe de Color, et non du côté instance."

Il n'y a que le protocole qui change : 
Inst. side
Graphics-Primitives> Color> accessing> blue
Class side
Graphics-Primitives> Color> defaults> blue
Sinon c'est deux chemins mènent à Rome.
Effectivement, ce n'est pas la même chose, mais c'est quand même compliqué cette histoire.
Plus j'avance dans ce document et plus ça devient compliqué. 

Mise à jour du Fichier "Ph_chap.6.png". (D:\Documents de user\Documents\INFORMATIQUE\PROGRAMMATION\Pharo)

14/10/2020 - D10:42 - F13:32 - Chapitre 6 - p.74/259 FR 107/376 EN
-------------------------------------------------------------------------------------------------------14/10/2020 fin


-------------------------------------------------------------------------------------------------------15/10/2020 debut
15/10/2020 - D11:19 - F00:00 - Chapitre 6 - p.74/259 FR 107/376 EN
15/10/2020 - D11:19 - F12:10 - Chapitre 6 - p.75/259 FR 109/376 EN

11:35 15/10/2020
6.5 Le côté instance et le côté classe

11:42 15/10/2020
"Class methods - For those familiar with Java and C++......."
Ce paragraphe répète ce qui a déjà été annoncé plus haut. Je m'en balance de Java et C++.
Ça rame sur place cette histoire.

11:58 15/10/2020
63. Chap. 6 Figure 6-2 - p.75 FR 107 EN 
"double-click just at the beginning of the comment "(Color wheel: 12) inspect" and press CMD-d. 
You will see the effect of executing this method."
Comment verrais-je cette exécution, le résultat ? Parce que rien ne se passe en cliquant au début de la ligne.
CTRL + P clavier donne Color .................................?????

12:10 15/10/2020
J'arrête là le micmac.
Example: Class instance variables and subclasses - p.75/259 FR 109/376 EN.

Mise à jour du Fichier "Ph_chap.6.png". (D:\Documents de user\Documents\INFORMATIQUE\PROGRAMMATION\Pharo)

15/10/2020 - D11:19 - F12:10 - Chapitre 6 - p.75/259 FR 109/376 EN
-------------------------------------------------------------------------------------------------------15/10/2020 fin



-------------------------------------------------------------------------------------------------------16/10/2020 debut
16/10/2020 - D10:11 - F00:00 - Chapitre 6 - p.75/259 FR 109/376 EN
16/10/2020 - D10:11 - F12:00 - Chapitre 6 - p.82/259 FR 117/376 EN

Mise à jour du Fichier "Ph_chap.6.png". (D:\Documents de user\Documents\INFORMATIQUE\PROGRAMMATION\Pharo)

Reprise : 
Example: Class instance variables and subclasses - p.75/259 FR 109/376 EN.

metaclasse
dog
class		sous-class	variable d'instance	method		methode de classe
dog		hyena		count					count

dog new							initialize		

"Now suppose we define class methods for Dog to initialize its count to 0, and
to increment it when new instances are created:"
10:40 16/10/2020
À quoi ça sert de ce compliqué le mou comme ça. C'est complètement débile ! p.77 FR 110 EN
Allez super, passons à la suite.

10:56 16/10/2020
On s'éloigne de plus en plus de la simple syntaxe qui peut tenir dans une carte postale. 
(class, metaclass, instance, instance class, method, method class) Quel bordel !

Exemple : définition d'un singleton (c'est quoi encore ce truc : singleton)

P.76 FR
"Exemple: définition d'un singleton
Le modèle Singleton fournit un exemple typique de l'utilisation de variables d'instance de classe et de méthodes de classe.
Imaginez que nous aimerions implémenter une classe  WebServer , et utiliser le modèle Singleton pour nous assurer qu'il n'a
qu'une seule instance."

Pourquoi indiquer webserver en une classe alors que c'est une metaclasse ?

class				variable d'instance class 	variable d'instance	method de classe
webserver (metaclasse)		uniqueinstance						uniqueinstance
				webserver

sous-class
reliablewebserver

(initialisation paresseux)
p.77 FR

x2 avant il fallait éviter de passer par "accessing", maintenant il faut éviter "d'initialiser 
à la place des variables d'instance dans leurs méthodes d'accès respectives ( en utilisant ifNil: checks), 
évitez cela à moins que vous n'ayez une bonne raison. p.77 FR

"car les utilisateurs ne s'attendent généralement pas à appeler WebServer initialize."
Ba voyons, si tu le dis.

"Chaque classe de Pharo hérite de son comportement et de la description de sa structure d'une seule superclasse. 
Cela signifie que Smalltalk a un héritage unique."
Cela signifie plutôt que c'est complètement tordu. Ce prendre la tête avec tous ces allez et venus qui vont dans tous les sens.

11:20 16/10/2020
Les traits sont des collections de méthodes qui peuvent être réutilisées par plusieurs classes qui ne sont pas liées 
par héritage. L'utilisation de traits permet de partager du code entre différentes classes sans dupliquer le code.
p. 78 FR 113 EN

"Les méthodes self subclassResponsibility doivent toujours être remplacées et ne doivent donc jamais être exécutées. 
Si vous oubliez d'en remplacer une et qu'elle est exécutée, une exception sera levée."
Putain, c'est quoi ce truc franchement. Si j'ai envie d'oublier mes clés alors, je les oublierais.  

Alors maintenant, j'ai droit à la classe et méthode abstraite.

class abstraite		méthodes
magnitude		<, =, hash, >, >=, <=, max:, min: entre: et:

sous-classe

D'un côté, s'est abstrait, mais de l'autre "> =" est concret, mais oui pourquoi faire simple.
Franchement, c'est dû n'importe quoi. p.79 FR
Quelle prise de tête : "elles sont toutes définies en termes de méthode abstraite <."
Si elles sont toutes pourquoi "> =" ne l'ai pas ? Encore une fois c'est contradictoire.

11:38 16/10/2020
Avant 
11:20 16/10/2020
Les traits sont des collections de méthodes qui peuvent être réutilisées par plusieurs classes qui ne sont pas liées 
par héritage. L'utilisation de traits permet de partager du code entre différentes classes sans dupliquer le code.
p.78 FR

Après
Un  trait est une collection de méthodes qui peuvent être incluses dans le comportement d'une classe sans avoir besoin
d'héritage. Cela permet aux classes d'avoir facilement une superclasse unique, tout en partageant toujours des méthodes
utiles avec des classes autrement non liées.
p. 79 FR

Pfou ! trop de blabla.

11:43 16/10/2020
6.7 Tout se passe en envoyant des messages.
11:54 16/10/2020
Les déclarations de variables, affectations, retours, primitives ne sont pas des envois de messages.
p. 81 FR

	recherche (la méthode portant le même nom que le message est recherchée)	execution
		  objet

		message unary yellow		
	      ----------------			
	      |	      	      |			
objet->	  aPen    X  aColor <-			 
    /		  X	      \	    		  
receiver     message selector message argument      
    |	   	  X   	        |     X   		
    |		 ms             |      ma 	
  color:(2)       X ---->----->--        X  		
    |		  X/		         X		
(keymessage) (1) Color <- (class send) <- yellow   
      	     |				     | 		  	
	     ----------------------------------			
	           a message send (yellow - Recherche)					


	 aPen color: Color yellow				
	|------------------------|				
	        a message

Que se passe-t-il lorsqu'une méthode ne renvoie pas explicitement une valeur?
Que se passe-t-il lorsqu'une classe réimplémente une méthode de superclasse?
Quelle est la différence entre self et super envoie ?
Que se passe-t-il lorsqu'aucune méthode n'est trouvée ?					  
p.81-82 FR

16/10/2020 - D10:11 - F12:00 - Chapitre 6 - p.82/259 FR 117/376 EN
-------------------------------------------------------------------------------------------------------16/10/2020 fin


-------------------------------------------------------------------------------------------------------17/10/2020 debut
17/10/2020 - D10:01 - F00:00 - Chapitre 6 - p.82/259 FR 117/376 EN
17/10/2020 - D10:01 - F13:07 - Chapitre 6 - p.83/259 FR 120/376 EN


Que se passe-t-il lorsqu'une méthode ne renvoie pas explicitement une valeur?
Que se passe-t-il lorsqu'une classe réimplémente une méthode de superclasse?
Quelle est la différence entre self et super envoie ?
Que se passe-t-il lorsqu'aucune méthode n'est trouvée ?					  
p.81-82 FR


10:22 17/10/2020
Ma représentation avant de visualiser la figure 6-19.
		
		anEllipse defaultColor (1 message)
superclass	class		method		method
   \/		EllipseMorph ->	defaultColor ->	Color yellow
   \/
   \/		
   \/		anEllipse openInWorld (2 message)
superclass	class		method		method
		EllipseMorph <-	openInWorld 	? rien
		        \/--------->---------------/\
     \/La recherche se poursuit dans la superclasse <|
Bordered-Morph->Morph ->	openInWorld
	|------------------------------------------/\

10:48 17/10/2020
Figure 6-19 - p.82 FR 119 EN 												p.82 FR 118 EN
message									Class/Method			Method		SuperClass			Method		Class
anEllipse openInWorld -> envoie message -> anEllipse -> recherche -> (C) EllipseMorph -> recherche -> (M)initialize - (SC) BorderedMorph -> recherche ->(M) initialize - (C) Morph
						\|->	instance-of -> (M) defaultColor							    		(M) defaultColor

Je ne vois pas l'intérêt de mettre "Objet" à la fin de la recherche, ça n'a aucun intérêt puisqu'il recherche "defaultcolor".
																	    		(M) openInWorld
Est-ce qu'ils se rendent compte que c'est n'importe quoi ? 
Passer d'une méthode à la classe et retourner à une méthode pour aller dans une superclasse et se rediriger dans une méthode et une autre classe,
ponctué par des doublons "defaultcolor" et "iniitialize".
Quelle perte de temps et d'incohérence !

11:25 17/10/2020
"Pourquoi écrire explicitement ^ self n'est-il pas une si bonne chose à faire ?"
Ce n'est pas très clair.
p.83 FR 118 EN
"Renvoyez une valeur uniquement lorsque vous souhaitez que l'expéditeur l'utilise."
Important Par défaut (si cela n'est pas spécifié différemment) une méthode renvoie le destinataire du message.

11:53 17/10/2020
Réponse p.83 FR 118 EN - "nous voyons que les classes Morph et EllipseMorph implémentent toutes deux defaultColor.
En ouvrant un "Morph new openInWorld", nous obtenons un morph bleu alors qu'une ellipse sera jaune.
 
"Nous disons que EllipseMorph remplace la méthode defaultColor qu'il hérite de Morph. 
La méthode héritée n'existe plus du point de vue anEllipse." p.83 FR 120 EN. 

a. anEllipse openInWorld new = un rond jaune (anEllipse new openInWorld = ne fonctionne pas)
b. EllipseMorph new openInWorld = ronds jaunes
c. BorderedMorph new openInWorld = carrés bleus
d. Morph new openInWorld = carrés bleus

L'ellipse aurait très bien pu être une couleur bleue par défaut : 12:28 17/10/2020

1. L'ordre des mots n'est pas pareil entre "a" et "d", (new après Morph)
1.1 Nouvelle commande ligne "b",
2. La commande ligne "d" associé à Print it, renvoie tout le temps des carrés bleus. Ce n'est pas le cas pour la ligne "a",
2.1 Par contre, la ligne "b" affiche tout le temps des ellipses jaunes,
3. La commande de la ligne "a" renvoie qu'une ellipse jaune contrairement à la ligne "b".
															p.82 FR 118 EN
message									Class/Method			Method		SuperClass			Method		Class
anEllipse openInWorld -> envoie message -> anEllipse -> recherche -> (C) EllipseMorph -> recherche -> (M)initialize - (SC) BorderedMorph -> recherche ->(M) initialize - (C) Morph
						\|->	instance-of -> (M) defaultColor							    		(M) defaultColor
																			(M) openInWorld
INITIALIZE
----------

BorderedMorph new openInWorld - Print It (CTRL + I)															    		
Meta> BorderedMorph> initialize
initialize
	"initialize the state of the receiver"
	super initialize.
	
	self borderInitialize


Morph new openInWorld - Print It (CTRL + I)
Meta> Morph> initialize
initialize
	"initialize the state of the receiver"

	super initialize.
	submorphs := EmptyArray.
	bounds := self defaultBounds.
	color := self defaultColor

13:00 17/10/2020
COLOR
-----

EllipseMorph new openInWorld - Print It (CTRL + I)
Meta> EllipseMorph> defaultColor
defaultColor
	"answer the default color/fill style for the receiver"
	^ Color yellow


Morph new openInWorld - Print It (CTRL + I)
Meta> Morph> defaultColor
defaultColor
	"answer the default color/fill style for the receiver"
	^ Color blue

17/10/2020 - D10:01 - F13:07 - Chapitre 6 - p.83/259 FR 120/376 EN
-------------------------------------------------------------------------------------------------------17/10/2020 fin


-------------------------------------------------------------------------------------------------------18/10/2020 debut
18/10/2020 - D10:59 - F00:00 - Chapitre 6 - p.83/259 FR 120/376 EN
18/10/2020 - D10:59 - F13:43 - Chapitre 6 - p.84/259 FR 122/376 EN

Comment veux-tu ne pas perdre la boule avec ces explications contradictoires ?

message -> destinataire - class destinataire
		self	- recherche

message -> recepteur - class recepteur
		self - recherche

"self représente le destinataire du message et la recherche de la méthode démarre dans la classe du destinataire." p.84 FR
"self represents the receiver of the message and the lookup of the method starts in the class of the receiver." p.121 EN

"self représente le récepteur du message et la recherche de méthode commence dans la classe du récepteur." p.84 FR 
"self represents the receiver of the message and the method lookup starts in the class of the receiver." p.121 EN
"self représente le récepteur du message et la méthode regarde les démarrages dans la classe du récepteur" autre traduction

"super représente le récepteur du message et la recherche de la méthode démarre dans la superclasse de la classe de la méthode où se produit le super envoi." 
(Plus il y a de fous récepteurs, plus on rigole et puis pour emmerder le monde tu démarreras dans la superclasse.)

11:38 18/10/2020

Avec les infos transmises par le paragraphe, interprétation du message envoyé : 
message			superclass	class		method
constructorString	EllipseMorph	BorderedMorph	fullPrintOn:

Je ne vois pas l'intérêt de mettre "Objet" à la fin de la recherche, ça n'a aucun intérêt puisqu'il recherche "fullPrintOn:".

64. Chap. 6 - p.84 FR 122 EN - Figure 6-25 - p.122 EN - Tournicoti - (Vous voulez bien cesser de tournicoter autour de moi, vous m’étourdissez !)				
                                                         ----------<--------------------------------<---------------------------<---------	
							\|										 |\
message						  class recepteur		method		       class				 |\	                 					        	       
anEllipse constructorString-> envoie message(1)-> (C)anEllipse-> recherche(2)-> (M)constructorString-> (C)Morph-> message(3)-> self fullPrintOn:  
							\|		        (M)fullPrintOn:	                  -------->----------------------------->---------|\
							\|	    						 /|                                          method		    class                               
							\|-----> recherche(4)-> (M)fullPrintOn:------> (SC)BorderedMorph-> message(5)-> super fullPrintOn:-> (M)constructorString-> (C)Morph
							\|				/|								     (M)fullPrintOn:
							\|				/|----------<---------|\		    						     					   
							\|--> instance-of---->  (M)defaultColor------> (C)EllipseMorph

instance-of = la classe (C)anEllipse est une instance de la méthode (M)defaultColor ou la classe (C)EllipseMorph, c'est qui le 1 ?

"Le message fullPrintOn: est recherché à partir de la classe EllipseMorph, et la méthode BorderedMorph>>fullPrintOn: se trouve dans BorderedMorph".
Non, il y a une erreur !  
D'abord la méthode EllipseMorph>>defaultColor, puis la méthode BorderedMorph>>fullPrintOn: au lieu de commencer par la classe EllipseMorph.							
(Un dessin vaut mille mots).

Parce qu'il traite des doublons "fullPrintOn:" alors "super" apparaît ?													    	

(J'ai recréé le schémas de la Figure 6-19 - p.82 FR 119 EN)
message 				    class recepteur		  class			           method	   superclass			      method	      class
anEllipse openInWorld-> envoie message(1)-> (C)anEllipse-> recherche(2)-> (C)EllipseMorph-> recherche(3)-> (M)initialize-> (SC)BorderedMorph-> recherche(4)-> (M)initialize-> (C)Morph																		
						\|   			  method /\									      (M)defaultColor
						\|---> instance-of------> (M)defaultColor								      X(M)openInWorld X	

instance-of = la classe (C)anEllipse est une instance de la méthode (M)defaultColor ou la classe (C)EllipseMorph, c'est qui le 1 ?

65. Chap. 6 - p.85 FR 122 EN - EllipseMorph Classe ou sous-classe ? 
p.85 FR
"Le message fullPrintOn: est recherché à partir de la classe EllipseMorph, et la méthode BorderedMorph>>fullPrintOn: 
se trouve dans BorderedMorph (voir Figure  6-25)."
p.122 EN
"The message fullPrintOn: is looked up starting in the class EllipseMorph, and the method BorderedMorph>>fullPrintOn: 
is found in BorderedMorph (see Figure 6-25)."

p.85 FR
".....redéfinissez la méthode dans cette sous-classe. 
Ici, EllipseMorph pourrait redéfinir la méthode fullPrintOn: et cette méthode serait exécutée par la méthode constructorString."
p.123 EN 							      
".....redefine the method in that subclass. 
Here EllipseMorph could redefine the method fullPrintOn: and this method would be executed by method constructorString." 

18/10/2020 - D10:59 - F13:43 - Chapitre 6 - p.84/259 FR 122/376 EN
-------------------------------------------------------------------------------------------------------18/10/2020 fin


-------------------------------------------------------------------------------------------------------22/10/2020 debut
22/10/2020 - D09:59 - F00:00 - Chapitre 6 - p.84/259 FR 122/376 EN
22/10/2020 - D09:59 - F13:31 - Chapitre 6 - p.85/259 FR 123/376 EN

66. Chap. 6 - p.85 FR 123 EN - 6.8 La recherche de méthode suit la chaîne d'héritage
"Notez qu'en regardant uniquement la méthode  construc-torString, nous ne pouvons pas prédire quelle méthode 
fullPrintOn: (soit celle d' EllipseMorph, BorderedMorph ou Morph) sera exécutée"
Or, d'après la "Figure 6-25 self and super sends p.122", aucune méthode "fullPrintOn:" 
n'est rattachée à EllipseMorph. Vérifions cela sur les Figures ci-dessous, 6-25, et Pharo. :-) 
				
                                                         ----------<--------------------------------<---------------------------<---------	
							\|										 |\
message						  class recepteur		method		       class				 |\	                 					        	       
anEllipse constructorString-> envoie message(1)-> (C)anEllipse-> recherche(2)-> (M)constructorString-> (C)Morph-> message(3)-> self fullPrintOn:  
							\|		        (M)fullPrintOn:	                  -------->----------------------------->---------|\
							\|	    						 /|                                          method		    class  	ajout p.85 FR                             
							\|-----> recherche(4)-> (M)fullPrintOn:------> (SC)BorderedMorph-> message(5)-> super fullPrintOn:-> (M)constructorString-> (C)Morph ->	Object - ProtoObject
							\|				/|								     (M)fullPrintOn:
							\|				/|----------<---------|\		    						     					   
							\|--> instance-of---->  (M)defaultColor------> (C)EllipseMorph

instance-of = la classe (C)anEllipse est une instance de la méthode (M)defaultColor ou la classe (C)EllipseMorph, c'est qui le 1 ?

Tournicoti - (Vous voulez bien cesser de tournicoter autour de moi, vous m’étourdissez !)

11:36 22/10/2020
p.85 FR 123 EN
"Important Un self envoi déclenche une recherche de méthode commençant dans la classe du récepteur. 
Un self envoi est dynamique en ce sens qu'en regardant la méthode qui le contient, 
nous ne pouvons pas prédire quelle méthode sera exécutée."
Encore une fois "Situation confuse, embrouillée. Quel micmac !"

11:42 22/10/2020
p.85 FR 123 EN
"Notez que la super recherche n'a pas commencé dans la superclasse du récepteur. 
Cela aurait provoqué la recherche à partir de BorderedMorph, résultant en une boucle infinie !"
De mon point de vue, cela prouve donc que le fait d'avoir décalé "super recherche" qu'il y a un problème.

11:50 22/10/2020
p.85 FR 123 EN
"les super liaisons sont statiques: tout ce qui compte, c'est la classe dans laquelle se trouve le texte du super envoi. 
En revanche, le sens de self est dynamique: il représente toujours le récepteur du message en cours d'exécution." 

12:03 22/10/2020 - 12:18 22/10/2020
Mise à jour du Fichier "Ph_chap.6.png". (D:\Documents de user\Documents\INFORMATIQUE\PROGRAMMATION\Pharo)

12:54 22/10/2020
Mon interprétation 		ProtoObject
message		    methode	object		    message		 object				    
foo	recherche-> foo ->	?	-> envoie-> message dynamique-> selfNotUnderstand: #foo 
\|/|										     	     \|
\|/|---------------------<------------------------------------<-----------------------<--------
\|  		method		  class		 method			object				object			debugger
recherche-> doesNotUnderstand-> EllipseMorph->  ? doesNotUnderstand-> doesNotUnderstand-> création-> MessageNotUnderstood-> 	debugger

12:57 22/10/2020 - 13:04 22/10/2020
p.86 FR 124 EN - Figure 6-26

message 	    class			      ProtoObject method		dynamique	   method
anEllispe foo(1)->  (C)anEllipse-> recherche(2)-> object->    (M)doesNotUnderstand-> message send(3)-> (M)self doesNotUnderstand: #foo
		    \|    \|  /|												       \|
		    \|    \|2 /|1												       \|
		    \|    \|  /|-------------------<------------------------------------<-----------------------------<-------------
		    \|    \|-instance-of--(C)EllipseMorph-> (SC)BorderedMorph-> (C)Morph-> doesNotUnderstand-> Object-> debugger 1 ici ou en bas ?
		    \|			   /| |/
		    \|	suppléments >	   /| |/----->--------->--- 
		    \|			   /|			  |/
		    \|------> recherche(4)-> (M)doesNotUnderstand-> object-> debugger 1 ici ou en haut ?

instance-of = la classe (C)anEllipse est une instance de la classe (C)EllipseMorph.

Encore une fois "Situation confuse, embrouillée. Quel micmac !"

22/10/2020 - D09:59 - F13:31 - Chapitre 6 - p.85/259 FR 123/376 EN
-------------------------------------------------------------------------------------------------------22/10/2020 fin


-------------------------------------------------------------------------------------------------------23/10/2020 debut
23/10/2020 - D09:42 - F00:00 - Chapitre 6 - p.85/259 FR 123/376 EN
23/10/2020 - D09:42 - F13:42 - Chapitre 6 - p.86/259 FR 124/376 EN

09:53 23/10/2020
p.85 FR 124 EN
"En fait, cela peut être un moyen simple d'implémenter la délégation automatique des messages d'un objet à un autre.
Un objet Delegator pourrait simplement déléguer tous les messages qu'il ne comprend pas à un autre objet dont la
responsabilité est de les gérer, ou déclencher une erreur lui-même!"
Je ne comprends pas ce paragraphe, parce que c'est ce qui a été fait puisqu'il a cherché dans les différentes class
la méthode qui n'a pas été trouvé et un "MessageNotUnderstood" dans "protoobjet" a déclenché le debugger.
Ce n'est pas moi qui l'ai fait manuellement ?

09:55 23/10/2020
p.86 124 EN
"Nous allons maintenant examiner un aspect de Pharo qui n'est pas si facilement couvert par nos cinq règles: 
les variables partagées."
MDR ! -> "n'est pas si facilement".
À ce jour, je suis au fond de l'océan sans scaphandre.


					VARIABLES PARTAGEES
(1) Variables Partagées totalement	(2) Variables partagées de classe	(3) Variables partagées de pool
 partage à l'échelle mondiale		  partages entre les instances		 partages entre un groupe de classes
					  et les classes

Notes : 
-------
Variables de classe vs variables d'instance de classe.	
minuscule = variables d'instance de classe
Mise à jour (12:53 28/10/2020)
majuscule = Variables partagées globales, Variables partagées de classe, Variables partagées de pool, noms de classe	

12:47 23/10/2020
p.76
"Important Une classe n'a pas accès aux variables d'instance de ses propres instances. 
Une instance d'une classe n'a pas accès aux variables d'instance de classe de sa classe."

p.86 FR 124 EN
"Les noms de toutes ces variables partagées commencent par une majuscule, pour nous avertir qu'elles sont
effectivement partagées entre plusieurs objets." 

13:11 23/10/2020
p.86 124 EN
"Les variables globales sont accessibles partout. Chaque classe est nommée par une variable globale."
p.86 124 EN
"La pratique recommandée est de limiter strictement l'utilisation de variables globales."

10:14 23/10/2020 - 12:11 23/10/2020 - 12:45 23/10/2020 - 13:42 23/10/2020
Mise à jour du Fichier "Ph_chap.6.png". (D:\Documents de user\Documents\INFORMATIQUE\PROGRAMMATION\Pharo)

23/10/2020 - D09:42 - F13:42 - Chapitre 6 - p.86/259 FR 124/376 EN
-------------------------------------------------------------------------------------------------------23/10/2020 fin


-------------------------------------------------------------------------------------------------------24/10/2020 debut
24/10/2020 - D09:42 - F00:00 - Chapitre 6 - p.86/259 FR 124/376 EN
24/10/2020 - D09:42 - F13:50 - Chapitre 6 - p.86/259 FR 124/376 EN

10:04 24/10/2020
Rappel, c'est quoi instance-of ou instance of ? une instance de
J'imaginais "of" comme "arrêt", ça m'a induit en erreur et à me questionner.

p.26 FR 35 EN
"The title tells us that 7 is an instance of the class SmallInteger."
"Le titre nous dit que 7 est une instance de la classe SmallInteger."

p.47 FR 66 EN
"Dans ce cas, nous pouvons voir dans la première ligne du panneau supérieur que le message toggleState 
a été envoyé à une instance de LOGame, alors qu'il aurait clairement dû être une instance de LOCell."
"In this case we can see in the first line of the top panel that the toggleState
message has been sent to an instance of LOGame, while it should clearly have been an instance of LOCell."

p.258/259 FR 375 EN
"La relation instance-of forme une boucle fermée, donc la classe de classe Metaclass est Meta-class." 
recherche instance of

10:23 24/10/2020 - 10:36 24/10/2020
Mise à jour des Figures 6-26, 6-25, 6-19, 


67. Chap. 6 - p.86 FR 124 EN - Variables globales
p.86 FR 124 EN
"Les variables globales sont accessibles partout. Chaque classe est nommée par une variable globale."
p.86 124 EN
"La pratique recommandée est de limiter strictement l'utilisation de variables globales."

Je m'interroge alors que chaque classe est nommée par une variable globale accessible partout, 
et l'on recommande de limiter son utilisation.
C'est une situation confuse, embrouillée et carrément contradictoire.
Limiter strictement son utilisation alors que chaque classe est nommée par une variable globale !
Supprimez là où changer la manière de procéder.
Pourquoi faire simple quand on peut écrire une carte postale ?
Franchement, à ce stade de lecture en plus d'être au fond de l'océan, il faut se pendre.


68. Chap. 6 - p.86 FR 124 EN - Variables globales - SystemDictionary
J'ai interrogé "SystemDictionary" pensant voir "Smaltalk" ainsi que les variables partagées globales.
Or, il n'en est rien et j'ai découvert dans la hiérarchie des classes qu'"Object" et "ProtoObject" sont 
deux classes distinctes alors que dans le livret s'accorde à dire que c'est la même chose.
p.85 FR 123 EN
"jusqu'à Object (ou plutôt ProtoObject)"
"the way up to Object (or rather ProtoObject)"
Pourquoi faire simple quand on peut écrire une carte postale ?


11:56 24/10/2020 -15 mns
Notes : 
-------
Variables de classe vs variables d'instance de classe.	
minuscule = variables d'instance de classe
Mise à jour (12:53 28/10/2020)
majuscule = Variables partagées globales, Variables partagées de classe, Variables partagées de pool, noms de classe

13:47 24/10/2020
69. Chap. 6 - p.86 FR 124 EN - Variables globales - SystemDictionary 2
J'ai compris une autre manière pour accéder au "Variables partagées globale" en prenant exemple avec
"Processor class" donc "SystemDictionary" -> CTRL + I

Inspector on a SystemDictionary class (SystemDictionary)
(C)aSystemDictionary [9097 items] (lots of globals)-> Items-> Keys -> (VPG)#IceTipHistoryDiffUpdater->
Smalltalk-> 
(C)SystemDictionary-> Instance d'une  classe=metaclasse-> (C)Object-> (SC)#IceTipHistoryDiffUpdater->
									(C)IceTipHistoryDiffUpdater

C'est tiré par les cheveux cette histoire, le chemin est long et semé d'embuche.
Visuellement, ce sont des valeurs en doublons, car (C)Classe est le doublon de (SC)Sous-classe, qui est le doublon de (VPG)Variable Partagées Globale.
En dehors de #.

Donc, SystemDictionary est une classe, une instance d'une classe, une metaclasse, un objet, un protoobject,
un object class, un protoobject class, etc.. 
Il manque quelque chose pour pimenter tout ça, peut-être ajouter autre chose pour boucler la boucle.

12:24 25/10/2020 (Supplément) - SystemDictionary stocke les variables partagées globales.
Playground> SystemDictionary class > CTRL + I
Inspector on a Metaclass (SystemDictionary class)
a Metaclass (SystemDictionary class)

Playground> SystemDictionary> CTRL + I
Inspector on a SystemDictionary class (SystemDictionary)
a SystemDictionary class (SystemDictionary)

24/10/2020 - D09:42 - F13:50 - Chapitre 6 - p.86/259 FR 124/376 EN
-------------------------------------------------------------------------------------------------------24/10/2020 fin


-------------------------------------------------------------------------------------------------------/10/2020 debut
25/10/2020 - D11:11 - F00:00 - Chapitre 6 - p.86/259 FR 124/376 EN
25/10/2020 - D11:11 - F13:36 - Chapitre 6 - p.86/259 FR 124/376 EN

11:23 25/10/2020
J'ai cliqué sur la seconde image et une fenêtre blanche est apparue en bas de Pharo.
J'ai fermé Pharo puis ouvert là première image et même message alors qu'avant aucun problème.

# Debug console
# To close: F2 -> 'debug options' -> 'show output console'
# To disable: F2 -> 'debug options' -> 'show console on errors'
LoadLibrary(SurfacePlugin) (998: L’ÿaccèÿs àÿ cet emplacement de la méÿmoire n’ÿest pas valide.)
LoadLibrary(SurfacePlugin.dll) (998: L’ÿaccèÿs àÿ cet emplacement de la méÿmoire n’ÿest pas valide.)
LoadLibrary(D:\Liberkeys\MyApps\Pharo\SurfacePlugin) (998: L’ÿaccèÿs àÿ cet emplacement de la méÿmoire n’ÿest pas valide.)
LoadLibrary(D:\Liberkeys\MyApps\Pharo\SurfacePlugin.dll) (998: L’ÿaccèÿs àÿ cet emplacement de la méÿmoire n’ÿest pas valide.)
LoadLibrary(SurfacePlugin) (998: L’ÿaccèÿs àÿ cet emplacement de la méÿmoire n’ÿest pas valide.)
LoadLibrary(SurfacePlugin.dll) (998: L’ÿaccèÿs àÿ cet emplacement de la méÿmoire n’ÿest pas valide.)
LoadLibrary(D:\Liberkeys\MyApps\Pharo\SurfacePlugin) (998: L’ÿaccèÿs àÿ cet emplacement de la méÿmoire n’ÿest pas valide.)
LoadLibrary(D:\Liberkeys\MyApps\Pharo\SurfacePlugin.dll) (998: L’ÿaccèÿs àÿ cet emplacement de la méÿmoire n’ÿest pas valide.)
LoadLibrary(SurfacePlugin) (998: L’ÿaccèÿs àÿ cet emplacement de la méÿmoire n’ÿest pas valide.)
LoadLibrary(SurfacePlugin.dll) (998: L’ÿaccèÿs àÿ cet emplacement de la méÿmoire n’ÿest pas valide.)
LoadLibrary(D:\Liberkeys\MyApps\Pharo\SurfacePlugin) (998: L’ÿaccèÿs àÿ cet emplacement de la méÿmoire n’ÿest pas valide.)
LoadLibrary(D:\Liberkeys\MyApps\Pharo\SurfacePlugin.dll) (998: L’ÿaccèÿs àÿ cet emplacement de la méÿmoire n’ÿest pas valide.)

11:53 25/10/2020 - 13:07 25/10/2020
70. Chap. 6 - p.86 FR 125 EN - Variables globales - variable d'instance de classe Processor
p.86 FR 125 EN
"La variable Processor nomme une instance de ProcessScheduler, le principal ordonnanceur de processus de Pharo."
"The variable Processor names an instance of ProcessScheduler, the main process schedler of Pharo.

Processor class
>>> ProcessorScheduler"
Inspector on a ProcessorScheduler class (ProcessorScheduler)
a ProcessorScheduler class (ProcessorScheduler)

Processor
>>> Processor
Inspector on a ProcessorScheduler (Processor)
a ProcessorScheduler (Processor)

Je ne comprends pas la différence entre "Processor class" et "Processor" puisque "Processor" est une classe.
Alors, pourquoi lancer "Processor class" puisque cela concerne "Processor" et qu'il est possible de le lancer 
à partir de "Processor" ?
De plus, la commande "Processor class" est lancé alors pourquoi l'inspecteur ne met pas plutôt :
"a Processor class (ProcessorScheduler)" ou alors "ProcessorScheduler class (Processor class) 
au lieu de "a ProcessorScheduler class (ProcessorScheduler)" ?
Les commandes A et B ci-dessous ne sont pas cohérentes.

12:24 25/10/2020 (Supplément) - SystemDictionary stocke les variables partagées globales.
		A						B
Playground> SystemDictionary class > CTRL + I		Processor class
Inspector on a Metaclass (SystemDictionary class)	Inspector on a ProcessorScheduler class (ProcessorScheduler)
a Metaclass (SystemDictionary class)			a ProcessorScheduler class (ProcessorScheduler)

Playground> SystemDictionary> CTRL + I			Processor
Inspector on a SystemDictionary class (SystemDictionary)Inspector on a ProcessorScheduler (Processor)
a SystemDictionary class (SystemDictionary)		a ProcessorScheduler (Processor)

Dormir sur la tête !
Si une simple syntaxe peut tenir sur une carte postale.
Alors, faudrait-il penser à faire tenir toutes ces classes, méthodes, variables, protocoles, sous-classes, 
super-classes, etc. sur la face d'un timbre. fin 13:31 25/10/2020

debut video 70. 13:32 25/10/2020 - 13:33 25/10/2020

25/10/2020 - D11:11 - F13:36 - Chapitre 6 - p.86/259 FR 124/376 EN
-------------------------------------------------------------------------------------------------------25/10/2020 fin


-------------------------------------------------------------------------------------------------------28/10/2020 debut
28/10/2020 - D11:04 - F00:00 - Chapitre 6 - p.86/259 FR 124/376 EN
28/10/2020 - D11:04 - F14:04 - Chapitre 6 - p.86/259 FR 125/376 EN

p.86 FR 125 EN
Transcript (CTRL+O+T)>
Smalltalk globals at: #Smalltalk> Print it (CTRL+P)
>>> Smalltalk

(Test)
Smalltalk globals
>>> a SystemDictionary(lots of globals)

(Smalltalk globals at: #Smalltalk) == Smalltalk
>>> true

(Test)
Smalltalk globals, #Smalltalk
>>> a SystemDictionary(lots of globals)

(Test)
Smalltalk globals. #Smalltalk (fonctionne aussi avec le point au milieu ou deux points)
>>> #Smalltalk

(Test)
Smalltalk globals , Smalltalk
fenêtre "Instance of SmalltalkImage did not understrand"

12:36 28/10/2020
71. Chap. 6 - p.86 FR 125 EN - Playground-> code-> ouvre-> fenêtre
La fenêtre "Instance of SmalltalkImage did not understrand" s'ouvre lorsque le code est erroné.
Sous Windows les touches claviers ALT + F4 permet de fermer la fenêtre.
Or, sous Pharo ce n'est pas la fenêtre active qui se ferme, mais une fenêtre "Pharo Virtual Machine" qui s'ouvre
pour choisir de "Quit Pharo Virtual Machine without saving?" (Oui - NON).

Surprise :
Encore un cadeau surprise.
p.86 FR 125 EN
"Undeclared est un autre dictionnaire, qui contient toutes les variables non déclarées." 

Recherche dictionnaire ->
p. 54 FR
"Les identificateurs qui commencent par des lettres majuscules sont des variables globales , des
variables de classe, des dictionnaires de pool ou des noms de classe."
dictionnaires de pool ?? (Variables partagées de pool)
p.88 FR 128 EN
"Les variables de pool étaient initialement stockées dans des dictionnaires de pool."


					VARIABLES PARTAGEES
(1) Variables Partagées globales	(2) Variables partagées de classe	(3) Variables partagées de pool
 partage à l'échelle mondiale		  partages entre les instances		 partages entre un groupe de classes
					  et les classes

Notes : 
-------
Variables partagées de classe vs variables d'instance de classe.	

minuscule = variables d'instance de classe
majuscule = Variables partagées globales, Variables partagées de classe, Variables partagées de pool, noms de classe	


11:27 28/10/2020 - 14:04 28/10/2020
Mise à jour du Fichier "Ph_chap.6.png". (D:\Documents de user\Documents\INFORMATIQUE\PROGRAMMATION\Pharo)

28/10/2020 - D11:04 - F14:04 - Chapitre 6 - p.86/259 FR 125/376 EN
-------------------------------------------------------------------------------------------------------28/10/2020 fin


-------------------------------------------------------------------------------------------------------30/10/2020 debut
30/10/2020 - D10:11 - F00:00 - Chapitre 6 - p.86/259 FR 125/376 EN
30/10/2020 - D10:11 - F13:06 - Chapitre 6 - p.87/259 FR 125/376 EN

Word est une instance de PasteUpMorph qui représente l'écran.
World bounds représente un rectangle qui définit tout l'espace de l'écran.
World -> sous-morphes -> Morphs

ActiveHand est une instance de HandMorph qui représente le graphique du curseur.
ActiveHand -> sous-morphes -> tout ce qui est déplacé par la souris

p.86 FR 125 EN
"Undeclared est un autre dictionnaire, qui contient toutes les variables non déclarées." 

Ci-dessous "Undeclared" est apparue dans différentes situations.
C’est à y perdre son latin !

-------------------------------------Undeclared debut
p.45/259 FR 64/376 EN
undeclared -> initialize ?

p.46/259 FR 64/376 EN
-------------------------------------
Protocol	>	Method	    |
Method				    |
   \/			   \/	    |
-------------------------------------
undeclared	>	initialize  |
-------------------------------------

p.48/259 FR - 66/376 EN
"initialize" est toujours "undeclared" dans "LOGame".


Playground> Undeclared (avec ou sans .) le reste ne fonctionne pas : Undeclared new, Undeclared openInWorld.
Undeclared
>>> a Dictionary(#Clipboard->AnObsoleteClipboard
		 #MacOSClipboard->AnObsoleteMacOSClipboard
		 #UnixClipboard->AnObsoleteUnixClipboard
		 #anEllipse->nil #defaultColor->nil #initialize->nil
		 #morph->nil #undeclaredStubInstVar1->nil
		 #undeclaredStubInstVar2->nil)
-------------------------------------Undeclared fin

12:00 30/10/2020 - 12:31 30/10/2020 - 13:06 30/10/2020
Mise à jour du Fichier "Ph_chap.6.png". (D:\Documents de user\Documents\INFORMATIQUE\PROGRAMMATION\Pharo)

30/10/2020 - D10:11 - F13:06 - Chapitre 6 - p.87/259 FR 125/376 EN
-------------------------------------------------------------------------------------------------------30/10/2020 fin



-------------------------------------------------------------------------------------------------------01/11/2020 debut
01/11/2020 - D10:43 - F00:00 - Chapitre 6 - p.87/259 FR 125/376 EN
01/11/2020 - D10:43 - F13:42 - Chapitre 6 - p.87/259 FR 126/376 EN

p.87 FR 125 EN
"La pratique recommandée est de limiter strictement l'utilisation de variables globales."

Notes : 
-------
Variables partagées de classe vs variables d'instance de classe.	

minuscule = variables d'instance de classe
majuscule = Variables partagées globales, Variables partagées de classe, Variables partagées de pool, noms de classe	

p.87 FR 126 EN - Figure 6-27 Méthodes d'instance et de classe accédant à différentes variables
Playground> Color new> CTRL + P (openInWorld: non)
>>> Color black

72. Chap. 6 - p.87 FR 126 EN - Figure 6-27 Méthodes d'instance et de classe accédant à différentes variables
La Figure 6-27, affiche dans la case "Color class", superclass, subclass et methodDict, 
pourquoi ce n'est pas le cas dans "Color" ?

La Figure 6-27, affiche "name isBlack" et "initializeNames", introuvable dans les fenêtres de l'inspecteur ?
Color 	    -> name -> #Color.
Color class -> ?

La Figure 6-27, affiche "subclass" alors que l'inspecteur indique "subclasses" ?

La Figure 6-27, affiche dans la rubrique "Color" -> ColorNames", non présente dans l'inspecteur. 
C'est sans doute dû à une version différente du programme ?

Les quatre autres exemples ci-dessous, l'inspecteur montre une variable "name" et une "valeur" tandis que "Color" 
et "Color class" rien, pourquoi ?

Autre exemple :
---------------
Playground> BorderedMorph CTRL + I (inspect it)
	    SimpleSwitchMorph
	    (C)LOGame
	    (C)LOCell


Playground> Color> CTRL + I						Playground> Color class> CTRL + I
Inspector on a Color class (Color)					Inspector on a Metaclass (Color class)
a Color class (Color)							a Metaclass (Color class)
	\/									\/
----------------------------------------------------------------------------------------------------------------------------------------
	Color							|	Color class							|	
----------------------------------------------------------------------------------------------------------------------------------------|
	superclass Objet					|	superclass Objet class						|
	subclasses nil (subclass ?)				|	subclass ? (subclasses ?)							|
	methodDict a MethodDictionary [129 items] (size 129)	|	methodDict a MethodDictionary [88 items] (#aaFontsxxxxxxx)	|
----------------------------------------------------------------------------------------------------------------------------------------|
instanceVariableNames: 'rgb cachedDepth cachedBitPattern alpha' |									|
classVariableNames: 'BlueShift CachedColormaps ColorRegistry	|									|
ComponentMask ComponentMax GrayToIndexMap GreenShift 		|									|
HalfComponentMask IndexedColors MaskingMap RedShift'  \		|									|
package: 'Colors-Base'				       \	|									|
--------------------------------------------------------\-------------------------------------------------------------------------------
		name isBlack ?			         \	|		initializeNames ?					|
----------------/-----------\-----------------------------\--------------/----------------------\---------------------------------------
               /	     \				   \	     	/			 \
     ColorNames		      \				    \/	      \/		 ColorNames
			      rgb			     shared
							   ColorNames
			private				CachedColormaps			private
			  rgb								superclass
			cachedDepth							subclass

Vid : 72. - 13:07 01/11/2020
Vid : 73. - 13:39 01/11/2020

Notes : 
-------
Variables partagées de classe vs variables d'instance de classe.	

minuscule = variables d'instance de classe
majuscule = Variables partagées globales, Variables partagées de classe, Variables partagées de pool, noms de classe	

73. Chap. 6 - p.87 FR 126 EN - variables de classe vs variables de classe ?
Après plusieurs questions et rebondissements, j'ai perdu le fil et ce paragraphe n'est pas clair 
quant à savoir qui est quoi.
Est-ce que c'est la "variable de classe" ou la "variable de classe" ? MDR

Je reformule.
Est-ce que c'est la "variable d'instance de classe" ou la "Variable partagée de classe" ?

De plus, la figure 6-27 n'indique pas que "CachedColormaps" ou "ColorRegistry" soient partagés à part le "V" 
majuscule, mais alors dans ce cas, "instanceVariableNames" et "classVariableNames" sont partagés.

Majuscule = Variables partagées globales, Variables partagées de classe, Variables partagées de pool, 
noms de classe.	

C’est à y perdre son latin !
Dans quoi me suis-je embarqué ?

Playground> Color> CTRL + I						Playground> Color class> CTRL + I
Inspector on a Color class (Color)					Inspector on a Metaclass (Color class)
a Color class (Color)							a Metaclass (Color class)
	\/									\/
----------------------------------------------------------------------------------------------------------------------------------------
	Color							|	Color class							|
----------------------------------------------------------------------------------------------------------------------------------------|
	superclass Objet					|	superclass Objet class						|
	subclasses nil (subclass ?)				|	subclass ? (subclasses ?)					|
	methodDict a MethodDictionary [129 items] (size 129)	|	methodDict a MethodDictionary [88 items] (#aaFontsxxxxxxx)	|
----------------------------------------------------------------------------------------------------------------------------------------|
instanceVariableNames: 'rgb cachedDepth cachedBitPattern alpha' |									|
classVariableNames: 'BlueShift CachedColormaps ColorRegistry	|									|
ComponentMask ComponentMax GrayToIndexMap GreenShift 		|									|
HalfComponentMask IndexedColors MaskingMap RedShift'  \		|									|
package: 'Colors-Base'				       \	|									|
--------------------------------------------------------\-------------------------------------------------------------------------------

01/11/2020 - D10:43 - F13:42 - Chapitre 6 - p.87/259 FR 126/376 EN
-------------------------------------------------------------------------------------------------------01/11/2020 fin



-------------------------------------------------------------------------------------------------------02/11/2020 debut
02/11/2020 - D10:41 - F00:00 - Chapitre 6 - p.87/259 FR 126/376 EN
02/11/2020 - D10:41 - F13:59 - Chapitre 6 - p.88/259 FR 127/376 EN

p.87 FR 126 EN
"super-classe,  sous-classe, methodDict sont des variables d'instance de classe"
"accessibles uniquement à la "Color classe" idem pour "Color" ? Oui.

	Color class - Inspector on a Metaclass (Color class)
	-----------
	Variable			Value
variables d'instance de classe		
	superclass 			Object class	
	methodDict			a MethodDictionary [88 items] (#aaFontsColormapDepth->xxx
	subclasses			?

	Color - Inspector on a Color class (Color)
	------
	Variable			Value
variables d'instance de classe		
	superclass 			Object	
	methodDict			a MethodDictionary [129 items] (size 129) //crochets items trop long à faire au clavier.
	subclasses			nil

"CachedColormaps" et "ColorRegistry" sont des variables partagées de classe définies pour "Color".
classVariableNames: CachedColormaps ColorRegistry

"toutes les instances de "Color" peuvent accéder à ces variables partagées de classe, 
mais également à la classe "Color" et à l'une de ses sous-classes (subclasses)".

p.87
"Les méthodes d'instance et les méthodes de classe peuvent accéder à ces variables partagées."

Recherche : méthodes d'instance

p.77 FR 111 EN
"Cette méthode vérifie d'abord si uniqueInstance a été initialisée. Si ce n'est pas le cas, 
la méthode crée une instance et l'affecte à la variable d'instance de classe uniqueInstance."

11:57 02/11/2020
74. Chap. 6 - p.87 FR 126 EN - variables d'instance de classe vs variables partagées de classe ?
"Une variable de classe est déclarée dans le modèle de définition de classe. 
Par exemple, la classe Color définit un grand nombre de variables de classe pour accélérer la création de couleur"
Je pourrais dire qu'il s'agit d'une "variable d'instance de classe" sans être absolument sure.
Cela semble évident pour vous, mais le lecteur est perdu et doit faire un effort considérable pour décrypter les différentes interactions. 
À savoir s'il s'agit d'une variable de classe d'instance ou partagée ? 
On est loin d'une simple syntaxe qui peut tenir sur une carte postale.

Listing 6-28 Color and its class variables
Sur la figure 6-28, il s'agit du package "Graphics-Primitives" alors que sur le programme Pharo 8.0.0 
c'est "Colors-Base".
Dans Pharo à "classVariableNames:", il manque "RandomStream".

Listing 6-29
Color class >> initialize ? ne fonctionne pas
12:54 02/11/2020
Recherche :  >> 
p.123 EN
Object >> DoesNotUnderstand

13:01 02/11/2020
75. Chap. 6 - p.87 FR 126 EN - Listing 6-29
J'ai fait planter Pharo (Peut-être qu'il cherche ?) avec la commande "Color class initialize".
Puisque celle proposée sur le livret ne fonctionne pas.
"Color class >> initialize"

13:15 02/11/2020
75. Chap. 6 - p.87 FR 126 EN - Listing 6-29
J'ai fait planter Pharo (Peut-être qu'il cherche ?) avec la commande "Color class initialize".
Puisque celle proposée sur le livret ne fonctionne pas.
"Color class >> initialize"
Bingo x2. lol
x3. MDR


À retenir :
-----------

appeler la méthode initialize

D13:36 02/11/2020 - F13:54 02/11/2020
76. Chap. 6 - p.88 FR 127 EN - Class initialization
"La présence de variables de classe pose la question: comment les initialiser?"
"The presence of class variables raises the question: how do we initialize them?"
Il existe deux solutions et en plus il faut se rappeler d'appeler la méthode initialize .....
C'est la folie ce truc.(Le concept du programme Pharo)
Pourquoi se "triturer" autant le cerveau ? 
Il faut être pragmatique au lieu de faire tout ce Micmac.
Si une simple syntaxe peut tenir sur une carte postale.
Alors, il y a du travail à faire pour toutes ces classes, méthodes, variables, et autres 
afin qu'ils tiennent sur la face d'un timbre.

D11:24 02/11/2020 - F11:51 02/11/2020
Mise à jour du Fichier "Ph_chap.6.png". (D:\Documents de user\Documents\INFORMATIQUE\PROGRAMMATION\Pharo)

A ajouter à la prochaine capture.
Il faut se concentrer sur le concept "Pharo" et la syntaxe du code est à l'état de poussière à ce stade de lecture. 

02/11/2020 - D10:41 - F13:59 - Chapitre 6 - p.88/259 FR 127/376 EN
-------------------------------------------------------------------------------------------------------02/11/2020 fin


-------------------------------------------------------------------------------------------------------03/11/2020 debut
03/11/2020 - D11:39 - F13:47 - Chapitre 6 - p.88/259 FR 127/376 EN
03/11/2020 - D11:39 - F13:47 - Chapitre 6 - p.89/259 FR 129/376 EN

p.88 FR 127 EN
"La présence de variables de classe pose la question: comment les initialiser?"
La question ne devrait même pas se poser.

Les variables partagées de pool doivent être définis comme des variables de classe de classes dédiées (sous-classe de SharedPool).

Rechercher : playground
#Text			> Printit > #Text
Collections-Text	> Printit > Unknown variable: Core please correct, or cancel:
string runs		> Printit > #string is missing, and does not understand #runs
TextConstants		> Printit > "TextConstants"
Text-Core-Base		> Printit > Unknown variable: Core please correct, or cancel:

p.88 FR 128 EN
Le package "Collections-Text" n'existe pas.
Celui qui s'en rapproche est "Text-Core-Base".

F12:47 03/11/2020 - 12:58 03/11/2020
77. Chap. 6 - p.88 FR 128 EN Collections-Text
Le package "Collections-Text" n'existe pas.
Celui qui s'en rapproche est "Text-Core-Base", mais lors de mes recherches c'est "Text-Core" 
qui apparaît dans la liste de package.
Lorsque j'effectue une recherche "Filter", aucun package ne porte le nom de "Text-Core-Base".
Ce qui est troublant, c'est de lire le nom du package "Text-Core-Base" depuis la classe "TextConstants" alors 
que depuis "All Packages", il s'agit de "Text-Core".
Ensuite, il ne s'agit pas de "pool dictionary TextConstants", mais de "SharedPool".
La constante "LF" n'existe pas dans la liste.
Où est écrit l'exemple de la méthode ? (suivante = Qui vient après, qui suit.)

Note : 
Il faut se concentrer sur le concept "Pharo" et la syntaxe du code est à l'état de poussière à ce stade de lecture. 
:-(

A ajouter à la prochaine capture.
Il faut se concentrer sur le concept "Pharo" et la syntaxe du code est à l'état de poussière à ce stade de lecture. 

p.88 FR 128 EN
"les personnes qui souhaitent vraiment approfondir la façon dont Pharo représente les objets en interne."
Moi qui croyais que c'était déjà fait ! 
Quand il y en a plus, il y en a encore des surprises.

----------------------------------------------------------------------------------------------------------------------------------------
								Implemantation							     	|
----------------------------------------------------------------------------------------------------------------------------------------
	Objet (1) ordinaire					    |	Objet (2)								|
	# 0 champs						    |	# immédiats							|
	référence						    |	passés par valeur						|
	0 ou 							    |	entiers = SmallInteger = objets Character			|
	plusieurs variables d'instance (Vd'I)			    |	sous-plage de nombres à virgule flottante 64 bits SmallFloat64	|
	Ex: Objet-> Point (Vd'I)-> x et y			    |									|
					 /->référence autre objet   |	 		 /->bits codent la valeur de l'immédiat		|
	(Vd'I) contient pointeur d'objet-			    |	pointeur d'objet-						|
					 \->immédiat autre objet    |	 		 \->bits codent la classe de l'objet		|
	Objets indexables - tableaux = accessible par des messages  |									|
	(Vd'I Indexée) contient un pointeur d'objet 		    |									|
			\/					    |									|
	peut-être une référence à un autre objet ordinaire	    |									|
			ou					    |									|
			immédiat				    |									|
-----------------------------------------------------------------------------------------------------------------------------------------

p.89 FR 129 EN
---------------------------------------------------------------------------------------------------------	
						Objets							|
---------------------------------------------------------------------------------------------------------
		Closure 			  |			Context				|
--------------------------------------------------|------------------------------------------------------
(Vd'I) nommés -> suit -> (Vd'I) indexées	  |	(Vd'I) nommés -> suit -> (Vd'I) indexées	|
---------------------------------------------------------------------------------------------------------

p.89 FR 129 EN - 13:47 03/11/2020
----------------------------------------------------------------	
				Objets				|
----------------------------------------------------------------
		ByteString 	  |		Bitmap		|
----------------------------------------------------------------|
	(Vd'I) indexées numérotées de 1 à N	  		|
			données brutes				|	
	occupation 8, 16, 32 bits selon classe    		|	
	accessible : entiers, caractères, décimale		|	
		méthodes at: et at:put:			  	|	
			conversion			  	|		
			/	\			  	|	
		       /	 \	      			|	 
	   objets pharo		  données brutes	  	|	
   		représentation interne = masquée	  	|	
		système -> données -> chaines -> bitmaps  	|	
-----------------------------------------------------------------

03/11/2020 - D11:39 - F13:47 - Chapitre 6 - p.89/259 FR 129/376 EN
-------------------------------------------------------------------------------------------------------03/11/2020 fin



-------------------------------------------------------------------------------------------------------04/11/2020 debut
04/11/2020 - D10:29 - F11:44 - Chapitre 6 - p.89/259 FR 129/376 EN
04/11/2020 - D10:29 - F11:44 - Chapitre 7 - p.91/259 FR 132/376 EN
10:32 04/11/2020 arret 11:46 04/11/2020

p.89 FR 129 EN
"Le modèle objet de Pharo est à la fois simple et uniforme."
"simple", mon point de vue est tout autre.
Le résumé du chapitre torture également l'esprit, une toile d'araignée est plus cohérente.

12:00 04/11/2020

Chap.7 Quelques outils clés de l'environnement pharo
"Pharo a un excellent débogueur, "
L'excellent décodeur ne sert à rien face à "Color class initialize" CTRL + I.

"Il existe un outil qui vous permet de regarder, et même de modifier, des objets vivants: l' inspecteur."

p.90 FR 131 EN
"L'outil Finder vous permettra de trouver des méthodes, des classes, des pragmas, etc."

Recherche : pragmas
p.81 FR 
"Les primitives  (et les pragmas / annotations) ne sont pas des messages envoyés. 
Ils sont implémentés dans la machine virtuelle."
p.60 FR
"Dans Pharo, la syntaxe des crochets angulaires est également utilisée pour les annotations de méthode
appelées pragmas."
pragmas = annotations de méthode

p.54 FR
"Primitifs. <primitive: ...> dénote une invocation d'une primitive de machine virtuelle. Par exemple,  <primitive: 1>  est la
primitive VM pour  SmallInteger . Tout code suivant la primitive est exécuté uniquement si la primitive échoue. La même syntaxe
est également utilisée pour les annotations de méthode (prag-mas)."

11:53 04/11/2020
Mise à jour du Fichier "Ph_chap.6.png". (D:\Documents de user\Documents\INFORMATIQUE\PROGRAMMATION\Pharo)

04/11/2020 - D10:29 - F11:44 - Chapitre 7 - p.91/259 FR 132/376 EN
-------------------------------------------------------------------------------------------------------04/11/2020 fin


-------------------------------------------------------------------------------------------------------05/11/2020 debut
05/11/2020 - D09:27 - F00:00 - Chapitre 7 - p.91/259 FR 132/376 EN
05/11/2020 - D09:27 - F13:21 - Chapitre 7 - p.94/259 FR 136/376 EN

F- 11:40 05/11/2020
78. Chap.7 - p.91 FR 133 EN - Themes and icon sets
Le paragraphe "Thems and icon sets" que fait-il dans le chapitre 7 ?
Est-ce que c'est un objet qui n'a pas reçu le bon message ?

Non seulement un enfant de CP pourrait changer l'apparence du programme, mais en plus les rubriques 
"A quick tour of Pharo, 2.5 The world menu - settings, 2.7, 2.9", sont sans doute plus appropriées. 
Le sommaire du chapitre 7 indique "de présenter les principaux outils de l'environnement de programmation Pharo",
une "session de débogage" et "modifier des objets vivants".
Dans la mesure où le lecteur a lu les chapitres précédents sur la présentation des outils, 
le débogage et de l'inspecteur.
Ainsi que la création du jeu "LightsOut", ce qui a permis d'utiliser plusieurs outils.

De plus, en lisant ce paragraphe, il induit plus en erreur qu'il ne permet de trouver rapidement 
la "section apparence".
Puisqu'il faut 'trouver' "Settings Browser" dans le "menu World" (World> System> Settings). 
Je ne savais pas qu'il fallait prévoir une boussole et une carte, mais effectivement c'est presque le cas.
Le mot "Settings" est introuvable dans "System" contrairement à "Browser" : System Browser, Process Browser.
Les touches de raccourci clavier ont été omises dans ce paragraphe. (CTRL + O + S)
Simple : Pharo> Settings ou Meno World> Pharo> Settings
Ce cas est typique de la représentation du livret ainsi que du programme Pharo c'est-à-dire un navire en perdition
dont le phare éclaire des zones tortueuses.
Il s'agit ici de tourner en rond comme le ferait le chat qui se mord la queue.
"Pragmatique : Qui se fonde sur l’action, les résultats concrets et l’efficacité."

F 12:12 05/11/2020
79. Chap.7 - p.92 FR 133 EN - The main code browser
Cette histoire c'est quoi ? Le retour dans le futur !
C'est reparti pour un tour quant à la présentation des différentes rubriques de Pharo.
J'hallucine.[Par extension] Qui a l’air égaré, bizarre.
Vous vous êtes dit "qu'il faut mettre du contenu" 
et "répéter celui-ci" pour avoir un document d'au moins 376 pages ?
D'ailleurs, c'est le cas, concernant les répétitivités.
Quelle perte de temps !
Le bateau coule et le Phare flanche.

D12:55 05/11/2020 - F13:21
80. Chap.7 - p.94 FR 136 EN - The main code browser - class-> Globally shared variables
p.94 FR 136 EN
"La création d'une classe crée également une variable globale qui fait référence à la classe"

C'est ce qui s'appel une contradiction.
"Prouver une proposition par l’absurde consiste à montrer que sa négation conduit à une contradiction."

p.87 FR 125 EN
"La pratique recommandée est de limiter strictement l'utilisation de variables globales."
Tu sais qu'à chaque fois qu'une classe est créée, s'associe une variable globale, 
mais tu dois limiter "strictement" son utilisation.
Ce qui veut dire que si tu n'en utilises jamais (variable globale), alors tu vas perdre du temps 
à faire quelque chose pour cette variable.

p.86 FR 125 EN
"si Pharo était implémenté à partir de zéro aujourd'hui, la plupart des variables globales 
qui ne sont pas des classes seraient remplacées par des singletons."
La plupart des variables partagées globales ne sont pas des classes certes, 
mais lors de la création d'une classe celle-ci (VPG) y fait référence.

minuscule = variables d'instance de classe
majuscule = Variables partagées globales, Variables partagées de classe, Variables partagées de pool, noms de classe

13:17 05/11/2020
Mise à jour du Fichier "Ph_chap.6.png". (D:\Documents de user\Documents\INFORMATIQUE\PROGRAMMATION\Pharo)

05/11/2020 - D09:27 - F13:21 - Chapitre 7 - p.94/259 FR 136/376 EN
-------------------------------------------------------------------------------------------------------05/11/2020 fin


-------------------------------------------------------------------------------------------------------06/11/2020 debut
06/11/2020 - D11:06 - F0000 - Chapitre 7 - p.94/259 FR 136/376 EN
06/11/2020 - D11:06 - F13:51 - Chapitre 7 - p.95/259 FR 138/376 EN

cmd-b (Mac) - alt+b (Win)
11:45 06/11/2020
Les raccourcis claviers "CTRL" ne fonctionne pas à coup sûr.
Il arrive que Monticello s'ouvre, mais pas Repositories vice-versa.

Les touches claviers de direction ne peuvent pas déplacer le carré bleu sur Yes vers No et vice-versa.
CTRL + U = Spotter search (Fenêtre : Question "MessageTally the UI process one cycle - Yes No)
CTRL + P = Monticello Browser
CTRL + I = Repositories

WIN + U = Spotter search (Fenêtre : Question "MessageTally the UI process one cycle - Yes No)
WIN + M = Réductions de toutes les fenêtres
WIN + D = Réductions de toutes les fenêtres
WIN + , = Affiche le bureau

ATL + T = Transcript ([Spotter] Exception in filter <GTFilterSubstring>: Prim....
ATL + K = Playground
ATL + B = System Browser

Shift + Enter = Spotter search

p.95 FR 138 EN - Code search
Raccourcies claviers disponible clique droit sur la fenêtre : Playground
Playground> clic droit> Code search
Playground> Morph (sélectionner Morph)> CTRL + B (ouvre System Browser - Browse full class)
					CTRL + N (ouvre Senders of Morph
					CTRL + M (ouvre System Browser - Implementors)

p. 96 FR 138 EN
Exemples : 
System Browser
--------------------
Playground(ALT+K)> tape Morph> sélectionne Morph (CTRL+A)> 
				Browser system (CTRL+M)> 
		Protocol recherche et clic sur Drawing>
		Methode recherche et clic sur drawOn:>
		Clic droit puis Senders (CTRL+N)>
		fenêtre "Senders of drawOn: [53]>
		dans la fenêtre "Senders", Recherche "Canvas" - "draw:" - "Graphics-Canvas" 

Monticello Browser
-----------------------
Playground(ALT+K)> tape Morph> sélectionne Morph (CTRL+A)> 
				Monticello Browser (CTRL+O+P)> 
		Tu ne peux pas aller plus loin sans connaître la package contrairement à "System Browser"
qui affiche le package, les classes, les protocoles et les méthodes. 


12:55 06/11/2020 F12:59 06/11/2020 - vid 13:38 06/11/2020
81. Chap.7 - p.94 FR 137 EN - System Browser Morph>>drawOn:
Il n'y a pas de cohérence entre la fenêtre "System Browser" et "Senders of drawOn:".
En effet, dans plusieurs rubriques du livre est indiqué depuis "System Browser" 
1 package, 2 class, 3 protocol, 4 method

Donc, pourquoi dans la fenêtre "Senders" cette classification n'est pas respectée ? 
1 class, 2 method, 3 package

vid 13:41 06/11/2020
82. Chap.7 - p.94 FR 137 EN - Monticello Browser Morph>>drawOn:
Lorsque le raccourcie clavier "Monticello Browser" est exécuté sur la fenêtre "Playground"> Morph,
celui-ci n'affiche pas le package, class, protocol ou method contrairement à "System Browser".

NOTE IMPORTANTE : 13:33 06/11/2020
-----------------
Par hasard, j'ai trouvé le "--all--" indiqué lors de l'exercice "LightsOut".

vid 13:46 06/11/2020
83. Chap.7 - p.95 FR 138 EN - Figure 7-7 Monticello Browser 
Par hasard, j'ai trouvé le "--all--" indiqué lors de l'exercice "LightsOut".
(Rappel -> 45. Chap. 3 - Une première application - 3.8 Terminer le jeu - Figure 3-20)
Il s'agissait de passer par le "Monticello Browser"> cliquer sur "Browse".
Du coup, si le document avait été plus clair je n'aurais pas perdu mon temps à chercher.

06/11/2020 - D11:06 - F13:51 - Chapitre 7 - p.95/259 FR 138/376 EN
-------------------------------------------------------------------------------------------------------06/11/2020 fin



-------------------------------------------------------------------------------------------------------07/11/2020 debut
07/11/2020 - D08:39 - F0000 - Chapitre 7 - p.95/259 FR 138/376 EN
07/11/2020 - D08:39 - F13:37 - Chapitre 7 - p.97/259 FR 141/376 EN

System Browser
----------------
Clic droit sur la méthode "drawOn:"

Browse 			CTRL+B
Find method		CTRL+F
Implementors		CTRL+M
Senders			CTRL+N
Jump to test method	CTRL+H+j
Rename			CTRL+R
Remove			CTRL+X

Monticello Browser
------------------
1. Connaître le package
Clic droit sur la méthode "drawOn:"

Note :
------
Rien n'est indiqué quant à la touche clavier principale.
Il faut appuyer sur les touches claviers ATL + [lettre]
Exemple : ALT + b

Browse full		(b)
Browse hierarchy	(h)
FileOut			(o)
Copy selector		(c)
Browse senders		(n)
Browse implementors	(m)
Inheritance		(i)
Versions		(v)

Notes : 
------
p.139 EN figure 7-8, la capture correspond à la fenêtre "Monticello Browser"
package> Morphic-Core-Kernel, class> Morph, protocol> drawing, method> drawOn:
Clic droit sur "drawOn:"> Version (v) -> ATL+v

Monticello Browser
Le nom de la fenêtre ne s'appelle pas "Senders" mais "Recent versions of"
La fenêtre "Senders" sur la figure affiche une liste de package alors que sur "Recent" qu'une ligne apparaît.
Le bouton "Version" (figure) a été remplacé par "Revert".

F11:13 07/11/2020 Vid11:32 07/11/2020
84. Chap.7 - p. 96 FR 140 EN - classe Dictionary
Le lecteur ne sait plus sur quel pied danser.
Donc sur le livret, il s'agit de Pharo version 5.0, certaines "Figures" affichent "Monticello Browser"
tandis que les autres c'est "System Browser" et enfin "--all--" a été trouvé. 
All de la série Télé ? Non, celui qui est rattaché à "Monticello Browser" et que j'ai cherché dans "System Browser".

p. 95 FR 139 EN - Figure 7-8 Browser ?
Le nom de la fenêtre ne s'appelle pas "Senders" mais "Recent versions of".
Sur la "Figure", la fenêtre "Senders" affiche une liste de package alors que sur "Recent" une ligne apparaît.
Le bouton "Version" a été remplacé par "Revert".
Qui suis-je ?

Basculer dans "Browser", OK, lequel ?
Dans ces conditions, il faut manipuler l'un et l'autre des "Browsers".
Sous "Monticello Browser", je n'ai pas trouvé l'option "Find class..."; 
de plus, il faut indiquer le nom d'un package pour connaître la liste des classes contrairement à "System Browser".
Conclusion, il faut utiliser "System Browser" comme indiqué au début du livret, 
mais certaines fois c'est l'incompréhension et le doute.

Autres points. 
Sous "System Browser", dans le volet "classe", il n'est pas possible de "Rechercher une classe" 
et la "Figure 7-9" est avant le paragraphe "Basculer vers la classe Dictionary" 
que je croyais rattaché à "Canvas>>draw:".
Sous Pharo les objets sont manipulés aidés par les "Figures" qui sont plus parlantes que le texte et son déroulement (texte)
qui apparaît plus tard.
Ipso facto, le contenu de ce livret est désordonné.

expand item = développer élément
unexpand item = renvelopper élément

C'est quoi ?
Recherche : mais 
Relatif au maoïsme.
Qui professe le maoïsme, qui est adepte du maoïsme.
Mais au final, je ne sais pas ce que c'est que le "maoisme".
Associer cette recherche avec l'utilisation de pharo et/ou le contenu du document pharo by example.

Fcréation12:26 07/11/2020 - Vid12:45 07/11/2020
85. Chap.7 - p. 96 FR 140 EN - classe Dictionary
Lorsque la classe "Dictionary" s'affiche, celle-ci est associée au package "Collections-Unordered-Dictionaries".
Dans le volet "Package" apparaît en surbrillance "Dictionaries" qui est rattaché au package "Collections-Unordered".
Étonnement ! 
Quand "Collections-Unordered-Dictionaries" est inscrit dans la fenêtre "Filter..." du volet "Package", 
celui-ci est introuvable.
Donc, il y a un package principale qui possède des sous-packages qui ne peuvent pas être trouvés ?
	Collections-Unordered
		|-> Collections-Unordered-Bags
		|-> Collections-Unordered-Dictionaries
		|-> Collections-Unordered-Exceptions
		|-> Collections-Unordered-Manifest	-> (C) ManifestCollectionsUnordered
		|-> Collections-Unordered-Sets		-> [] Set, []  IdentitySet, []  PluggableSet
		|-> Collections-Unordered-Utilities

Pour le reste, "xxx-Manifest" possède une classe "(C) ManifestCollectionsUnordered" symbolisée par "(C)", mais
"xxx-Sets" possède également des classes "Set, IdentitySet, PluggableSet", mais avec des symboles différents 
d'une classe et "IdentitySet, PluggableSet" est différent de "Set" par l'espacement.

D'un autre côté, en mettant en surbrillance "Collections-Unordered", le volet classe affiche 
l'ensemble des contenues des sous-packages.
Dans le volet classe, l'on pourrait croire que les éléments collés aux symboles seraient le début 
et ceux espacés la fin d'une liste correspondant à un package.
Or, ce n'est pas le cas, car le package "Collections-Unordered-Dictionaries" contient la classe 
"SmallIdentityDictinary" qui se situe en avant-dernière position dans le volet classe.

Chap.7 - p. 96 FR 140 EN - at: key put: value message
Après avoir sélectionné "self at: key put: value]]." et lancé "Senders" (CTRL + N), 
celui-ci affiche [1701] résultats.
Autrement dit une liste de 1701 expéditeurs.

code -> selection -> senders 	->  voir tous les expéditeurs du message at: key put: value
code -> selection -> implementors ->  répertorie toutes les classes qui mettent en œuvre une méthode avec le même sélecteur.

Note : 
-----
Pour ouvrir "Spotter" le raccourcie "Shift + Entré" est préférable sinon une fenêtre s'affiche (yes, no).

ALT + K 	-> Playground 
CTRL + M 	-> System Browser 
CTRL + O + P	-> Montecillo Browser
Shift + Entré 	-> Spotter

13:37 07/11/2020 à lire
Method inhéritance and overriding

07/11/2020 - D08:39 - F13:37 - Chapitre 7 - p.97/259 FR 141/376 EN
-------------------------------------------------------------------------------------------------------07/11/2020 fin


-------------------------------------------------------------------------------------------------------08/11/2020 debut
08/11/2020 - D10:53 - F0000 - Chapitre 7 - p.97/259 FR 141/376 EN
08/11/2020 - D10:53 - F15:03 - Chapitre 7 - p.98/259 FR 143/376 EN

10:54 08/11/2020
Method inhéritance and overriding
"sélectionnez la  méthode "ImageMorph >> drawOn:"

Playground> ImageMorph> surbrillance ImageMorph> CTRL + M> 
Fenêtre "ImageMorph>>drawOn:"	
-----------------------------------------------------------
	Package		   |	Class |	Protocol | Method |
Morphic-Base		   |	      |		 |	  |
 	\|		   |	      |		 |	  |
	 Morphic-Base-Basic> ImageMorph> drawing> drawOn: |
-----------------------------------------------------------

Volet méthode> drawOn:> Inheritance> CTRL + H

11:51 08/11/2020 - F12:56 08/11/2020 - Vid13:11 08/11/2020
86. Chap.7 - p. 97 FR 141 EN - Montecillo - Inheritance
Monticello Browser n'affiche pas "ImageMorph>>drawOn:", pourquoi ? 
Parce qu'il faut cliquer sur le bouton "instance" situé avant "?" et "class".

System Browser et le raccourci clavier "Inheritance"(CTRL + H) sur la méthode "drawOn:" ne fonctionne pas.

Pourquoi lorsque je lance "Inheritance", le nom de la fenêtre est-il "Implementors" au lieu de "Inheritance" ?
Sous "Monticello" c'est bien une fenêtre "System Browser" "Inheritance of drawOn:[5]" qui s'affiche.

Encore une fois on embrouille le lecteur dans le paragraphe "Hierarchy view" entre la "Figure 7-10" et l'utilisation 
de "System Browser" et "Monticello Browser".
Dans "System Browser" il n'y a aucun mot "Hierarchy" et il s'agit d'un rond à cocher situé sous le volet classe
et à côté du mot "Hier.", mais en aucun cas d'un bouton.
(J'ai compris la subtilité "Hierarchy" et "Hier." lorsque j'ai lu, les raccourcies claviers de Monticello)

Vue> "Monticello"> ImageMorph> 	Browse full (b)		-> Ouvre System Browser -> ImageMorph>>drawOn:
				Browse hierarchy (h)	-> Ouvre System Browser -> ImageMorph>>drawOn:
				Show hierarchy		-> Ouvre System Browser -> Inheritance of drawOn:[5]
				Load class ImageMorph

Le volet packages n'est pas grisé lorsque le rond est coché de « Hier. » sans doute dû à la version 8 de Pharo.


À retenir :
-----------

triangle bleu haut
triangle bleu bas
flèche bleu haut
flèche bleu bas
Icônes fléchées à côté du nom de la méthode.
La flèche bleu (triangle bleu) pointant vers le haut indique que "ImageMorph>>drawOn:" remplace une méthode héritée,
(c'est à dire "Morhp>>drawOn:")
La flèche pointant vers la bas indique qu'elle est remplacée par les sous-classes.

14:45 08/11/2020 - Vid14:58 08/11/2020 F15:03 08/11/2020
87. Chap.7 - p. 98 FR 143 EN - Class # Superclass
"la vue hiérarchique révèle que la superclasse directe de "ImageMorph" est "Morph"."
Visuellement, ce n'est pas flagrant que "Morph" est la superclasse directe de "ImageMorph" depuis le volet classe.
A contrario, "Morph" et "ImageMorph" sont des classes sans symbole "C".
Également catégorisé dans "subclass" et "superclass".
Donc, la majorité des classes située dans le volet classe ont un symbole "non class" (contradictoire), mais 
sont "espacés" pour indiquer plus ou moins une hiérarchie. :-)
J'ai dû zapper quelques choses, car je me pose une question.
À savoir quel est l'intérêt, d'avoir un volet classe contenant des objets qui sont "subclass" et "superclass" ?
D'autre part et de mon point de vue, "Morph" n'est pas un "Object" simplement une classe affichée dans un volet classe.

Pharo 8 affiche deux classes distinctes "ProtoObject" et "Object", qui n'apparaissent pas dans la "Figure 7-11". 
(Rappel : p.85 FR 123 EN - ("jusqu'à Object (ou plutôt ProtoObject)) ("the way up to Object (or rather ProtoObject)).
Comme quoi les choses évoluent.


Rappel : 
--------
p. 37 FR 51 EN - classe - sous-classe
Créer une nouvelle classe
Remplacer "Object" 	par 	"SimpleSwitchMorhp" 	<- Classe existante
Remplacer "NameOfSubClass" par	"LOCell"		<- Création d'une sous-classe
Message-> 			"SimpleSwitchMorph"	<- #LOCell
Compilation-> 			"#LOCell"		<- Classe créée

Lors de la compilation, l'argument "#" sera ajouté à "LOCell", représentant le nom de la classe à créer 
et un message sera envoyé à "SimpleSwitchMorhp", criant une classe "LOCell".

p. 98 FR 142 EN
Finding variable references
"en sélectionnant  Analyser> Inst var références ... ou  Analyser> Class var refs"
"Analyze > Class refs"
Aucun "Analyser", c'est seulement "Class refs." (CTRL + N).
("Analyze > Class refs")

08/11/2020 - D10:53 - F15:03 - Chapitre 7 - p.98/259 FR 143/376 EN
-------------------------------------------------------------------------------------------------------08/11/2020 fin



-------------------------------------------------------------------------------------------------------09/11/2020 debut
09/11/2020 - D10:17 - F0000 - Chapitre 7 - p.98/259 FR 143/376 EN
09/11/2020 - D10:17 - F14:02 - Chapitre 7 - p.98/259 FR 143/376 EN

Utilisation d'une variable d'instance ou de classe. (Imprécis)
Clique droit classe "ImageMorph"> Class refs.> 

p. 98 FR 142 EN
Le paragraphe "Finding variable references"
Rien ne correspond, c'est un gros fiasco. La situation est pire qu'avant.

10:55 09/11/2020 - vid11:08 09/11/2020
88. Chap.7 - p. 98 FR 142 EN - Finding variables references
Dans ce chapitre, entre l'explication, la figure 7-12 et le résultat rien ne correspond. 
1. "Analyse" inexistant depuis le volet classe, mais "Class refs." disponible.
("Analyze > Class refs")
2. "Class refs." aucune visibilité, quant à savoir s'il s'agit de l'utilisation d'une variable d'instance ou classe.
3. Aucun bouton "Variable" au-dessus de la liste des packages.
4. Aucune variable "bounds".
5. La figure 7-12 située après les paragraphes "Bytecode source" et "Refactoring" aurait dû être encore plus loin. 
Le chat qui se mord la queue ! 

12:31 09/11/2020
89. Chap.7 - p. 98 FR 142 EN - Finding vs Bytecode
Les raccourcis sont oubliés dans certains paragraphes ou mis deux fois dans d'autres alors que cela pourrait éviter 
au lecteur de chercher quelque chose qui n'existe plus. (Bytecode - CMD-b CMD-b)

Par exemple : 
Analyze, Inst var references, Inst var assignments n'existe pas.

Ces paramètres doivent surement être ceux figurant sur le bandeau situé sous les volets.
(package, class, protocol, method)
"Class refs." existe par l'intermédiaire du raccourcie (CTRL + N) et d'un lien "Class refs." situé sur le bandeau.

Dans le paragraphe "Bytecode source", aucun raccourci n'affiche ce qui est présenté à la figure 7-13.
Donc, au fur et à mesure je comprends qu'il s'agit d'un mix entre "System Browser" et "Monticello Browser" comme
représenté sur la Figure 2-15 de la page 36. Cela ne m'a pas choqué au commencement du livret.

"System Browser" 	-> ImageMorph>>drawOn:			-> Flat Hier. Traits | Inst. side Class side|
"Monticello Browser" 	-> Snapshot Browser: Morphic-Base	-> instance ? class

Encore un cadeau-surprise dont je me passerais bien. (Perte de temps)

12:41 09/11/2020
p. 98 FR 145 EN - Source de bytecode - Bytecode source
Utiliser "System Browser", car sous "Monticello Browser" ça ne fonctionne pas.
Mettre en surbrillance la méthode "drawOn:",
Clique droit, "Extra"> "Inspect" ou CTRL + I,
Fenêtre "Inspector on a CompiledMethod (ImageMorph>>#drawOn:),
Onglet "Bytecode".

13:15 09/11/2020 - Modifs 13:35 09/11/2020 - Modifs 13:54 09/11/2020
90. Chap.7 - p. 98 FR 143 EN - Refactoring
"Refactoring - Figure 7-14", j'imagine que du haut du "Phare" c'est plus facile à voir.
Début page 143.....page 144......page 145...ouf enfin.
La souris s'amuse à faire tourner la roue et moi, c'est la roulette de la souris. :-(

"Le refactoring n'était auparavant disponible que dans un navigateur spécial appelé navigateur de refactoring, 
mais il est désormais accessible depuis n'importe quel navigateur."
Faux, indisponible dans "Monticello Browser". 


Trop de navigateurs font perdre la boule, n'est-ce pas ?
Trop de navigateurs tuent le navigateur. ;-(
"System Browser" se nomme en coulisse "ClyFullBrowser".
Et Monticello ?
Monticello en arrière-fond c'est "MCWorkingCopyBrowser".  Ébahissé-je ! HOooooooo.
Puis Snapshot Browser ?
"MCSnapshotBrowser", Mister Mac leod ! 
Aie, caramba ! Trop de noms ! non ? 
Non, pas du tout. C'est fun. Mdr ! 
Mettez un lapin dans un terrier, il s'y retrouve puis mettez-le dans le phare Pharo, c'est peine perdue.
Le chat a des identités masqué : MOlusquelelapin, BILeperroquet, ALLextraterreste.

09/11/2020 - D10:17 - F14:02 - Chapitre 7 - p.98/259 FR 143/376 EN
-------------------------------------------------------------------------------------------------------09/11/2020 fin



-------------------------------------------------------------------------------------------------------10/11/2020 debut
10/11/2020 - D13:11 - F00:00 - Chapitre 7 - p.98/259 FR 143/376 EN
10/11/2020 - D13:11 - F16:14 - Chapitre 7 - p.98/259 FR 143-144/376 EN

13:23 10/11/2020 F14:35 10/11/2020 Modifs15:22 10/11/2020 Modifs16:03 10/11/2020
91. Chap.7 - p. 98 FR 142-144 EN - Finding variable references vs Figure 7-12.
Avant le paragraphe "Finding variable references", le lecteur travaille avec la classe "ImageMorph".
Puis un intermède dans le paragraphe "Finding vxxx", pour exécuter les options "class refs.", "Inst. side", "Vars".
Sauf le bouton "Variables" qui est rattaché à une ancienne version de Pharo. (+ un mix)

Ensuite, le liseur est invité à cliquer sur une "variable" par exemple "bounds" (Figure 7-12).
Avant de faire une bêtise, vérifions la figure 7-12 !

Alors la "Figure 7-12" pourrait-elle m'en apprendre un peu plus sur la manière de trouver cette variable ?
Sauf que je ne m'attarde pas à lire l'intitulé, mais à regarder le numéro de la figure.

La figure montre deux fenêtres, la première indique sur le bandeau "ImageMorph" et en surbrillance le package "Basic",
puis la classe "ImageMorph". Jusque-là c'est cohérent.
La seconde, le bandeau indique "Accesses to bounds [48], dessous une liste de lignes, en dessous des boutons 
et enfin un code avec "bounds" sélectionné.
Impossible d'afficher cette fenêtre sauf s'il s'agit de la classe "Morph" au lieu de "ImageMorph". 
Alors s'amorce un long processus de décryptage mis en place pour le lecteur biaisé par le paragraphe "Findingxx" 
et la figure 7-12.
Dans le paragraphe "Finding", à aucun moment il n’est fait mention de "Morph".

Exemple capture : variable bounds

C'est seulement en fin de phrase situé sous une capture qu'il y a un indice.
De plus, en travaillant avec la méthode "drawOn:" et le code "bounds" on peut afficher le navigateur de messages 
sans passer par la classe "Morph".
La fenêtre "References to bounds [155]" affiche exactement le même nombre et liste d'items.
Au final, pourquoi faire compliqué ?

D'autre part, en se référant à la "Figure 7-12" le "Browser" est plus représenté par celle de "Monticello Browser".
Donc, la question est de savoir comment la fenêtre "Accesses to bounds" est apparue.
Puisque :
1. Aucune classe "Morph" n'est disponible dans la liste du volet classe de Monticello,
2. Aucun mot "bounds" n'est identifiable après avoir sélectionné "Basic" et "ImageMorph".
3. C'est totalement incohérent.

10/11/2020 - D13:11 - F16:14 - Chapitre 7 - p.98/259 FR 143-144/376 EN
-------------------------------------------------------------------------------------------------------10/11/2020 fin



-------------------------------------------------------------------------------------------------------11/11/2020 debut
11/11/2020 - D10:57 - F: - Chapitre 7 - p.98/259 FR 143-144/376 EN
11/11/2020 - D10:57 - F14:18 - Chapitre 7 - p.99/259 FR 144/376 EN

10:59 11/11/2020
Rappel : 
--------
Bytecode
Bytecode source
Utiliser "System Browser", car sous "Monticello Browser" ça ne fonctionne pas.
Mettre en surbrillance la méthode "drawOn:",
Clique droit, "Extra"> "Inspect" ou CTRL + I,
Fenêtre "Inspector on a CompiledMethod (ImageMorph>>#drawOn:),
Onglet "Bytecode".

10:59 11/11/2020 - vid11:20 11/11/2020 modifs11:37 11/11/2020
92. Chap.7 - p. 98 FR 143 EN - Refactoring
"Cliquez simplement avec le bouton droit dans l'un des quatre volets pour voir 
les opérations de refactorisation actuellement disponibles."
J'essaye avec "System Browser" puis "Monticello".

Je complète l'intervention avec la Figure 7-14 qui se trouve à perpète les alouettes.

Après quoi "System Browser", l'option est disponible avec le clic droit depuis les volets "Class" et "Method".
Alors que "Monticello Browser - MCWorkingCopyBrowser" et "Snapshot Browser - MCSnapshotBrowser",
n'affichent aucune vue sur "Refactoring". 
Donc, il s'agit de deux volets dans "System Browser" au lieu de quatre dans "Monticello" heu ! MCWorkingCopyBrowser :-) (((((

Note : 
------
p.99 FR 144 EN
Dans chaque volets l'option "File out" est disponible mais sont contenus est différents.
	Volet package -> File out -> classe l'ensemble du package 
	Volet class -> File out -> classe l'ensemble de la classe
	Volet protocol -> File out -> le protocol entier
	Volet method -> File out -> sort la méthode affichée

13:00 11/11/2020
93. Chap.7 - p. 98 FR 143 EN - File out
"Refactoring" ne fait-il pas partie du "Browser menus" comme "File out" ? (Extra-> File out)
L'option "File out" est disponible sur la Figure 7-14.

Dans les volets du "Monticello Browser and co-> Snapshot Browser and co" l'option "Extra-> File out" ou 
"File out" est absente.
Depuis "System Browser and co -> ClyFullBrowser, et le volet "package" de "Extra-> File out" exporte "Basic.st", 
et affiche seulement le contenu du package "Basic" avec les classes, les protocoles (méthodes) 
et les méthodes (protocoles).
Ensuite, le volet "class" de "Extra-> File out" exporte le fichier "ImageMorph.st" sans souligner les autres classes,
mais mentionne les protocoles et les méthodes.
Alors, le volet "protocol" de "Extra-> File out" n'exporte rien, mais attire l'attention sur une fenêtre intitulée 
"Instance of WriteStream did not understand #trailer".
Après, le volet "method" de "Extra-> File out" exporte le fichier "ImageMorph-drawOn.st"et attire l'attention 
sur le code de la méthode "drawOn:" cela équivaut à ce qui est affiché dans l'onglet de la méthode "drawOn:".

Maintenant, la question est de savoir quel est l'intérêt de ces exportations.
Qu'est-ce qui se passe si j'ajoute ou j'enlève des lignes dans ces différents fichiers ou lorsque j'importe
un fichier dans une version différente de Pharo ?

13:07 11/11/2020 - vid14:08 11/11/2020
94. Chap.7 - p. 99 FR 144 EN - Browser menus -> Find class
"L'élément de menu le plus utile est probablement Find class...(f, c) dans les volets du package ou de la classe." 
Sous "Monticello Browser" and co "Snapshot Browser" l'option est inexistante et les raccourcies claviers
CTRL + F, CTRL + C ou ALT + F, ALT + C ne fonctionne pas.

Depuis "System Browser and co -> ClyFullBrowser, et le volet "package" alors "Find class" n'est disponible
que lors de la sélection du package principale par exemple "Morph-Base", 
mais pas les secondaires comme par exemple "package: 'Morphic-Base-Basic' pourtant rattaché à un package. (?) 

De plus, "Find class" apparaît seulement dans le "package principal", mais pas dans celui de la classe.

Le raccourcie "CTRL + F" pour rechercher une classe fonctionne depuis les volets package, classe et protocole.
Tandis que le volet "method", "CTRL + F" affiche une fenêtre de recherche de "method". 

Note : 
------
Depuis quelques chapitre le copier/coller de Pharo ne fonctionne plus. (?)
"#Clipboard is missing, and does not understand #clipboardText:"
p.91 FR 
"Le  Test Runner vous permet d'exécuter et de déboguer", c'est quand tu en as besoin qu'il est introuvable ce truc.
En comptant celui-ci, c'est le troisième bogue. (bogue, erreur informatique, bug) 
Simplement en suivant le livret "Pharo by example".


Je fais quoi ? 

J'appelle les pompiers (non, ne marche pas); on coule, on coule (ça, non plus), Pizza (Oui, extra fun). ;-)

11/11/2020 - D10:57 - F14:18 - Chapitre 7 - p.99/259 FR 144/376 EN
-------------------------------------------------------------------------------------------------------11/11/2020 fin




-------------------------------------------------------------------------------------------------------12/11/2020 debut
12/11/2020 - D11:03 - F00:00 - Chapitre 7 - p.99/259 FR 144/376 EN
12/11/2020 - D11:03 - F14:22 - Chapitre 7 - p.100/259 FR 146/376 EN

11:19 12/11/2020 - vid11:32 12/11/2020
95. Chap.7 - p.99 FR 145 EN - Navigation history
"Le menu déroulant History Navigator, situé au-dessus des volets de protocole et de méthode, 
peut également vous aider à revenir rapidement à une classe ou une méthode que vous avez parcourue récemment, 
même si vous avez oublié son nom."
Le menu déroulant "history navigator" situé au-dessus des volets protocole et méthode 
sous "Monticello-> Snapshot", n'existe pas.
Tandis que sous "ClyFullBrowser-> System Browser", "history navigator" n'est pas un menu déroulant, 
mais plutôt des flèches vertes situées en dessous du volet "method".

11:43 12/11/2020 - vid12:34 12/11/2020
96. Chap.7 - p.99 FR 145 EN - Test Runner 
[Rappel 94.
Note : Depuis quelques chapitre le copier/coller de Pharo ne fonctionne plus. (?)
"#Clipboard is missing, and does not understand #clipboardText:"
p.91 FR 
"Le  Test Runner vous permet d'exécuter et de déboguer", c'est quand tu en as besoin qu'il est introuvable ce truc.
En comptant celui-ci, c'est le troisième bogue. (bogue, erreur informatique, bug) 
Simplement en suivant le livret "Pharo by example".]

"Test Runner" est disponible depuis le bouton "Tools" ou "CTRL + O + U), dommage qu'il ne soit pas disponible depuis
le code ou la fenêtre en cours de bogue.
Quoi qu'il en soit, j'ai lancé "Test Runner" au pifomètre qui a gelé quelques secondes le programme Pharo.
Une fenêtre "Not Covered Code (28% Code Coverage) [1530] s'est affichée ainsi que plein d'autres fenêtres furtives.
Est-ce que le problème de copier/coller a été résolu ? Hum, ensuite ?
"Glamorous Browser" ?? Il sort d'où celui-là ?
Bon à suivre.

Note : 
-----
"Glamorous Browser"-> GLMCompositePresentation (about) ???
Est apparue lors du "Test Runner".

12:34 12/11/2020 -reprise12:50 12/11/2020 - vid12:59 12/11/2020erreur page - vid13:21 12/11/2020 - 
modifs13:31 12/11/2020 - vid13:38 12/11/2020
97. Chap.7 - p.100 FR 146 EN - Find method (CMD-f-> Mac, CTRL + F-> Win)
"Une autre méthode utile dans le volet de classe est la "méthode Find" ( CMD-f CMD-m )"
Depuis le volet classe "Find method", n'existe pas dans "Snapshot Browser" et "System Browser".
Mais, elle est disponible dans le volet "method" de "System Browser" (CTRL + F).
Par contre, les fenêtres qui s'ouvrent s'intitulent "Choose xxx" au lieu de "Find xxx", 
et ne sont pas identiques à l'intitulé disponible dans les menus. ("Find class", "Find method")

Note :
-----
"Find classe" p.96 FR 140 EN - "Find method" p. 100 FR 146 EN
Même eux s'y perdent à cause des options décalées ou un coup sur deux disponible.
Ou alors, des options inexistantes dans le menu comme c'est le cas dans le volet classe-> "Find class" ou "Find method".
Encore une fois "Situation confuse, embrouillée. Quel micmac !"

14:07 12/11/2020 - vid14:12 12/11/2020
98. Chap.7 - p.100 FR 146 EN - searching for a particular method
"il est souvent plus rapide de parcourir le protocole --all-- , de placer la souris dans le volet des méthodes
et de saisir la première lettre du nom de la méthode que vous êtes en train de chercher."
1. Le nom de la méthode recherché s'affiche en surbrillance "gris",
2. Si la méthode est en seconde position, la touche clavier "flèche bas", fait retourner en haut de la liste,
3. La méthode trouvée est en seconde position, alors là validée par un clic de souris ou la touche "Entrée", 
4. La méthode se trouve en 20 positions utiliser la roulette de la souris plus tôt que la touche clavier "flèche bas",
5. Concerne le browser "Monticello-> Snapshot Browser".
6. C'est mieux "System Browser".

14:23 12/11/2020
Note :
------
"Pour faire Essayez les deux façons de naviguer vers  OrderedCollection >> removeAt:"
Playground n'autocomplète pas la méthode "removeAt:" contrairement à "drawOn:", mais seulement après les deux points.
Par contre, l'autocomplète fonctionne bien sur une classe.
(faire une video)

12/11/2020 - D11:03 - F14:22 - Chapitre 7 - p.100/259 FR 146/376 EN
-------------------------------------------------------------------------------------------------------12/11/2020 fin



-------------------------------------------------------------------------------------------------------13/11/2020 debut
13/11/2020 - D11:50 - F00:00 - Chapitre 7 - p.100/259 FR 146/376 EN
13/11/2020 - D11:50 - F14:03 - Chapitre 7 - p.100/259 FR 146/376 EN

11:52 13/11/2020
99. Chap.7 - p.100 FR 146 EN - Playground auto-complet 
Playground n'autocomplète pas la méthode "removeAt:" contrairement à "drawOn:", mais seulement après les deux points.

Note : 
------
C'est maintenant que je m'aperçois que le raccourcie clavier "CTRL + M" n'est pas attribué à "System Browser" 
mais à "Implementors".
Sauf, lorsqu'une classe est sélectionné "System Browser" s'ouvre. ??????

vid13:28 13/11/2020
99. Chap.7 - p.100 FR 146 EN - Playground auto-complete 
"quicker to browse the --all-- protocol,"
"To do Try both ways of navigating to OrderedCollection>>removeAt:"

Je commence avec "Snapshot Browser", la suite de "Monticello" qui utilise "--all-- protocol".
1. Que ce soit avec "Tools> Monticello" ou par "Playground> code> Monticello", ils n'affichent aucun résultat.

2. Tandis qu'avec "Tools> System Browser" et rechercher "removeAt:", c'est simple et rapide.
3. Ensuite avec "Playground", il y a plusieurs possibilités et certaines sont incohérentes.
	3.1 Playground> OrderedCollection>>removeAt:> CTRL + M affiche "Implementors" au lieu de "System Browser",
	3.2 Playground> OrderedCollection>>removeAt:> CTRL + B affiche "Variable or expression expected->",
	3.3 Playground> OrderedCollection> CTRL + M affiche "System Browser" au lieu de "Implementors",
	3.4 Playground> OrderedCollection> CTRL + B affiche correctement "System Browser",
	3.5 Playground> Ord...> propose l'autocomplétion,
	3.6 Playground> rem...> ne suggère pas l'autocomplétion même après les deux points,
	3.7 Playground> drawOn:> conseille l'autocomplétion seulement après les ":",
	3.8 Playground> removeAt: ou drawOn: > CTRL + B affiche "Variable or expression expected->",
	3.9 Playground> removeAt: ou drawOn:> CTRL + M affiche "Implementors".

13:31 13/11/2020
Browsing programmatically

"Ouvrez une aire de jeux et évaluez le code suivant pour parcourir les expéditeurs de drawOn:."
Playground> SystemNavigation par défaut BrowseAllSendersOf: #drawOn:

Playground> Senders 	->  voir tous les expéditeurs du message drawOn:

Note : 
------
Presque tous les raccourcis ouvrent "Senders" mais n'affichent pas la même chose.

Playground> SystemNavigation par défaut BrowseAllSendersOf: #drawOn: - CTRL + G -> Do it and go -> Senders of drawOn: [52] + second fenêtre playground a ClyOldMessageBrowserAdapter
Playground> SystemNavigation par défaut BrowseAllSendersOf: #drawOn: - CTRL + D -> Do it -> Senders of drawOn: [52]
Playground> SystemNavigation par défaut BrowseAllSendersOf: #drawOn: - CTRL + P -> Print it -> Senders of drawOn: [52]
Playground> SystemNavigation par défaut BrowseAllSendersOf: #drawOn: - CTRL + I -> Inspector on a ClyOldMessageBrowserAdapter + Senders of drawOn: [52]
Playground> SystemNavigation par défaut BrowseAllSendersOf: #drawOn: - CTRL + Shift + I -> Senders of drawOn: [52] + Warning "The method SpAbstractListPresenter>>#menu: xxxxx
Playground> SystemNavigation par défaut BrowseAllSendersOf: #drawOn: - CTRL + Shift + D -> Debug it
Playground> SystemNavigation par défaut BrowseAllSendersOf: #drawOn: - Aucune -> Profile it + Senders of drawOn: [52]
Playground> SystemNavigation par défaut BrowseAllSendersOf: #drawOn: - CTRL + B -> System Browser-> ClyOldMessageBrowserAdapter + Senders of drawOn: [52]

Playground> SystemNavigation par défaut BrowseAllSendersOf: #drawOn: - CTRL + N -> Senders of BrowseAllSendersOf: [11]

13/11/2020 - D11:50 - F14:03 - Chapitre 7 - p.100/259 FR 146/376 EN
-------------------------------------------------------------------------------------------------------13/11/2020 fin



-------------------------------------------------------------------------------------------------------14/11/2020 debut
14/11/2020 - D08:59 - F00:00 - Chapitre 7 - p.100/259 FR 146/376 EN
14/11/2020 - D08:59 - F14:14 - Chapitre 7 - p.103/259 FR 151/376 EN
- 17 mns pause


À retenir :
-----------

La flèche bleu (triangle bleu) pointant vers le haut indique que "ImageMorph>>drawOn:" remplace une méthode héritée,
(c'est à dire "drawOn:" hérite de Morph, "Morhp>>drawOn:")
	1 Morph -> 2 ImageMorph -> 3 drawOn:
La flèche bleu pointant vers la bas indique qu'elle est remplacée par les sous-classes.

09:30 14/11/2020 -vidF10:56 14/11/2020
100. Chap.7 - p.100 FR 146 EN - Navigation par programmation
Je ne comprends pas l'intérêt de la navigation par programmation !
Le premier code fonctionne "SystemNavigation default browseAllSendersOf: #drawOn:".
À ce moment-là, j'évalue le code et parcours les expéditeurs. Et après ? (évaluer !)

Le second code, ci-dessous, pour restreindre la recherche d'expéditeurs ne fonctionne pas. 
"SystemNavigation default browseAllSendersOf: #drawOn: localTo:ImageMorph" ou
"SystemNavigation default browseAllSendersOf: #drawOn: localTo: ImageMorph".

Je suis "hébété" par la suite.
"Les outils de développement étant des objets", 
"accessible depuis les programmes",
"vous pouvez développer vos propres outils ou adapter les outils existants à vos besoins.",
OK ! Tout est "objets", l'écran, le fil électrique, la Terre c'est bon.

De quel programme parle-t-on ?
Je peux développer mes outils, comment les développer ? Ce paragraphe c’est quoi ? 
On te balance trois lignes de code dont l'une ne fonctionne pas. 
Alors, "j'évalue" et je fais du saut de parcours, super !

L'équivalent programmatique de "Implementors" est peut-être plus intéressant.
SystemNavigation default browseAllImplementorsOf: #drawOn:

J'adore la fin du paragraphe.
"À faire Pour en savoir plus sur ce qui est disponible, explorez la classe System-Navigation avec le navigateur."
À savoir, dès le début du paragraphe j'ai consulté la classe "System-Navigation", donc je n'ai pas attendu la fin 
de cette partie puisque précédemment c'était l'exploration de " OrderedCollection >> removeAt:".
À ce stade, je ne vois plus l'intérêt de savoir ce qui est disponible parce que je ne sais pas quoi en faire 
de ces choses.
Même en lisant les commentaires des quatre classes, "super fun" des descriptions, 
mais concrètement qu'est-ce que c'est la suite ? 
C'est la même chose lorsque je suis enfoncé au fond du canapé à lire un bouquin. 
Il a été lu, il est fini, c'est l'heure de la balade.

10:58 14/11/2020
7.3 L'inspecteur
L'inspecteur a déjà été vu précédemment, peut-être allons-nous avancer.
Malheureusement non ! 

Note : 
------
À part un changement de date, le code reste statique. 

11:38 14/11/2020
101. Chap.7 - p.101 FR 147 EN -  world of live vs world of static code
"L'une des choses qui rend Pharo si différent de beaucoup d'autres environnements de programmation 
est qu'il vous offre une fenêtre sur un monde d'objets vivants, pas un monde de code statique."

Il me semblait que c'était "Playground" qui proposait un environnement "d'objets vivants".
À la page 147 de "pharo by example" les objets ont été et sont toujours statiques.
Quand est-ce que l'on rentre dans le vif du sujet et dans "un monde d'objets vivants" ?

Le paragraphe "7.3 L'inpecteur", n'est qu'illusion d'objets.
À part un changement de date, le code reste statique. Alors, le monde d'objets vivants est où ?	

L'inspecteur a déjà été vu précédemment "LightsOut".
Alors les objets vivants ???????????
Ce n'est qu'une fenêtre statique avec du code tout aussi statique.
Mouais ! vivants = world of static code

Note :
------
12:00 14/11/2020
Sauvegarde de Pharo avec l'erreur du copier/coller, dossier "Pharo_old" (liberkeys) et création du raccourcie sur le bureau "Pharo_OLD".
Attention, lors du 1er lancement de "pharo_old" celui-ci a ouvert le nouveau Pharo ? 
Changement de répertoire en allant chercher l'exécutable dans le dossier "Pharo_old".


11:39 14/11/2020 - 12:41 14/11/2020 modif13:51 14/11/2020 vid14:03 14/11/2020
102. Chap.7 - p.102 FR 149 EN - 7.4 Le débogueur
Le débogueur a déjà été vu précédemment, peut-être allons-nous avancer.
Si c'est comme l'inspecteur alors c'est peine perdue.

"À l'aide du navigateur, ajoutez la méthode suivante à la classe String"


1. Je vais chercher la classe "String" en utilisant "Find class" comme indiqué dans le paragraphe précédent 
"Browser menus - items is Find class in the package or class panes". (p. 99 FR 144 EN)

Tools> System Browser (CTRL + O + B)> Volet Package> Find class (CTRL + F)> String -----|/ 
=================== Ne trouve rien, l'objet est vivant. MDR ! ===================<----<-|/

2. Playground (CTRL + K)> String> System Browser (CTRL + M ou CTRL + B) "+M, seulement pour une classe."

3. Pharo demande "Author identification" -> FirstnameLastname. 
(C'est une nouvelle version de Pharo puisque je ne pouvais plus copier/coller)
Pour FirstnameLastname mettre LObjetVivantcoule

4. Pourquoi "Listing 7-16 A buggy method" indique une méthode "buggy" alors qu'il s'agit de "suffix" ?

5. Représentation suffix.
	Package		Class 		Protocol		method
Collections-Strings	String		accessing-properties	suffix
	\|-> Base

6. Fenêtre débogage "NotFound".
Le résultat est inattendu puisque les boutons "Proceed, Abandon, Debug et Report" ne sont pas disponibles.
L'objet "PreDebugWindow pops up" s’est fait la malle ? (malle = partir sans prévenir.)
Playground> 'readme.txt' suffix et Print it (CTRL + P)
"NotFound: [:i |(self at:i)=dot] not found in Interval

7. Fenêtre débogage "NotFound", impossible de cliquer sur "Debug".
", we need the debugger itself, so click on Debug." (p. 103 FR 150 EN)
Ce n'est pas grave étape 8.

8. "selected the detect:ifFound:IfNone:"
À suivre...

14/11/2020 - D08:59 - F14:14 - Chapitre 7 - p.103/259 FR 151/376 EN
-------------------------------------------------------------------------------------------------------14/11/2020 fin

3

-------------------------------------------------------------------------------------------------------15/11/2020 debut
15/11/2020 - D12:23 - F00:00 - Chapitre 7 - p.103/259 FR 151/376 EN
15/11/2020 - D12:23 - F14:07 - Chapitre 7 - p.104/259 FR 151/376 EN

p.102 FR 149 EN
Playground>  'readme.txt' suffix (.txt, *.txt, .dot, *.dot ne fonctionne pas)

12:50 15/11/2020
103. Chap.7 - p.102 FR 149 EN - 7.4 Le debogeur - dot
J'ai évalué le code et l'extension "dot" enfin il me semble que c'est rattaché à une extension.
Donc, en prenant en compte que "dot" est une extension et qu'il est souvent énuméré dans le code,
avec Playground j'ai essayé les mots suivants : 'readme.dot' suffixe, '.dot', '*.dot', '.txt', '*.txt'
, mais c'est toujours la même erreur.
Alors, le code de l'exercice est "dot := '.'.", que j'ai modifié en "dot := '.dot'.", 
mais j'ai remis le code par défaut et après l'enregistrement le message "Error" est apparu.
C'est bizarre, parce que j'ai remis par défaut sans avoir lancé quoi que ce soit.
:?)

La réponse doit être "txt" ? (Alors le code est incompréhensible),
Debug montre une trace de pile des messages qui ont conduit à l'erreur,

"UndefinedObjet>>DoIt -> représente le code qui a été compilé et exécuté (CTRL+P),
"Suffix" -> message -> object -> ByteString ('readme.txt')-> Pourquoi entre parenthèse après bytestring ?,
(M)Suffix -> execution -> héritage -> (C)String -> 
				\|/
 ----------------------------------------------------------------------
(Toutes ces infos sont encodées à la ligne "ByteString(String)>>suffix")

Questions : 
----------
Alors pourquoi lorsque "ByteString(String)>>suffix" est sélectionné, 
dans la "Source", le code suivant est mis en surbrillance "detect: [ :i | (self at: i) = dot ]." ?

Suite de la trace de la pile.....
(M)Suffix -> envoie -> detect:
		-> envoie -> detect:ifNone -> envoie -> errorNotFound:

Pourquoi "dot" n'a pas été trouvé ?
Pourquoi la valeur de la variable "self", a un intervalle de 1 à 10 au lieu de 0 à 9 ? (Onglet "Variables")

[suffix
"assumes that I'm a file name, and answers my suffix, the part
after the last dot"
| dot dotPosition |
dot := '.'.									
dotPosition := (self size to: 1 by: -1) //variable "self" valeur "an Interval [10 items] (10 9 8 7 6 5 4 3 2 1) - Evaluator "(10 to: 1 by: -1)" self
					//self size = start 10, stop 1, step -1 ? 10 ?
detect: [ :i | (self at:i) = dot ].
^ self copyFrom: dotPosition to: self size]

Variables-> ? je ne sais plus le chemin
10   9   8   7   6   5  4  3   2   1 
58 110 114 101 116 116 97 80 111 110 decimal 
$:  $n  $r  $e  $t  $t $a $P  $o  $n

La liste des variables a jusqu'à quatre types de variables qu'elle affiche.
* parameter	tout paramètre transmis à cette méthode. 
* temp		tous les temporaires utilisés dans cette méthode. 
* attribute	toute variable d'instance accessible depuis le contexte du récepteur actuel.
* implicit 	pseudo variables (self, thisContext, stackTop) utilisées dans le contexte courant.   

p. 104 FR 151 EN
Variables-> 
	Type		Variable	Value
	implicit  	thisContext	Interval(Collection)>>detect:ifFound:ifNone:

15/11/2020 - D12:23 - F14:07 - Chapitre 7 - p.104/259 FR 151/376 EN
-------------------------------------------------------------------------------------------------------15/11/2020 fin

3

-------------------------------------------------------------------------------------------------------16/11/2020 debut
16/11/2020 - D09:29 - F: - Chapitre 7 - p.104/259 FR 151/376 EN
16/11/2020 - D09:29 - F13:23 - Chapitre 7 - p.106/259 FR 154/376 EN

09:57 16/11/2020 - vid10:55 16/11/2020
104. Chap.7 - p.104 FR 151 EN - Le débogueur - '.' in the string 'readme.txt'
"As we can see one method lower in the stack trace, the exceptionBlock is [self errorNotFound: ...],"
"nous pouvons voir une méthode plus bas dans la trace de la pile, l'exceptionBlock est [self errorNotFound: ...],"

*******	PILE ************************************************** PILE ******************* 
----------------------------------------------------------------------------------------
Stack											|
----------------------------------------------------------------------------------------  
Interval(Collection)	detect:ifFound:IfNone:		 			<method	| cadre de pile
											|
											|
----------------------------------------------------------------------------------------|
Source											|
----------------------------------------------------------------------------------------|
detect: aBlock ifFound: foundBlock ifNone: exceptionBlock				|
	"Evaluate aBlock with each of the receiver's elements as the argument.  	|
	If some element evaluates aBlock to true, then cull this element into 		|
	self										| cadre de pile
		do: [ :each | 								|
			(aBlock value: each)						|
				ifTrue: [ ^ foundBlock cull: each ] ].			|
	^ exceptionBlock value								|
----------------------------------------------------------------------------------------|
Variables										|
----------------------------------------------------------------------------------------|
Type		Variable	Value							|
----------------------------------------------------------------------------------------|
parameter	exceptionBlock	[self errorNotFound: aBloclk]			<method	| cadre de pile
											|
implicit  	thisContext	Interval(Collection)>>detect:ifFound:ifNone:		|
											|
											|
-----------------------------------------------------------------------------------------

"En regardant en arrière à la fenêtre de la méthode, nous voyons que nous nous attendions 
à ce que l'avant-dernière ligne de la méthode
trouve '.' dans la chaîne 'readme.txt', et cette exécution n'aurait jamais dû atteindre la ligne finale."
"Looking back at the method window, we see that we expected the penultimate line of the method to 
find '.' in the string 'readme.txt', and that execution should never have reached the final line."

À la lecture de ce paragraphe, je suis perdu pour trouver '.' dans la chaîne 'readme.txt'.
"En regardant en arrière à la fenêtre de la méthode" ? C'est où ?
En cliquant sur chaque triangle, c'est interminable.
Chercher une aiguille dans une botte de foin.
Ça traîne en longueur cette histoire.

Notes : p.104 FR 151 EN
-------

Restart		Le focus de l'exécution revient à la première instruction de la méthode actuelle.
Into		Exécute l'envoi du message en cours (dans le cas présent "do:") en une seule étape, sauf erreur.
Over		Amène au prochain message envoyé dans la méthode actuelle (dans le cas présent "value"), au commencement et pas beaucoup d'aide.

11:08 16/11/2020 - vid11:38 16/11/2020
105.  Chap.7 - p. 104 FR 152 EN - Le débogueur - dot vs . vs readme.txt
Playground> 'readme.txt' suffix-> Print it (CTRL + P)

Interval(Collection) detect:ifFound:ifNone:

1 Restart 2 Over 3 Restart - Figure 7-19
Interval(Collection - detect:iFound:ifNone: , Source-> [:each xxxxxxx each ]],
Variables-> implicit - thisContext - [Interval|Collection|>>detecxxxx)

Ça ne change pas grand-chose et c'est d'une efficacité redoutable.(Ironique)
Ce n'est pas fini. MDR ! 
4 Into x2 (Stack-> Interval - do:, Source-> index :=0, Variables-> implicit - thisContext - Interval>>do:)
5 Through x2 (Stack-> Interval(Collection - detect:iFound:ifNone: - [:each xxxxxxx], Source-> value: each,
Variables-> implicit - thisContext - [:each xxxxxxx])
6 Into (Stack-> ByteString(String) - suffix - [:ixxxxx), Source-> at:i, Variables-> implicit - self - 'readme.txt')
Non, je ne vois pas pourquoi ils ne sont pas égaux, ce n'est pas flagrant.
Character -> dot et Character $. ce n'est pas flagrant pour ainsi dire incompréhensible.
String "readme.txt" et String "." c'est pareil. pas flagrant
Rien ne me prouve "pourquoi ils ne sont pas égaux:" 
:-)
dot	= chaîne
.	= caractère

[suffix
"assumes that I'm a file name, and answers my suffix, the part
after the last dot"
| dot dotPosition |
dot := '.'.				//dot = chaine, '.' = caractère									
dotPosition := (self size to: 1 by: -1) //variable "self" valeur "an Interval [10 items] (10 9 8 7 6 5 4 3 2 1) - Evaluator "(10 to: 1 by: -1)" self
					//self size = start 10, stop 1, step -1 ? 10 ?
detect: [ :i | (self at:i) = dot ].
^ self copyFrom: dotPosition to: self size]

12:24 16/11/2020
106. Chap.7 - p. 104 FR 152 EN - Le débogueur -  dot :=$.
"Change the code right in the debugger so that the assignment reads dot :=$. and accept the change."
"Modifiez le code directement dans le débogueur afin que l'affectation lise dot: = $. et acceptez le changement."
1. La moitié du code passe à la ligne suivante, c'est malin. 
Alors c'est quoi le code ?
	Document 1 EN (Copier/Coller)->  EN =  dot :=$.  
	Document 2 FR (Copier/Coller)->  FR =  dot: = $.

		 dot: = $.
		 dot :=
$.	

2. Modifier le code directement dans le débogueur, mais c'est où ? String, Items, Evaluator ???
(Ça m'agace de décrypter ce document, c'est une perte de temps.
Ce qui vous semble facile, évident, indéniable ne l'est pas pour les autres.)
Galère !

Note : 13:08 16/11/2020
------
Remettre par defaut (Stack-> ByteSting(String) - suffix, Source-> dot := '.'. 

12:47 16/11/2020
"Change the code right in the debugger so that the assignment reads dot :=$. and accept the change."
"Modifiez le code directement dans le débogueur afin que l'affectation lise dot: = $. et acceptez le changement."
Ça y est, j'ai décrypté le document et j'ai trouvé l'endroit où a lieu la modification.

Étant donné que "at: i" est mis en surbrillance, c'est la raison pour laquelle cela me semblait judicieux 
de modifier "dot" depuis la rubrique "Variables" -> temp-> dot->.

Mais, c'est lorsque j'ai comparé les Figures 7-21 et 7-22 que j'ai compris la manière de modifier "dot". 
(Relu surtout)

Donc, les codes qui ont été "Copier/Coller", aucun ne correspond à la "marque" indiquée sur la Figure 7-22.

	Document 1 EN (Copier/Coller)->  EN =  dot :=$.  
	Document 2 FR (Copier/Coller)->  FR =  dot: = $.
	
	 dot :=$.
	 dot: = $. 
	 dot := $..
nil !  mais c'est où ? String, Items, Evaluator ??? Aucun lol
tout ça pour ça ! :-(

Note : 
------
Alors que le débogueur aurait pu mettre un message similaire : 
"WARNING = 'dot'= chaîne and '.'= caractère, modified your '.' and '$.'".

16/11/2020 - D09:29 - F13:23 - Chapitre 7 - p.106/259 FR 154/376 EN
-------------------------------------------------------------------------------------------------------16/11/2020 fin


-------------------------------------------------------------------------------------------------------17/11/2020 debut
17/11/2020 - D08:59 - F00:00 - Chapitre 7 - p.106/259 FR 154/376 EN
17/11/2020 - D08:59 - F13:56 - Chapitre 7 - p.107/259 FR 155/376 EN

Notes :  redacD11:00 - F11:48 17/11/2020 - vid
------

108. Chap.7 - p. 104 FR 152 EN - Le débogueur - .txt vs txt
1. "L'évaluation du "suffix" « readme.txt » se terminera et affichera la réponse « .txt ».
La réponse est-elle correcte ? 
Malheureusement, nous ne pouvons pas le dire avec certitude. 
Le suffixe doit-il être ".txt" ou "txt" ? 
Le commentaire de méthode en "suffix" n'est pas très précis. 
La manière d'éviter ce genre de problème est d'écrire un test "SUnit" qui définit la réponse."

2. "Pharo a un excellent débogueur, mais comme la plupart des outils puissants, 
il peut être déroutant lors de la première utilisation." (p.90 FR 131 EN)

3. Listing 7-23 A simple test for the suffix method
testSuffixFound
self assert: 'readme.txt' suffix = 'txt'

Listing 7-25 A better test for the suffix method
testSuffixFound
self assert: 'readme.txt' suffix = 'txt'.
self assert: 'read.me.txt' suffix = 'txt'

1. Concernant le premier point, le suffixe ".txt", est correcte d'après la liste de "PATHEXT" de Windows.
De plus, je ne comprends pourquoi il faut se fier à un commentaire "pas très précis" plus tôt qu'un code.
Est-ce que cela soulève la question, à savoir qu'il s'agit d'un code imprécis et non fiable ?
Où alors interroge-t-il un modèle incomplet, rudimentaire ou erroné ?

Variables-> ? je ne sais plus le chemin
10   9   8   7   6   5  4  3   2   1 
58 110 114 101 116 116 97 80 111 110 decimal 
$:  $n  $r  $e  $t  $t $a $P  $o  $n

2. Le second point met en avant l'excellence d'un "débogueur" et le premier point son incertitude.
Ou alors pourrait-on bifurquer sur l'hypothèse que le codeur n'a pas su mettre correctement en code sa demande ?
Quelle est la définition du mot "suffixe" ? On peut l'interpréter de deux manières :
"Suffixe = Affixe ajouté à la suite d’un mot." et "Affixe = Élément qui s’ajoute à la forme d’un mot pour en 
modifier le sens ou la valeur grammaticale. Les préfixes, les suffixes, les infixes sont des affixes."
Considérant cela, on peut constater que "readme" est le premier élément suivi des deux autres : "." et "txt".
Alors qu'en informatique, le suffixe ou l'extension font appel à deux éléments indissociables ".txt".
Par voie de conséquence, le codeur ne sait pas ce qu'il cherche précisément étant donné que le mot "suffixe",
fait appel à un conflit intérieur inconscient, une vérité instable, imprécise sur ce qui doit être "cherchez " 
ou "recherché ".
Dans ce cas, on pourrait imaginer le plateau d'un jeu de "Go" ou "d'échecs" et chaque case contiendrait 
des mots de code et au-dessus en miroir, mais identique par sa forme contiendrait la racine des mots. 

3. "Le suffixe doit-il être ".txt" ou "txt" ?", 
les listings "7-23" et "7-25" montrent des tests sur le suffixe "txt" alors qu'il s'agit de ".txt".
Pourquoi, aucun test pour le suffixe ".txt" ? 

4. Pourquoi est-ce que le "Listing 7-24" n'existe pas ? Peut-on considérer que c'est ici aussi un modèle inexistant ?
(Listing vs Figure)

Au final, ce sont des choses simples ou les accidents qu’ils font écroulés l'excellence d'un code, d'un objet, 
d'un modèle et d'un débogueur.
:-)

11:14 17/11/2020
Defaut (Stack-> ByteSting(String) - suffix, Source-> dot := '.'. 

12:25 17/11/2020
Pharo présentation
p.36 EN - Figure 2-15
Partie basse de Pharo "Retour de l'assistant qualité".
"vous obtenez les commentaires de l'Assistant Qualité: il exécute automatiquement des règles de qualité sur votre code et les signale."

--------------------------------------------------------
  Packages   |	 Classes  |  Protocols   |    Methods   |
--------------------------------------------------------|
	Method selector					|
							|
		Method comment				|
							|
			Method body			|
--------------------------------------------------------|
		Quality Assistant feedack		|
--------------------------------------------------------

Fvid	(erreur sur 108 et 109, décalage des numéros)
109. Chap.7 - p. 106 FR 155 EN - testSuffix - StringTest 1
"Un test simple pour la méthode des suffixes"
J'ai mis le code "testSuffixFound" dans "Playground", histoire d'aller plus vite mais ça ne fonctionne pas.

testSuffixFound
self assert: 'readme.txt' suffix = 'txt'

self assert: 'readme.txt' suffix = 'txt'.
self assert: 'read.me.txt' suffix = 'txt'

Sauf, peut-être, un peu de patientes et des modifications.

" si vous ajoutez testSuffix à la classe StringTest..."
Et lorsque "System Browser" a ouvert la classe "StringTest", 
je me suis interrogé sur le contenu (corps, method selector, body) de cette classe et le bug précédent.
C'est un objet qui contient beaucoup de test qui va interroger plusieurs autres object qui va interroger du code.
Mais quand est-il de ce code ? De son contenu, sa fiabilité, l'analyse, l'approche, le déroulement, 
son fonctionnement et son résultat ?

De même, je suis surpris de constater la longue liste affichée par l'assistant qualité.
Alors que je n'ai pas modifié ce code, dans ce cas, c'est un objet vivant. (A life, a life)
:-)

17/11/2020 - D08:59 - F13:56 - Chapitre 7 - p.107/259 FR 155/376 EN
-------------------------------------------------------------------------------------------------------17/11/2020 fin



-------------------------------------------------------------------------------------------------------18/11/2020 debut
18/11/2020 - D12:04 - F - Chapitre 7 - p.107/259 FR 155/376 EN
18/11/2020 - D12:04 - F13:57 - Chapitre 7 - p.107/259 FR 156/376 EN

SUnit ? "Le "Test Runner" vous permet d'exécuter et de déboguer des tests "SUnit", 
et est décrit plus en détail dans le chapitre 9 - SUnit (p.119 FR - 175 EN)." (p.91 FR) 

13:13 18/11/2020
110. Chap.7 - p. 107 FR 155 EN - test for the suffix 2
Le listing 7-23 passe le test contrairement au second listing 7-25 qui reste en erreur.


Je n'ai plus la main sur le programme Pharo.

Sauf si....

Solution
1 Restart = suffix 2 Into = dot 3 Proced = Runtest green

Note : 
------
Impossible d'exécuter le code Figure 7-26, car il me demande de choisir une ligne contenue dans une liste.
Rien n'est indiqué dans le livret, encore une fois il faut décrypter les paragraphes, chercher ou laisser tomber.

Ajouts des numéros 1, 2 et 3 à 109, 110 et 111 "test for the suffix". (Absent des GIFs)

13:39 18/11/2020
111. Chap.7 - p. 107 FR 155 EN - test for the suffix 3
"Ainsi, par exemple, nous pourrions modifier la méthode "suffix" pour qu'elle se lise comme suit:"
1. Encore une fois, le code n'est pas à la suite du paragraphe.
2. Je lance le troisième Code (Figure 7-26) en direct afin d'enregistrer les surprises éventuelles.
Je fais quoi ?
Rien n'est indiqué sur le livret ! :-(
class String - method suffix 
????????
:-(

18/11/2020 - D12:04 - F13:57 - Chapitre 7 - p.107/259 FR 156/376 EN
-------------------------------------------------------------------------------------------------------18/11/2020 fin



-------------------------------------------------------------------------------------------------------19/11/2020 debut
19/11/2020 - D11:06 - F: - Chapitre 7 - p.107/259 FR 156/376 EN
19/11/2020 - D11:06 - F13:15 - Chapitre 7 - p.108/259 FR 157/376 EN

11:22 19/11/2020
StringTest>>testSuffixFound

12:30 19/11/2020 - vidF12:37 19/11/2020
112. Chap.7 - p. 107 FR 156 EN - Listing 7-26
Le lecteur est abonné à son sort.
Undeclared : basta
Le mirage d'une boucle infinie, le débogage d'un calcul (?), 
des touches de raccourcis "CMD-. ou CMD-Shift-." qui ne serve à rien (?), 
la modification simple d'un code pour insérer "Halt now.." (?),
changer la méthode suffixe pour qu'elle se lise comme suit (suite ?) 
et enfin l'apparition du pré-débogueur : procéder ou entrer ?
selecting the erroneous test ???
replace the detect: message by detect:ifNone: ???
Où est-il l'objet vivant, concret, pragmatique et l'excellence du débogueur ?
Au lieu de répéter des paragraphes pour rien dire, c'est par exemple ici qu'il fallait démontrer 
l'excellence du débogueur.
C'est bâclé.
:-(
Voilà fini, je ne cherche pas midi quatorze heures.

13:10 19/11/2020
113. Chap.7 - p. 107 FR 157 EN - L'excellence du débogueur
Très franchement, une note de 1,5 sur 10 s’est même trop bien notée.
Ça n'a rien à voir avec l'excellence.
J'ai réalisé des tests de débogage sur le site code.org et les blocs graphiques d'un côté 
et la mise en scène vivante de l'autre ont de réelles incidences visuelles 
et le débogage ainsi que l'exécution du code fonctionne.
Ce qui n'est pas du tout le cas dans ce débogueur qui n'est pas précis et le meilleur test ne fonctionne pas.
(and from there look at variables, step through the computation, and edit the code).
Qu'est-ce que ça va m'amener à "regarder, parcourir et éditer" ?
"Le bug initial aurait dû vous faire réaliser que s'il n'y a pas de point dans la chaîne cible" 
Je ne sais pas de quoi il s'agit.
"remplacer le  detect:  message en  détecter: ifNone:"
Non seulement je ne sais pas où ça se trouve, mais en plus je ne sais pas ce que c'est.
Puis rapidement, le lecteur passe au paragraphe "7.5 - The process browser".
Intégrez un objet vivant dans votre livret PDF, car ici c'est bâclé, non vivant, on ne sait pas ou l'on va.
Il faut décrypter et chercher et enfin des mots apparaissent sans savoir ce qu'il en retourne. 1/10.

19/11/2020 - D11:06 - F13:15 - Chapitre 7 - p.108/259 FR 157/376 EN
-------------------------------------------------------------------------------------------------------19/11/2020 fin



-------------------------------------------------------------------------------------------------------20/11/2020 debut
20/11/2020 - D11:26 - F00:00 - Chapitre 7 - p.108/259 FR 157/376 EN
20/11/2020 - D11:26 - F14:14 - Chapitre 7 - p.108/259 FR 157/376 EN

11:30 20/11/2020 
114. Chap.7 - p.107 FR 156 EN - Listing 7-26
Je refais "le meilleur test".

1. Je remplace l'ancien code "suffix" par celui de la figure 7-26,

2. J'enregistre et je sélectionne la 1re ligne du menu "Leave variable undeclared",

3. "Lorsque nous exécutons cette méthode, l'exécution de Halt fera maintenant apparaître le pré-débogueur,"
	3.1 Dans le code suffix, met le curseur à la droite du point "Halt now.", puis "Do It" (CTRL + D), 
		(Ouvre le débogueur, mais le nom de la fenêtre est "Halt")
	3.2 Dans le code suffix, sélectionne "Halt now.", puis "Debug It" (CTRL + Shift + D), 
		(Ouvre le débogueur et le nom de la fenêtre est "debug it")
4. (et à partir de là, regardez les variables, parcourez le calcul et éditez le code).
   (and from there look at variables, step through the computation, and edit the code).
	4.1 Parcourir le calcul ?
	4.2 Editez le code ?

5. "Le bug initial aurait dû vous faire réaliser que s'il n'y a pas de point dans la chaîne cible,"
   "The initial bug should have made you realize that if there is no dot in the target string,"

6. "ajoutez "testNoSuffix" à la suite de tests dans la classe "StringTest" et regardez le test générer une erreur."
   "add testNoSuffix to the test suite in class StringTest, and watch the test raise an error."

7. "Entrez le débogueur en sélectionnant le test erroné dans SUnit et modifiez le code pour que le test réussisse."
   "remplacer le  detect: message en detect:ifNone:"
   "Enter the debugger by selecting the erroneous test in SUnit, and edit the code so that the test passes."
   "replace the detect: message by detect:ifNone:"
 "remplacer le  detect: message en detect:ifNone:" ?????
Je ne sais pas ce que je dois faire ou chercher!!!!

Note : 
-----
$.. remplace par FileDirectory dot first.

20/11/2020 - D11:26 - F14:14 - Chapitre 7 - p.108/259 FR 157/376 EN
-------------------------------------------------------------------------------------------------------20/11/2020 fin



-------------------------------------------------------------------------------------------------------21/11/2020 debut
22/11/2020 D11:58 - F: - Chapitre 7 - p.108/259 FR 157/376 EN
22/11/2020 D11:58 - F13:44 - Chapitre 7 - p.109/259 FR 159/376 EN

12:05 22/11/2020
"replace the detect: message by detect:ifNone:"
Des informations sont manquantes sur ce qu'il faut modifier et l'endroit.
Je laisse tomber et passe à la suite.
7.5 The process browser

13:32 22/11/2020 - vid13:38 22/11/2020
115. Chap.7 - p.109 FR 158 EN - 7.7 Résumé du chapitre

Notes :
------
"mais à l'heure actuelle, la concurrence est mise en œuvre par découpage temporel."
concurrence ? découpage temporel ?

"Nous en avons discuté assez longuement dans le chapitre : Un tour rapide de Pharo."
Alors c'est marrant, là il le met. (lien Un tour rapide de Pharo).

"Afin de se développer efficacement avec Pharo,"
Afin de se développer efficacement ? Jusqu'à maintenant, la ligne de conduite est tortueuse.

"il est important d'investir un peu d'efforts dans l'apprentissage des outils disponibles dans l'environnement."
C'est plus qu'un peu d'efforts c'est une prise de tête.
À ce stage, le codage est survolé et oublié tandis que les outils c'est 95 % de prise de tête.

"Le navigateur standard est votre interface principale"
Le lecteur se demande, quelles sont les interfaces principales ? 
Parce qu'il faut décrypter les "Figures" présentent dans le livret et les navigateurs 
"monticello et system browser" ou l'un possède "--all--" tandis que l'autre il faut sauter un volet sur deux.

"votre interface principale pour parcourir les packages, classes, protocoles de méthodes et méthodes existants"
C'est surprenant de lire "protocoles de méthodes" alors qu'il m'a fallu faire un document pour comprendre qu'il 
s'agissait de méthode. 
Plus j'avance dans ce livret et je découvre des choses qu'il aurait fallu indiquées au début.

"Vous pouvez également parcourir le système Pharo par programmation en envoyant des messages à 
SystemNavigation par défaut."
J'ai oublié ce qu'il en était.

"L'Inspecteur est un outil utile pour explorer et interagir avec les objets vivants de votre image."
Je n'ai pas rêvé, mais interagir avec une "date" je n'appelle pas ça un objet vivant. 
Donc, j'ai exploré, lu du code, exploré, lu du code, ensuite tu recommences du début, etc..

"Vous pouvez même inspecter les outils en méta-cliquant pour afficher leur halo morphique et en sélectionnant la
poignée de débogage."
Recherche dans le livret "halo morphique", cela donne "Figure 3-10".
Le halo morphique, je ne l'ai vu à aucun moment. 
C'était un peu plus clair et flagrant lorsqu'il fallait inspecter "Locell" à la "Figure 3-10" page 57.

"Le débogueur, d'interagir avec tous les objets de votre application, y compris le code source"
Encore une fois cette notion "d'objet" est incohérent puisqu'il s'agit de code.
Package> code, Classe> code, Protocol - methode> code, méthode> code

"Le débogueur est particulièrement efficace"
"Cependant, il s'avère que cela n'aide pas non plus;"
"Le commentaire de méthode en "suffix" n'est pas très précis. La manière d'éviter ce genre de problème est d'écrire un test SUnit"
"Maintenant que nous voyons le bogue, le correctif est évident: nous devons convertir dot en caractère avant de commencer à le rechercher."
Il est tellement efficace qu'on est obligé d'écrire un test SUnit, de lire plusieurs lignes de code en surbrillance 
sans savoir ce qu'il faut faire, de voir de multiples bogues et un correctif qui n'est pas évident.
Et enfin, être tenu de remplacer "detect: message en detect:ifNone:", sans pour autant que cela fonctionne.
C'est d'une efficacité redoutable de bogue.



"Le Finder est un outil de localisation de méthodes."
Quel est l'intérêt d'utiliser "Finder" alors que depuis "System Browser" on peut rechercher une méthode.
"System Browser" recherche une méthode rattachée au package en cours alors que "Finder" rechercher dans tous les packages. 

Affichage des processus :
System> Process Browser> fenêtre de gauche ligne statique> mettre à jour : clic droite "Turn on auto-update" (CTRL +A),

22/11/2020 D11:58 - F13:44 - Chapitre 7 - p.109/259 FR 159/376 EN
-------------------------------------------------------------------------------------------------------21/11/2020 fin



-------------------------------------------------------------------------------------------------------23/11/2020 debut
D12:02 23/11/2020 - F: - Chapitre 7 - p.109/259 FR 159/376 EN
D12:02 23/11/2020 - F13:34 - Chapitre 8 - p.111/259 FR 162/376 EN

12:22 23/11/2020
116. Chap.8 - p.110 FR 161 EN - Partage du code

Notes : 
------
"La conséquence de la programmation dans un monde d'objets vivants plutôt qu'avec des fichiers"
Désolé, mais lorsque j'ai exporté "ImageMorph.st", "ImageMorph-drawOn.st", "Morph-drawOn.st", 
"Object-shouldBeImplemented.st", "PBE-LightsOut.st" ce sont clairement des fichiers contenant du code.
En aucun cas un "monde d'objets vivants".
"Quelque chose d'explicite" (smallFontsIcon, smallWarningIcon, nodesWithUnknownParent, Blue Morph) ou 
"un ensemble de modifications" (!LOCell commentStamp: 'UserPharo 9/28/2020 13:07' prior: 0!), 
c'est la même chose en l'occurrence du code.

Note : 
-----
Cadre-> framework PharoLink
Indiquer tout simplement un "package PharoLink" n'est-il pas plus simple qu'utiliser de multiples mots ?
MDR, c'est après avoir indiqué les classes que le lecteur peut lire "placés dans un package appelé PharoLink".
Au début du livret et après avoir exécuté "LightsOut", le lecteur sait à quoi s'attendre de l'organisation 
du package et des classes.
"Cependant, tout votre code ne résidera pas dans ces classes."
Ha, ce n'est plus des objets ?


------------------------------------------------------------------------
     Package	|     Class 		|   Protocol 	|	Method  |
------------------------------------------------------------------------
		|	   RPackage	|		|		|
		| (Représente les packa-|		|		|
		| -ges)		|	|		|
		|			|		|		|
		| RPackageOrganizer	|		|		|
		| (Implemente un single-|		|		|
		| -ton qui contient tous|		|		|
		| les packages Pharo.)	|		|		|
-------------------------------------------------------------------------
    PharoLink	| OracleConnection	|		|  		|
 		| MySQLConnection	|		|		|
	 	| PostgresConnection	|		|		|
		| DBTable		|		|		|
		| DBRow			|		|		|
		| DBQuery		|		|		|
		| Object		| *PharoLink	| # asSQL	|
		| String		| *PharoLink	| # asSQL	|
		| Date			| *PharoLink	| # asSQL	|
		| 			|		|		|
		|			|		|		|
-------------------------------------------------------------------------

D12:02 23/11/2020 - F13:34 - Chapitre 8 - p.111/259 FR 162/376 EN
-------------------------------------------------------------------------------------------------------23/11/2020 fin



-------------------------------------------------------------------------------------------------------24/11/2020 debut
D09:02 24/11/2020 - F13:34 - Chapitre 8 - p.111/259 FR 162/376 EN
D09:02 24/11/2020 - F12:20 - Chapitre 8 - p.118/259 FR 174/376 EN

Recherche : Foo ou foo
----------

Code simple :
inlineFoo: aBlock 
	| bar baz asdf |
	bar := aBlock value: self.
	baz := bar + bar.
	asdf := baz + bar.
	^asdf

Rappel : singleton (encore une surprise = une épine dans le pied)
--------
P.76 FR
"Exemple: définition d'un singleton
Le modèle Singleton fournit un exemple typique de l'utilisation de variables d'instance de classe et de méthodes 
de classe. Imaginez que nous aimerions implémenter une classe WebServer, et utiliser le modèle Singleton 
pour nous assurer qu'il n'a qu'une seule instance."

p.86 FR 125 EN
"si Pharo était implémenté à partir de zéro aujourd'hui, la plupart des variables globales qui ne sont pas 
des classes seraient remplacées par des singletons."

09:25 24/11/2020
117. Chap.8 - p.111 FR 162 EN - Accéder aux packages
"Les expressions suivantes sont des exemples des requêtes que vous pouvez effectuer."
Je ne sais pas ce qu'il ouvre à ce jour le Playground, mais contrairement à hier c'était des "not understand". 
C'est incompréhensible, ça n'a rien à voir avec le package "AST-Core" et encore moins les classes. 
Bon et bien voilà, Super ! 

Note : p.111 FR 163 EN
------
"Lorsque vous chargez du code ou écrivez du code dans un référentiel distant, une copie est également enregistrée
dans le cache du package. "
"When you load code from or write code to a remote repository, a copy is also saved in the package cache."
Chargement et écriture, ce n'est pas décrit comme un objet vivant alors que tout est objet.

10:48 24/11/2020
118. Chap.8 - p.112 FR 164 EN - Création d'un package
"Créez également une méthode dans une classe existante, telle qu'Object, et placez-la 
dans le même package que vos classes - voir Figure 8-4."
Malheureusement, cette partie est compliquée puisqu'il ne veut pas n'importe quel "object" et un message indique
une instabilité éventuelle. 
(Object is an existing class in this system. Redefining it might cause serious problems.
Is this really what you want to do?)
La question c'est, comment faire pour créer une méthode dans une classe existante ?
Encore une fois, il faut décrypter le livret pour peut-être enfin arriver à finaliser un exercice.
Du coup, j'ai cliqué sur "Proced" et le programme Pharo a bloqué.
Création du package PBE x2.
(Cliquer sur "Hier." pour faire apparaître l'objet)<- NON pas bon.
:-(

Notes : 
-------
Blablabla, "controle de la source, ensemble de mofis".

11:26 24/11/2020
119. Chap.8 - p.117 FR 172 EN - 8.3 The file list browser
J'ai mis "*" dans la fenêtre de recherche "Hit return to accept" et depuis "File Browser" n'est pas en bonne forme
lorsque je clique sur les dossiers le message indique "RegexSyntaxError: nullable closure".
Exemples de recherche : *dout, *.dll, ssleay*
On s'attend à ce qu'il affiche de suite la recherche alors qu'il faut appuyer sur la touche clavier "Entrée".
Il faut composer, entrent la touche clavier "Entrée", le symbole "*", vider la fenêtre "Hit return to accept".
:-(

11:55 24/11/2020 -modifs12:09 24/11/2020 
120. Chap.8 - p.118 FR 173 EN - How to get your code back
"Restart Pharo from the most recent snapshot, and select World > Tools...> Recover lost changes."
"Redémarrez Pharo à partir de l'instantané le plus récent et sélectionnez Monde> Outils ...
> Récupérez les modifications perdues."

1. Comment redémarrer Pharo ?
Depuis la barre d'outils : Pharo> Save and quit ou Pharo> Quit 
Ou alors  
En cliquant sur la "X" (Pharo Virtual Machine - Quit Pharo Virtual Machine without saving? "Oui - Non")
Parce qu'il y a une différence entre "Quit" et "Reboot" - "Restart".

2. L'option "Recover lost changes" n'existe pas. L'objet est-il vivant ? Alors, il s'est envolé.
:-( Recover Kapout.

Peut-être, mettre en place la possibilité de lancer cette option depuis Playground.
Indiquer le raccourci clavier sur le livret ne serait pas un mal non plus.

D09:02 24/11/2020 - F12:20 - Chapitre 8 - p.118/259 FR 174/376 EN
-------------------------------------------------------------------------------------------------------24/11/2020 fin



-------------------------------------------------------------------------------------------------------25/11/2020 debut
D11:45 25/11/2020 - F: - Chapitre 9 - p.118/259 FR 174/376 EN
D11:45 25/11/2020 - F14:02 - Chapitre 9 - p.121/259 FR 178/376 EN

Chap. 9 - p. 119 FR 175 EN
Créateur - Kent Beck, étendu par Joseph Pelrine et d'autres.
"Notez que la version documentée dans ce chapitre et utilisée dans Pharo est une version modifiée de SUnit3.3."
"SUnit est un framework minimal mais puissant"


				SUnit
			  (utilisé pour )
		/----------------|----------------\
	       /		 |		   \
	tests unitaires  tests d'intégration tests fonctionnels

			tests automatisés

Notion de ressource :
--------------------- 

Pourquoi nous testons ? 9.2
-----------------------
(?)
"mouvement de développement logiciel Agile",
"programmation eXtreme",
"développement incrémental soutenu par sa programmaton environnement",

(:-)
"En moins de deux minutes, vous pouvez écrire des tests avec SUnit, donc au lieu d'écrire de petits extraits 
de code dans un playgound, nous vous encourageons à utiliser SUnit et à profiter de 
tous les avantages des tests stockés et exécutables automatiquement."
"Considérez les tests comme un investissement pour l'avenir: avoir une suite de tests est très utile maintenant, 
mais cela sera extrêmement utile lorsque votre application, ou l'environnement dans lequel elle s'exécute, 
changera dans le futur."

1. Fournir une documentation de la fonctionnalité,
2. Aide le développeur à confirmer les modifications,
3. Réflexion sur les fonctionnalités à concevoir et représentation au "code client",
4. Écrire des tests avant le code. (contexte, interaction code client, résultats) - (Méthodologies de développement
de logiciels telles que eXtreme Programming, Test-Driven Development (TDD)).

"Votre code s'améliorera."(Le code évolue-t-il ? Qu'est-ce qu'un bon code ?)


Qu'est-ce qui fait un bon test ? 9.3
-------------------------------

1. Pratiquer pour écrire de bons tests,

Propriétés des tests : 
---------------------

1. Tests répétés,
2. Tests obtenant la même réponse,
3. Tests sans intervention humaine,
4. Tests exécutés sans surveillance,
5. Tests racontant une histoire,
6. Tests couvrant l'aspect d'un morceau de code,
7. Tests agissants comme un scénario et être susceptible de le lire pour comprendre une fonctionnalité,
8. Tests à fréquence de changement inférieure à celle de la fonctionnalité qu'ils couvrent,
9. Tests écrits basés sur les interfaces publiques de la classe que vous testez,
10. Tests écrits pour une méthode d'assistance privée lorsque la méthode est compliquée,
11. Tests proportionnel au nombre de fonctions à tester,

13:47 25/11/2020
Note : 
------
Listing 9-1 est perdu au milieu du test. :-)

"Les programmeurs pragmatiques proposent le principe «right-BICEP». 
Ça signifie :
 
	* Right : les résultats sont-ils corrects ?
 
	* B : Toutes les conditions aux limites sont-elles correctes ? (conditions aux limites ?)
 
	* I : Pouvez-vous vérifier les relations inverses ? (relations inverses ?)
 
	* C : Pouvez-vous recouper les résultats en utilisant d'autres moyens ?
 
	* E : Pouvez-vous forcer les conditions d'erreur à se produire ?
 
	* P : Les caractéristiques de performance sont-elles dans les limites ?

Note : 
------
Il n'y a aucune relation, interaction entre la lettre et son contenu. 
(C'est étonnant étant donné qu'il s'agit de programmation utilisant des objets)
(Rébus, Mnémotechnique, images, scénario, histoire)


Exemple, SUnit : 9.4 - suite le 26/11/2020
----------------
Exemple étape par étape pour tester la classe "Set".

Etape 1: créer la classe de test.
Le package ? Playground> Set - System Browser (CTRL + B)
Le package principal est "Collections-Unordered",
Le package contenant la classe "Set" est "Collections-Unordered-Sets".


Mise en œuvre de SUnit : 
------------------------

"Enfin, nous examinons la mise en œuvre de SUnit, afin que vous puissiez comprendre comment Pharo utilise 
le pouvoir de la réflexion pour soutenir ses outils."

D11:45 25/11/2020 - F14:02 - Chapitre 9 - p.121/259 FR 178/376 EN
-------------------------------------------------------------------------------------------------------25/11/2020 fin



-------------------------------------------------------------------------------------------------------26/11/2020 debut
D13:15 26/11/2020 - F00:00 - Chapitre 9 - p.121/259 FR 178/376 EN
D13:15 26/11/2020 - F13:43 - Chapitre 9 - p.121/259 FR 178/376 EN

13:25 26/11/2020
121. Chap.9 - p.121 FR 178 EN - Listing 9-1
Je me pose la question à savoir pourquoi le "Listing 9-1", est-il au milieu de nulle part ?
De plus, sans lien avec le paragraphe et encore une fois, il faut décrypter le contenu.
Jeu de piste.

Note : 
------
122. Chap.9 - p.121 FR 178 EN - 9.4 SUnit par l'exemple
En décryptant le livret, je pense que le listing 9-1 est le package à créer.
Le système d'étape n'est pas au point.


Exemple, SUnit : 9.4 - suite le 26/11/2020
----------------
Exemple étape par étape pour tester la classe "Set".

Etape 0: créer le package (Listing 9-1)
TestCase subclass: #MyExampleSetTest
instanceVariableNames: 'full empty'
classVariableNames: ''
package: 'MySetTest'

Création :
----------

Object subclass: #NameOfSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'MySetTest'

Etape 1: créer la classe de test.
Le package ? Playground> Set - System Browser (CTRL + B)
Le package principal est "Collections-Unordered",
Le package contenant la classe "Set" est "Collections-Unordered-Sets".

D13:15 26/11/2020 - F13:43 - Chapitre 9 - p.121/259 FR 178/376 EN
-------------------------------------------------------------------------------------------------------26/11/2020 fin



-------------------------------------------------------------------------------------------------------27/11/2020 debut
D12:36 27/11/2020 - F00:00 - Chapitre 9 - p.121/259 FR 178/376 EN
D12:36 27/11/2020 - F15:04 - Chapitre 9 - p.121/259 FR 178/376 EN

Exemple, SUnit : 9.4 - suite le 26/11/2020
----------------
Exemple étape par étape pour tester la classe "Set".

Note : 
------
123. Chap.9 - p.121 FR 178 EN - 9.4 Etape 1 : créer la classe de test
A. Plusieurs volets sont définis dans Pharo et le premier concerne le package.
Lorsqu'un projet démarre celui-ci, commence par la création d'un package.
Alors pourquoi l'étape 1 de SUnit démarre-t-elle par la création d'une classe ?
(3.1 The Lights Out game - 3.2 Creating a new Package - 3.3 Defining the class LOCell - p. 50 EN)

Étape 0 : créer le package (Listing 9-1)
--------

Package défaut : 
---------------

Object subclass: #NameOfSubclass
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'MySetTest'

Package modifié :
----------------

TestCase subclass: #MyExampleSetTest
instanceVariableNames: 'full empty'
classVariableNames: ''
package: 'MySetTest'

B. "Add two instance variables so that your new class looks like this:", 
"Ajoutez deux variables d'instance pour que votre nouvelle classe ressemble à ceci :"
Définition de ceci : "Ce que l’on montre et qui est (le plus) près du locuteur."
Pourquoi le "Listing 9-1" n'est-il pas à la suite de "ceci" idem à suivant ?

C. De toute évidence, le lecteur va copier et coller le code disponible depuis le volet package.
Donc, pourquoi "Ajouter deux variables d'instance" ?

Étape 1 : créer la classe de test
--------

Package		Class			Variables d'instance	
MySetTest	(C)TestCase		full		
		(C)MyExampleSetTest	empty


Étape 2 : initialiser le contexte de test
--------

Package		Class			Protocol			Method	
MySetTest	(C)TestCase		running (créé automatiquement)	setUp (Effacé par setUp code livret) Il manque une info.< Pas bon !
		(C)MyExampleSetTest	setup				(setUp	"Hooks that subclasses may override to define the fixture of test.")
					tests

D. Un décalage entre le code et le paragraphe.
Entre le code "Listing 9-2" et la "Figure 9-6", l'élément "setup" et "setUp" sont contradictoire.
Les étapes ne sont pas claires.

E. Aucune information dans les étapes 1, 2, 3 concernant les protocoles "setup" et "tests". 
Après toutes ces étapes, le lecteur a "espéré " une figure et c'est lorsque la "Figure 9-6" apparaît 
que le lecteur constate la création de deux protocoles.
Non seulement les étapes ne sont pas claires, mais également les explications.
(exemple : each test method defined in the test class. = aucune classe "Test" seulement "MyExampleSetTest")

methode setUp-> listing 9-2 ? protocol setup-> figure 9-6 ?

Une figure vaut mille mots.

Erreurs ? Test OK ? C'est contradictoire.
Il reste à lire les explications des "étapes". :-(
----------------------------------------------------------123. Chap.8 - p.121 FR 178 EN fin

D12:36 27/11/2020 - F15:04 - Chapitre 9 - p.121/259 FR 178/376 EN
-------------------------------------------------------------------------------------------------------27/11/2020 fin



-------------------------------------------------------------------------------------------------------28/11/2020 debut
D11:06 28/11/2020 - F00:00 - Chapitre 9 - p.121/259 FR 178/376 EN
D11:06 28/11/2020 - F13:40 - Chapitre 9 - p.123/259 FR 180/376 EN

Note : 
------
Erreurs sur les précédents points négatifs, laissés Chap.8 au lieu de Chap.9.

13:08 28/11/2020 - vid13:27 28/11/2020
124. Chap.9 - p.122 FR 179-180 EN - 9.4 Étape 2, 3

Étape 2 : initialiser le contexte de test
--------

----------------------------------------------------------------------------------------
Package		Class			Protocol			Method	
		(C)Set
----------------------------------------------------------------------------------------
MySetTest	(C)TestCase		
		(C)MyExampleSetTest	setup	--------------------->	setUp
					tests	--------------------->	testIncludes
									testOccurences
									testRemove
----------------------------------------------------------------------------------------

p.122 FR 179 EN									
"Le message TestCase >> setUp définit le contexte dans lequel les tests vont s'exécuter"
"setUp est invoqué avant l'exécution de chaque méthode de test définie dans la classe de test."
"le contexte est appelé le  dispositif  de test."

Étape 3 : écrivez quelques méthodes de test
---------

"Les noms des méthodes doivent commencer par la chaîne «test» afin que SUnit les rassemble dans des suites de tests."
"Les méthodes de test n'acceptent aucun argument."

Note : 
-----
Je comprends maintenant pourquoi les programmeurs ne font pas de test puisque c'est une contrainte, 
une perte de temps, nébuleux et compliqué.

----------------------------------------------------------------------------------------------------------------------
Méthodes	|	Descriptions
----------------------------------------------------------------------------------------------------------------------
testIncludes	|	teste la méthode "includes: de Set
		|	le test dit que l'envoi du message "includes: 5 to a set containing 5 should return true"
		|					   "comprend: 5 à un ensemble contenant 5 doit retourner vrai"
		|	"Clairement, ce test repose sur le fait que la méthode "setUp" a déjà été exécutée."
		|	:-?
----------------------------------------------------------------------------------------------------------------------
testOccurrences	|	verifies that the number of occurrences of 5 in full set is equal to one, 
		|	even if we add another element 5 to the set.
		|	vérifie que le nombre d'occurrences de 5 dans l'ensemble complet est égal à un,
		|	même si nous ajoutons un autre élément 5 à l'ensemble. 
		|	"Enfin, nous testons que l'ensemble ne contient plus l'élément 5 après l'avoir supprimé."
		|	:-?
----------------------------------------------------------------------------------------------------------------------
testRemove	|	Aucune description ?
		|
		|	:-?
----------------------------------------------------------------------------------------------------------------------


Notes : 
------
testIncludes : Très clairement, le "testIncludes" est incompréhensible.
-------------
Pourquoi cette méthode spécifique "includes:" au lieu de "collect:" ou de "do:" ?
Pourquoi le message serait "includes: 5" ? au lieu de 9 ou 0 ?
Le "Clairement = rabâche", ce qui a été signalé plus haut autrement dit : 
"setUp est invoqué avant l'exécution de chaque méthode de test définie dans la classe de test."
Au final, ce test qu'est-ce que c'est ?

testOccurrences :  TestOccurences, occupe plus qu'un symbole à s'y perdre.
----------------
Dans la classe "(C)Set", "Occurrences" n'existe pas contrairement à "occurrencesOf:".
Finder affiche "testOccurencesOfForIdentityCollections".
Pourquoi une occurrence de 5 ?
Pourquoi l'ensemble complet est-il égal à 1 ?
Si tu ajoutes un autre élément "9" à l'ensemble, que se passerait-il ?

TestCase >> deny: : Qu'est-ce que ça fait là ? Je ne comprends pas.
-------------------
"Notez l'utilisation de la méthode TestCase >> deny: pour affirmer quelque chose qui ne devrait pas être vrai. 
aTest deny: anExpression est équivalent à aTest assert: anExpression non, mais est beaucoup plus lisible."


testRemove : Formidables, les deux premières méthodes s'accompagnent d'explications nébuleuses 
-----------  tandis que la troisième est omise.


En conclusion, tout ça est compliqué, confus, tarabiscoté, opaque entre coupés de non-sens.
J'aurais aimé voir les "objets vivants", annoncés (bande-annonce), mais qui sont invisibles.
---------------------------------------124. Chap.9 - p.122 FR 179-180 EN FIN

13:38 28/11/2020
125. Chap.9 - p.122 FR 179 EN - TestCase 

TestCase >> deny: : Qu'est-ce que ça fait là ? Je ne comprends pas.
-------------------
"Notez l'utilisation de la méthode TestCase >> deny: pour affirmer quelque chose qui ne devrait pas être vrai. 
aTest deny: anExpression est équivalent à aTest assert: anExpression non, mais est beaucoup plus lisible."

"Inspector on a TestCase class (TestCase)" -> deny: n'existe pas.

D11:06 28/11/2020 - F13:40 - Chapitre 9 - p.123/259 FR 180/376 EN
-------------------------------------------------------------------------------------------------------28/11/2020 fin



-------------------------------------------------------------------------------------------------------29/11/2020 debut
D12:08 29/11/2020 - F00:00 - Chapitre 9 - p.123/259 FR 180/376 EN
D12:08 29/11/2020 - F14:03 - Chapitre 9 - p.124/259 FR 182/376 EN

Recherche : fixture
p. 122 FR 179 EN
"In testing jargon the context is called the fixture for the test."
"Dans le jargon de test, le contexte est appelé le dispositif de test."
(setUp	"Hooks that subclasses may override to define the fixture of test.")

Étape 4 : exécuter les tests
--------

12:45 29/11/2020
126. Chap.9 - p.123 FR 180 EN - Étape 4: exécuter les tests
1. "Abstract classes are italicized,"
"Les classes abstraites sont en italique,"
Définition : Abstrait 
"Qui ne fait pas référence à des objets du monde, mais à des relations, à des qualités.  
Qui est difficile à comprendre parce que ne fait pas référence à des objets du monde."
D'un côté, l'on rabâche que tout est objet et de l'autre l'annonce de classes abstraites.
C’est à y perdre son latin !

2. Le "Test Runner" affiche un résultat "blanc" sur fond "vert clair " difficile à déchiffrer.
À force, je me demande si cela n'est pas fait exprès, car le résultat de la figure 9-7 est lisible.

127. Chap.9 - p.123 FR 181 EN - Étape 4 : MyExampleSetTest run
1. Exécution d'un seul test.
1.1 Avec ou sans point ? Les deux.
1.2 Depuis Playground ? Oui.
Playground> "Print It" (CTRL + P)>  MyExampleSetTest run: #testRemove.

2. C'est agaçant ce décalage "Listing" ou "Figure" et le "Contenu".
"comme indiqué ci-dessous."
"as shown below."
Définition : Dessous
"Partie inférieure ou plus basse de qqch. Dessous du pied."
Le contenu du livret doit être "linéaire" comme une mélodie tandis que là, le lecteur monte, descend, remonte,
redescend, puis déchiffre et décrypte les paragraphes.
Définition : Linéaire
"Qui présente ou constitue une succession, une suite. Récit, mélodie linéaire. Classification linéaire."

3. "Certaines personnes incluent un commentaire exécutable dans leurs méthodes de test"
"Some people include an executable comment in their test methods that allows running a test method"
Le lecteur cherche le commentaire, il peut supposer que cela correspond au "Listing 9-8" 
puisque le prochain paragraphe indique le changement du chiffre 6 en 7.
Donc, où est le commentaire dans ce code (Listing 9-8) ?


Playground> "Print It" (CTRL + P)> (MyExampleSetTest selector: #testRemove) debug
Playground> "Print It" (CTRL + P)> MyExampleSetTest debug: #testRemove

L'étape par étape est bancale par conséquent contradictoire au contenu désordonné.

cool :-)
"1 ran, 1 passed, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 passed unexpected"

A
testRemove
full remove: 5.
self assert: (full includes: 6).
self deny: (full includes: 5)

B Listing 9-8
testRemove
"self run: #testRemove"
full remove: 5.
self assert: (full includes: 6).
self deny: (full includes: 5)

C Listing 9-9
testRemove
full remove: 5.
self assert: (full includes: 7).
self deny: (full includes: 5)


Étape 5 : Interpréter les résultats
--------

p.124 FR 182 EN
"La méthode assert: est définie dans la classe TestAsserter."
"The method assert: is defined in the class TestAsserter."

Note : 
------
"assert:" est la base à d'autres méthodes par exemple : 
assert:closeTo:, assert:closeTo:precision:, assert:description:, etc.
 
----------------------------------------------------------------------------------------
Package			SuperClass	Class		Protocol	Method	
----------------------------------------------------------------------------------------
SUnit-Core-Kernel			(C)TestAsserter			assert:closeTo:, assert:closeTo:precision:, assert:description:, etc.	
			(C)TestAsserter	  (C)TestCase	
----------------------------------------------------------------------------------------

D12:08 29/11/2020 - F14:03 - Chapitre 9 - p.124/259 FR 182/376 EN
-------------------------------------------------------------------------------------------------------29/11/2020 fin



-------------------------------------------------------------------------------------------------------03/12/2020 debut
D11:47 03/12/2020 - F: - Chapitre 9 - p.124/259 FR 182/376 EN
D11:47 03/12/2020 - F13:53 - Chapitre 9 - p.125/259 FR 184/376 EN

9.5 Le livre de recettes SUnit
"il existe plusieurs autres méthodes qui peuvent être utilisées pour faire des assertions."
Recherche :  assertions
"Proposition que l’on présente comme une vérité. Assertion gratuite, invérifiable, mensongère."

"La manière de présenter les choses fait qu'il faut apprendre les noms de la plupart de ces tests."

Exécution d'un seul test
L'exécution d'un seul test a déjà été citée plus haut. (redondant)

Ouvre test runner
Playground> TestRunner open (CTRL+D) 					

Lance la méthode de test "testremove"
Playground> MyExampleSetTest run: #testRemove> Print It (CTRL+P)		

Note : 
-----
Histoire de compliquer les choses. (suite)

Exécution de tous les tests dans une classe de test
"Any subclass of TestCase responds to the message suite,"
Playground> MyExampleSetTest suite run> Print It (CTRL+P) 

128. Chap.9 - p.125 FR 184 EN - Figure 9-11
9.6 Le cadre SUnit
--------------------------------------------------------------------------------------
				SUnit
--------------------------------------------------------------------------------------
Packages		Classes		Protocols	Methodes
--------------------------------------------------------------------------------------
(P)Kernel		(C)Object	(P)asserting	(M)assert:
(P)Kernel-Objects

(P)SUnit-Core		(C)TestAsserter	(P)asserting	(M)deny:
(P)SUnit-Core-Kernel			(P)asserting	(M)should:raise:
					(P)asserting	(M)shouldnt:raise:
							
			(C)TestCase	(P)accessing	(M)\bleu/ resources (avec s)
					(P)overridden
					(P)running	(M)run (sans :)
					(P)accessing	(M)selector
					(P)running	(M)\bleu/ setUp
					(P)overridden
					(P)running	(M)\bleu/ tearDown
					(P)overridden												

		(sans s)(C)TestResource (P)testing	(M)\bleu/ isAvailable
					(P)overridden
					(P)testing	(M)isUnavailable
					(P)running	(M)\bleu/ setUp
					(P)overridden
					(P)running	(M)\bleu/ tearDown
					(P)overridden

			(C)TestResult	(P)accessing	(M)errorCount
					(P)accessing	(M)failureCount
					(P)accessing	(M)passedCount
					(P)accessing	(M)runCount
					(P)accessing	(M)tests
									
			(C)TestSuite	(P)accessing	(M)addTest: (sans s)
					(P)accessing	(M)resources (avec s)
					(P)running	(M)run (sans :)			
-------------------------------------------------------------------------------------
Figure 9-11 Les quatre classes représentant le cœur de SUnit.


À retenir :
-----------

La flèche bleu (triangle bleu) pointant vers le haut indique que "ImageMorph>>drawOn:" remplace une méthode héritée,
(c'est à dire "drawOn:" hérite de Morph, "Morhp>>drawOn:")
	1 Morph -> 2 ImageMorph -> 3 drawOn:
La flèche bleu pointant vers la bas indique qu'elle est remplacée par les sous-classes.

D11:47 03/12/2020 - F13:53 - Chapitre 9 - p.125/259 FR 184/376 EN
-------------------------------------------------------------------------------------------------------03/12/2020 fin



-------------------------------------------------------------------------------------------------------07/12/2020 debut
D13:06 07/12/2020 - F00:00 - Chapitre 9 - p.125/259 FR 184/376 EN
D13:06 07/12/2020 - F13:45 - Chapitre 9 - p.125/259 FR 183/376 EN

Histoire : 
----------
Un concessionnaire auto de grande marque intervient sur une voiture électronique haut de gamme.
Le mécanicien ne comprend pas d'où vient le problème et ne peut le résoudre.
Il demande alors de l'aide auprès d'ingénieurs.
Ceux-ci ne comprennent pas plus l'origine du problème tellement celui-ci est incompréhensible.

C'est ce qui se passe avec le programme Pharo.

Note : 
------
C'est quoi une "exception particulière" ? "la propagation d'exception" ? l'objet vivant ?

should: aBlock raise: anExceptionalEvent
	"To test that a particular exception is raised during the execution of a Block"
	<debuggerCompleteToSender>
	^ self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)


shouldnt: aBlock raise: anExceptionalEvent  
	<debuggerCompleteToSender>
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not

D13:06 07/12/2020 - F13:45 - Chapitre 9 - p.125/259 FR 183/376 EN
-------------------------------------------------------------------------------------------------------07/12/2020 fin



-------------------------------------------------------------------------------------------------------08/12/2020 debut
D09:54 08/12/2020 - F00:00 - Chapitre 9 - p.125/259 FR 183/376 EN
pause 1 heure
D09:54 08/12/2020 - F12:30 - Chapitre 9 - p.126/259 FR 184/376 EN

p.126/259 FR 184/376 EN

"Un TestResource spécifie une méthode setUp qui est exécutée une seule fois avant une suite de tests; 
c'est à la différence de la méthode TestCase>>setUp, qui est exécutée avant chaque test."

(C)TestResource -> (M)setUp -> 1 seule exécution
(C)TestCase -> (M)setUp -> exécution avant chaque test 


"TestCase est une classe abstraite conçue pour être sous-classée."
Une classe abstraite. Objet vivant ! 
Au fur et à mesure, le lecteur va connaître le vrai visage du masque de Pharo. :-) (Zorro)
  
Cas de test : 1re représentation 
-------------
---------
Packages |
---------
   SUnit-Core 
      SUnit-Core-Kernel
	\/
-------------------------------------------------------------------------------------------------
Classe abstraite |  Sous-classe  |  Classe  | Protocole |   Méthode    |    Tests     | réponse  |
-------------------------------------------------------------------------------------------------
         ->	 |	->	 |     ->   |	  ->    | 	->     |     ->	      |		 |
TestCase	 |   TestCase    | TestCase |	        | Groupe Tests |	      |		 |
		 |		 |	    |  running  |   setUp      | suite test 1 | tearDown |--	
		 |		 |	    |  running  |   setUp      | suite test 2 | tearDown | |
		 |		 |	    |  running  |   setUp      | suite test 3 | tearDown | |
		 |		 |	    |  running  |   setUp      | suite etc....| tearDown | |
-------------------------------------------------------------------------------------------------- |
Modifications 09/12/20					|  tearDown    | <-----------<------------<|

Cas de test : 2e représentation 
-------------

Packages
SUnit-Core |
	  \/ 
    SUnit-Core-Kernel |
		     \/
		Classe abstraite-
		TestCase	 |
		|		\/
 		|	Sous-classes
 		| 	Groupe de tests |			   
 		|		       \/
 		|			Tests					    Méthode     Réponse (tearDown = méthode)
		|------>		suite test 1 ----> Création instance -----> setUp ----> tearDown	
		|------>		suite test 2 ----> Création instance -----> setUp ----> tearDown 
		|------>		suite test 3 ----> Création instance -----> setUp ----> tearDown 
		|------>		suite test etc --> Création instance -----> setUp ----> tearDown


Contexte spécifié							Spécialisation de la méthode
	\/									   \/
   [C)TestCase						     			(M)setUp
 subclass: #TestCase
instanceVariableNames: 'testSelector expectedFails' <- initialisation <--------
							(début, commencement)


Notes : 
-------
Le programme consulte la classe TestCase puis la méthode setUp qui va initialiser la variable d'instance.
Cela implique donc de partir puis de revenir.

"tearDown" n'est pas indiqué comme méthode, c'est par la suite que le lecteur le découvre.
Non, tearDown est disponible Figure 9-11. (oubli)

"Les sous-classes de TestCase peuvent également remplacer la méthode tearDown"

TestCase nombre de sous-classes : 
---------------------------------
Il y a 93 sous-classes de TestCase qui peuvent remplacer la méthode tearDown.
(Finder n'affiche pas de résultat "total de recherche", alors j'ai dû compter "toutes" les lignes)

Aller savoir qui fait quoi dans tout ce micmac ! 

D09:54 08/12/2020 - F12:30 - Chapitre 9 - p.126/259 FR 184/376 EN
-------------------------------------------------------------------------------------------------------08/12/2020 fin



-------------------------------------------------------------------------------------------------------09/12/2020 debut
D11:36 09/12/2020 - F00:00 - Chapitre 9 - p.126/259 FR 184/376 EN
- 28 mn - 10 mn
D11:36 09/12/2020 - F13:58 - Chapitre 9 - p.126/259 FR 186/376 EN

----------------------------------------------------------------------------------------
Packages		Classes		Sous-classes	Protocols	Methodes
----------------------------------------------------------------------------------------
(P)SUnit-Core		(C)TestAsserter	
			(C)TestCase
(P)SUnit-Core-Kernel	(C)TestAsserter	
							
			(C)TestCase	Groupe de tests (P)running	(M)\bleu/ setUp		sous-instances < TestCase		|
							(P)overridden						|
							(P)running	(M)\bleu/ tearDown			|
														|
			(C)TestSuite	Collection tests					sous-instances > TestSuit
			[C)TestResult								< représente les résultats d'une exécution TestSuite


---------------------------------------------------------------------------

"Il s'agit en fait d'une application du modèle composite dans lequel TestSuite est le composite et les cas de test sont les feuilles."
Il ne s'agit plus de code, de classe abstraite, ni d'objet vivant, mais de composite et de feuilles.
FORmidable ! 

explicite : 
Qui est énoncé de façon claire et ne permet aucun doute, aucune contestation, aucune interprétation. 

p.126/259 FR 185/376 EN
------------------------------------------------------------------------------------------------------

Sous-classé par ces classes de ressources

Classe abstraite- ?
TestResource	 |
|		\/
|	Sous-classes
| 	Groupe de tests |			   Effectuer setUp avant chaque test et tearDown ensuite
|		       \/			   contribue à renforcer l'indépendance des tests.
|			Tests					    Méthode     Méthode  
|------>		suite test 1 ----> Création instance -----> setUp ----> tearDown -> échec	
|------>		suite test 2 ----> Création instance -----> setUp ----> tearDown -> en cours...
|------>		suite test 3 ----> Création instance -----> setUp ----> tearDown -> en cours ..
|------>		suite test etc --> Création instance -----> setUp ----> tearDown -> échec


	TestResource subclass: #SimpleTestResource		-> current -> instance singleton
	TestResource subclass: #StdioStreamTestResource		-> current -> instance singleton
	TestResource subclass: #WithForkedProcessTestResource	-> current -> instance singleton
-------------------------------------------------------------------------------------------------------

* Objet - Singleton - Classe

"Cependant, il y a des occasions où la mise en place du contexte nécessaire prend trop de temps 
pour qu'elle soit effectuée avant l'exécution de chaque test."

Contexte spécifié							Spécialisation de la méthode
	\/									   \/
   [C)TestCase						     			(M)setUp
 subclass: #TestCase
instanceVariableNames: 'testSelector expectedFails' <- initialisation <--------
							(début, commencement)

Notes : 
------
Finder> TestResource> 3 sous-classes

"setUp et tearDown doivent être remplacées dans la sous-classe pour garantir que la ressource est initialisée et
finalisée."
C'est quoi cette histoire ! 
Avec tout ce qui a à faire, mémoriser et comprendre s'ajoute "le calendrier pense bête" pour penser à remplacer
des méthodes.
Qu'est-ce que c'est ce truc ? Franchement, c'est n'importe quoi.

Rappel :
--------
"une instance TestCase persiste uniquement pendant la durée d'un seul test (l'instance est à nouveau créée pour chaque méthode de test)"

"SUnit doit savoir quelles ressources sont associées à quelle suite de tests."
"SUnit doit savoir", de toute évidence ce n'est pas certain.

SUNIT
-----
"SUnit doit savoir quelles ressources sont associées à quelle suite de tests. Une ressource est associée 
à une sous-classe particulière de "TestCase" en remplaçant les "ressources" de la méthode de classe."

Exemple : (plus d'infos listing 9-12)
---------

(C)TestCase |
	   \/
	Ressource -> Sous-classe (particulière) -> (remplace) méthode de classe ressource
	     /\
(C)TestSuite |


Class
(C)TestCase
	   |
	  \/
	Sous-classe
	MyTestResource
		|
		\/
	Association
	MyTestCase (remplacer la méthode de classe MyTestCase class >> resources
								|
								\/
						Renvoie un tableau des classes de ressources de test
						que MyTestCase utilisera.

Notes : 
------
J'ai fait un schéma, car c'est incompréhensible. Pourquoi "s'emmerder" autant la vie ?
Je me concentre tellement à essayer de comprendre que je ne sais même plus l'intérêt au final.

D11:36 09/12/2020 - F13:58 - Chapitre 9 - p.126/259 FR 186/376 EN
-------------------------------------------------------------------------------------------------------09/12/2020 fin



-------------------------------------------------------------------------------------------------------10/12/2020 debut
D10:11 10/12/2020 - F00: - Chapitre 9 - p.126/259 FR 186/376 EN
D10:11 10/12/2020 - F12:36 - Chapitre 9 - p.127/259 FR 186/376 EN

10:53 10/12/2020
129. Chap.9 - p.127 FR 186 EN - Exercice
p.126/259 FR 185/376 EN
"Une variable globale fonctionnerait, mais utiliser trop de variables globales pollue l'espace de nom, 
et la liaison entre le global et les tests qui en dépendent ne sera pas explicite."

Explicite : 
Qui est énoncé de façon claire et ne permet aucun doute, aucune contestation, aucune interprétation. 

Exercice, la trace suivante (écrite dans la transcription) est contradictoire.
Indirectement ou par voie détournée, le lecteur est incité à utiliser une variable globale 
alors que dans la pratique c'est de limiter strictement son utilisation.
Dans ce cas, limiter strictement son utilisation ne veut rien dire.
Qui se limite à un carré de chocolat alors qu'on sait pertinemment qu'à un moment donné la limitation sera franchie.
En fin de compte, cela va à l'encontre du principe de précaution, car lorsqu'on observe ce problème alors on se l'interdit.
Donc, dans ce cas présent c'est un interdit limité. MDR ! 
Par conséquent contradictoire.
Comment limiter une erreur humaine alors que tu n'es pas conscient de faire cette erreur 
ou alors tu le sais, mais tu l'as fait quand même.

Par voie de conséquence, il y a des énoncés qui ne sont pas clairs et d'autres contradictoires.

Détourner:
"S’agit-il de détourner un homme d’une action dangereuse et imprudente ?
Claude Adrien Helvétius, De l’homme, de ses facultés intellectuelles et de son éducation, Gallica"


Rappels : 
---------

p.86 FR 125 EN
"si Pharo était implémenté à partir de zéro aujourd'hui, la plupart des variables globales qui ne sont pas 
des classes seraient remplacées par des singletons."

p.87 FR 125 EN
"La pratique recommandée est de limiter strictement l'utilisation de variables globales."
Tu sais qu'à chaque fois qu'une classe est créée, s'associe une variable globale, 
mais tu dois limiter "strictement" son utilisation.
Ce qui veut dire que si tu n'en utilises jamais (variable globale), alors tu vas perdre du temps 
à faire quelque chose pour cette variable.

11:12 10/12/2020
130. Chap.9 - p.127 FR 186 EN - Exercice My*
"Let’s see if you can obtain this trace yourself."
"Voyons si vous pouvez obtenir cette trace vous-même."

Est-ce que c'est fait exprès de mettre le lecteur en difficulté ou alors est-ce dû au fait que le déroulement
de l'exercice devrait se lire de bas en haut ?

Le contenu (déroulement) n'est pas cohérent que ce soit l'étape par étape ou cet exercice.
(122. Chap.9 - p.121 FR 178 EN - 9.4 SUnit par l'exemple
En décryptant le livret, je pense que le listing 9-1 est le package à créer.
Le système d'étape n'est pas au point.)

Exercice : (dernier contact avec transcript 20/07/20 )
----------

Transcript (Alt + T)>
(MyExampleSetTest class>>DoIt (empty is Undeclared))

Transcript (Alt + T)>MyTestResource >> setUp has run.
UndefinedObject>>DoIt (MyTestResource is Undeclared)

Transcript (Alt + T)>MyTestCase >> setUp has run.
UndefinedObject>>DoIt (MyTestCase is Undeclared)

11:30 10/12/2020 - 
131. Chap.9 - p.127 FR 186 EN - Exercice création
Alors, j'ai réussi à décrypter le contenu de ce livret et donc après l'exemple et l'exercice faussé avec "transcript".
Il faut créer de nouvelles classes.
Peut-être aurait-il fallu commencer par là, c'est comme remuer la pâte au chocolat avec ces doigts 
alors qu'il faut préparer les ustensiles et ensuite les utiliser. (gâteau fondant au chocolat)
TestOne on peut mettre une tonne de chose. Reste à savoir quoi mettre. :-(
Je fais quoi ?
Houla, 
WARNING ! 
"UndefinedObject" should not be redefined as its structure is known to the VM. 
Only proceed if you know what you are doing!

Select Proceed to continue, or close this window to cancel the operation.

D'accord, super ! :-(
Asm tram gram ! 
Peut-être une réponse à la suite de l'exercice. :?(

D10:11 10/12/2020 - F00: - Chapitre 9 - p.126/259 FR 186/376 EN
20/07/20 -> transcript
Comment voulez-vous que je me rappel ce qui a été fait en juillet ?
La solution je ne sais pas.

??????????????????????????
Au ptit bonheur ! 
Ca craint.
Je suis le déroulement du livret qui est incohérent.
Pfiiiiii ! 

Notes : Suite "Exercice création"
-----
Pharo debug D12:05 - F?-12:32
Gestionnaire des tâches - Pharo.exe "Pas de réponse" - Pharo Cog Spur Virtual Machine.

Je me pose la question à savoir : 
Est-ce que les exercices ont été exécutés puis validés ?
Ou alors.
Sont-ils simplement posés au petit bonheur la chance afin que le lecteur s’en dépêtre ?

Encore un exercice qui n'aura pas été fini.

D10:11 10/12/2020 - F12:36 - Chapitre 9 - p.127/259 FR 186/376 EN
-------------------------------------------------------------------------------------------------------10/12/2020 fin



-------------------------------------------------------------------------------------------------------11/12/2020 debut
D10:57 11/12/2020 - F - Chapitre 9 - p.127/259 FR 186/376 EN
-15mn
D10:57 11/12/2020 - F13:38 - Chapitre 9 - p.127/259 FR 186/376 EN

"Créez de nouvelles classes MyTestResource et MyTestCase qui sont respectivement 
des sous-classes de TestResource et TestCase. 
Ajoutez les méthodes appropriées afin que les messages xxxxxx"

SUnit-Core
	SUnit-Core-Kernel
		(C)TestResource
  		   (C)MyTestCase	resources "Listing 9-12" p.186 EN
					running	setUp	 (message : Check for methods that are equivalent to their superclass methods.)
					running	tearDown (message : Check for methods that are equivalent to their superclass methods.)
					tests	testOne
					tests	testTwo

  		   (C)MyTestResource	running	setUp	 (message : Check for methods that are equivalent to their superclass methods.)
					running	tearDown (message : Check for methods that are equivalent to their superclass methods.)


Notes : "Listing 9-1" p.178 EN
-----
Package :  MySetTest - Message "MyExampleSetTest" : 
A test class (subclass of TestCase) should be placed in a package with a '-Tests' suffix
Idem pour le package "ReleaseTests".

La question est de savoir pourquoi dans le livret l'exercice n'a pas consisté à créer le package "MySetTest"
avec le suffixe "-" ?

12:41 11/12/2020
J'ai renommé "MySetTest" en "MySet-Tests".


Transcript(ALT+T)>
MyExampleSetTest class>>DoIt (empty is Undeclared)	//Message à l'ouverture de transcript

"Run tests" des classes rattachés aux packages "ReleaseTests", résultats Transcript :

ClyClassWithUndeclares>>method2WithUndeclares (undeclaredStubInstVar2 is Undeclared)
ClyClassWithUndeclares>>method1WithUndeclares (undeclaredStubInstVar1 is Undeclared)
DTPluginConfiguration>>asTestSuite(testSuite is shadowed)
DrTestsTestRunnerTest>>testAllSelectedClassesAreTestCases(package is shadowed)
DrTestsTestRunnerTest>>testSelectedPackagesContainTestCases(package is shadowed)
MCFileTreeStCypressWriter class>>fileNameForSelector:(specials is shadowed)
OCASTTranslatorTest>>testExamplePrimitiveModuleError(method is shadowed)
OCASTTranslatorTest>>testExamplePrimitiveErrorModule(method is shadowed)
OCASTTranslatorTest>>testExamplePrimitiveErrorCodeModule(method is shadowed)
OCASTTranslatorTest>>testExamplePrimitiveErrorCode(method is shadowed)
OCASTVariableTranslatorTest>>testPushThisContext(method is shadowed)
PNGReadWriter>>writeChunk:(stream is shadowed)
OCStoreIntoReadOnlyVariableError: Cannot store into
RBAssignmentOnBlockArgumentRuleTest
sampleMethod
	"Assignment to blockArgument is bad - here x"

	| myBlock |
	myBlock := [ :x :y | 
	x := x + y.
	y := y + x ]
OCStoreIntoReadOnlyVariableError: Cannot store into
RBAssignmentOnBlockArgumentRuleTest
sampleMethod
	"Assignment to blockArgument is bad - here x"

	| myBlock |
	myBlock := [ :x :y | 
	x := x + y.
	y := y + x ]
RBDummyRefactoryTestDataApp>>tempVarOverridesInstVar(temporaryVariable is shadowed)
RBRefactoryTestDataApp>>tempVarOverridesInstVar(temporaryVariable is shadowed)
RBSmalllintTestObject>>tempVarOverridesInstVar(temporaryVariable is shadowed)
RBTempVarOverridesInstVarRuleTest>>sampleMethod:(dummy1 is shadowed)
RBTempVarOverridesInstVarRuleTest>>sampleMethod:(dummy2 is shadowed)
RBTempVarOverridesInstVarRuleTest>>sampleMethod:(dummy3 is shadowed)
String>>suffix (FileDirectory is Undeclared)
TextTest>>testAdjacentRunsWithIdentitcalAttributes(text is shadowed)
TextTest>>example1:(text is shadowed)
TextTest>>example2(text is shadowed)
VGTigerDemo>>convertPathData2(paths is shadowed)

Note : 
------
Trancript affiche des incohérences et des erreurs à la suite des runs tests des packages "ReleaseTests".
Je suis surpris !
Mais surtout, j'ai l'impression que ce n'est pas fiable et qu'il faut vérifier le code.
C'est rigolo : DrTestsTestRunnerTest (jamais deux cent trois : Test)
		 ---- ----      ----
		  1     2         3


13:07 11/12/2020
Transcript (ALT+T)>
UndefinedObject>>DoIt (setUp is Undeclared)
MyTestResource >> setUp has run.	//non ne pas mettre cette ligne

Transcript (ALT+T)>
MyTestCase >> setUp
Transcript show: 'MyTestCase>>setUp has run.'; cr

réponse : depuis Transcript(CTRL+P)
MyTestCase >> setUp
Transcript show: 'MyTestCase>>setUp has run.'; cr TranscriptMyTestCase>>setUp has run.

Autres solutions : 
----------------

1er cas :
--------
Playground(ALT+K)>
MyTestCase >> setUp
Transcript show: 'MyTestCase>>setUp has run.'; cr

réponse : Playground(CTRL+P)
MyTestCase >> setUp
Transcript show: 'MyTestCase>>setUp has run.'; cr Transcript


2e cas :
--------
Playground(ALT+K)>
MyTestCase >> setUp
Transcript show: 'MyTestCase>>setUp has run.'; cr

réponse : Playground(CTRL+I)
Ouvre la fenêtre "Inspector on a ThreadSafeTranscript (Transcript)
ligne "stepContents" -> 'MyTestCase>>setUp has run.'


3e cas : 
--------
Playground(ALT+K)>
Playground(CTRL+P)
MyTestCase >> tearDown
Transcript show: 'MyTestCase>>tearDown has run.'; cr Transcript

Transcript (ALT+T)> réponse : 
MyTestCase>>tearDown has run.


13:15 11/12/2020
Comme je l'ai, indiquer hier "xx l'exercice devrait se lire de bas en haut ?"
Je confirme qu'il faut lire la solution puis les exercices. De bas en haut. Mdr ! 
Sinon, tu ne comprends pas.

Exercice : résumer
1. La trace (c'est le retour d'une commande - MyTestResource >> setUp has run.),
2. Création des classes et des méthodes, (System Browser - les méthodes plus tôt flouent : contenues)
3. Solution. (Transcript - copier/coller code : MyTestCase >> setUp
						Transcript show: 'MyTestCase>>setUp has run.'; cr)

Notes :
-----
La méthode "resources", qu'elle soit présente ou pas il y a toujours un retour de la commande. 
({MyTestResource})

Dans solution le code "resource" à tester : 
MyTestCase class >> resources
^ Array with: MyTestResource

réponses : depuis playground ou transcript
MyTestCase class >> resources
^ Array with: MyTestResource {MyTestResource}


D10:57 11/12/2020 - F13:38 - Chapitre 9 - p.127/259 FR 186/376 EN
-------------------------------------------------------------------------------------------------------11/12/2020 fin



-------------------------------------------------------------------------------------------------------13/12/2020 debut
D12:43 13/12/2020 - F: - Chapitre 9 - p.127/259 FR 186/376 EN
D12:43 13/12/2020 - F13:40 - Chapitre 9 - p.127/259 FR 186/376 EN

Le programme Pharo ne s'ouvre pas directement comme à l'accoutumée, mais une fenêtre s'affiche et demande 
"Pharo virtual machine: Please select an image file...".


13:35 13/12/2020
133. Chap.9 - p.127 FR 186 EN - Exercice solution
Dans Transcript, pourquoi mettre ce code "MyTestCase >> setUp" ou "' ; cr" ?

MyTestCase >> setUp
Transcript show: 'MyTestCase>>setUp has run.'; cr

Alors que celui du dessous répond la même chose autrement dit "MyTestCase>>setUp has run.".
Transcript show: 'MyTestCase>>setUp has run.' TranscriptMyTestCase>>setUp has run.

Une erreur ? '.'

Transcript Do It(CTRL + D) ou Print It (CTRL + P).

1 Transcript show: 'MyTestCase>>setUp has run.' TranscriptMyTestCase>>setUp has run. 
2 Transcript show: 'MyTestCase>>setUp has run. ' TranscriptMyTestCase>>setUp has run.
3 Transcript show: 'MyTestCase>>setUp has run. ';cr TranscriptMyTestCase>>setUp has run.
4 Transcript show: 'MyTestCase>>setUp has run. '; crMyTestCase>>setUp has run. 

1 Transcript show: 'MyTestCase>>setUp has run.' Transcript MyTestCase>>setUp has run.

1 Transcript show: 'MyTestCase>>setUp has run'. TranscriptMyTestCase>>setUp has run

1 Transcript show: 'MyTestCase>>setUp'. Transcript MyTestCase>>setUp

1 Transcript 'show: MyTestCase>>setUp' has run. Transcript  End of statement list encountered ->'show: MyTestCase>>setUp' has run.

1 Transcript show: 'MyTestCase>>setUp has run.; Unmatched ' in string literal. ->
2 Transcript show: 'MyTestCase>>setUp has run. ; Unmatched ' in string literal. ->
3 Transcript show: 'MyTestCase>>setUp has run.cr  Unmatched ' in string literal. ->
4 Transcript show: 'MyTestCase>>setUp has run. cr  Unmatched ' in string literal. ->
    
1 Transcript show: 'MyTestCase>>setUp has run.'; Message expected ->
2 Transcript show: 'MyTestCase>>setUp has run. '; Message expected ->

1 Transcript show: 'MyTestCase>>setUp has run.'cr fenêtre> "Instance of ByteString did not understand #cr"
2 Transcript show: 'MyTestCase>>setUp has run.' cr fenêtre> "Instance of ByteString did not understand #cr"

1 Transcript show: 'MyTestCase>>setUp has run.;cr Unmatched ' in string literal. ->
2 Transcript show: 'MyTestCase>>setUp has run.; cr Unmatched ' in string literal. ->

1 Transcript show: MyTestCase>>setUp has run. UndefinedObject>>DoIt (setUp is Undeclared)

1 show: MyTestCase>>setUp. Variable or expression expected ->show: MyTestCase>>setUp.

D12:43 13/12/2020 - F13:40 - Chapitre 9 - p.127/259 FR 186/376 EN
-------------------------------------------------------------------------------------------------------13/12/2020 fin



-------------------------------------------------------------------------------------------------------14/12/2020 debut
D11:09 14/12/2020 - F - Chapitre 9 - p.127/259 FR 186/376 EN
D11:09 14/12/2020 - F13:02 - Chapitre 9 - p.128/259 FR 187/376 EN

Playground> Transcript show: 'MyTestCase>>setUp has run.' (CTRL + P)
réponses : 
Playground> Transcript show: 'MyTestCase>>setUp has run.' Transcript
Transcript> MyTestCase>>setUp has run.

9.7 SUnit
"SUnit contient des chaînes de description d'assertion" (String = chaine)


Chaînes de description d'assertion

Note : 
------
Comment tester le code ci-dessous ? Le manipuler ? L’objet vivant il est où ?

...
e := 42.
self assert: e = 23 description: 'expected 23, got ', e printString
...


Note : 
------
En plus d'être une sous-classe, une classe "TestAsserter" est un protocole d'assertion.

 Class		Protocol	Method
(C)TestAsserter	------------->  Un certain nombre de méthodes --------> description de l'assertion

				assert:description: "This method raises an AssertionFailure with aString as #messageText if aBooleanOrBlock evaluates to false.
				assert:description:resumable: "Assertion"
				assert:equals:			"Assertion"
				assertCollection:equals: 	"Assertion"
				etc..


assert:description:
-------------------
assert: aBooleanOrBlock description: aStringOrBlock
	"This method raises an AssertionFailure with aString as #messageText if
	 aBooleanOrBlock evaluates to false."					//Le guillemet était à la ligne.
	<debuggerCompleteToSender>
	self assert: aBooleanOrBlock description: aStringOrBlock resumable: false

deny:description:
-----------------
deny: aBooleanOrBlock description: aString
	"This method raises an AssertionFailure with aString as #messageText if
	 aBooleanOrBlock evaluates to true."
	self deny: aBooleanOrBlock description: aString resumable: false


should:description:
-------------------
should: aBlock description: aString
	self assert: aBlock value description: aString


shouldnt:description:
---------------------
shouldnt: aBlock description: aString
	self deny: aBlock value description: aString

Questions : 
-----------
Les deux derniers codes sont presque similaires tandis que les deux premiers ont plus de différences.
Pourquoi ne pas avoir mis "debuggerCompleteToSender" sur le second code ?
Pourquoi la description est-elle différente dans le premier code alors que dans les autres c'est équivalent ? (aString)
Pourquoi "resumable:" n'apparaît-il pas dans les deux derniers codes ?
Pourquoi dans les deux premiers codes est-ce "aBooleanOrBlock" alors que les autres c'est "aBlock" ?
Pourquoi le code n'est-il pas vivant (Objet vivant) et ne peut-on pas le manipuler ?


assert:equals:
--------------
assert: actual equals: expected
	"This method raises an AssertionFailure if actual is different (using #= message) from expected.
	 Else it does nothing and execution continues.				//Le guillement est à la ligne x2.
	"
	
	^ self
		assert: actual = expected
		description: [self comparingStringBetween: actual and: expected]

Note : 
------
(accessoirement, assert: equals: utilise assert: description:)
Dans le code rien ne m'indique qu'accessoirement "assert: equals: utilise "assert: description:".


assert:equals:
--------------
"nous supposons que aDateAndTime est une variable d'instance de la classe de test."
Ce n'est pas clair.

Donc en résumé, il faut chercher "testAsdate" au lieu "aDateAndTime" car "Finder" ne trouve pas.
Alors s'affichera "TestaDateAndTime" en plus de "testAsdate".
Du coup, il y a plusieurs autres possibilités comme indiqués en dessous des codes "testAsDate".

testAsDate
self assert: aDateAndTime asDate = ('February 29, 2004' asDate translateTo: 2 hours).

testAsDate
self assert: aDateAndTime asDate equals: ('February 29, 2004' asDate translateTo: 2 hours).

Autres possibilités :
--------------------
 
DateAndTimeDosEpochTest ------------------------------------------------------>----------------->-------
testAsDate												|
self assert: aDateAndTime asDate equals: 'January 1, 1980' asDate ------------>----------------->-------|
													|
DateAndTimeLeapTest		//Un espace supplémentaire avant la parenthèse)				|
testAsDate												|
self assert: aDateAndTime asDate equals:  ('February 29, 2004' asDate translateTo: 2 hours).		|
													|
DateTest												|
testAsDate												|
self assert: january23rd2004 asDate equals: january23rd2004.						|
													|
StringTest												|
testAsDate												|
self assert: 'Jan 1 2015' asDate asString equals: '1 January 2015'. 					|
self assert: '1/1/2015' asDate asString equals: '1 January 2015'.					|
self assert: '1 1 1' asDate asString equals: '1 January 2001'.						|
self assert: '1 J 1' asDate asString equals: '1 January 2001'.						|
self should: [ '' asDate ] raise: Error.								|
self should: [ '1234' asDate ] raise: Error 								|
													|
TimeTest												|
testAsDate												|
self assert: aTime asDate equals: Date current								|
													|
TimespanTest												|
testAsDate												|
self assert: aTimespan asDate equals: jan01 asDate							|
"MessageNotUnderstood: Date class>>starting:"								|
													|
DateAndTimeDosEpochTest	------------------------------------------------------<-------------------<-----|										|
testAsDateAndTime											|
self assert: aDateAndTime asDateAndTime equals: aDateAndTime -----------------<-------------------<-----

D11:09 14/12/2020 - F13:02 - Chapitre 9 - p.128/259 FR 187/376 EN
-------------------------------------------------------------------------------------------------------14/12/2020 fin



-------------------------------------------------------------------------------------------------------17/12/2020 debut
D11:15 17/12/2020 - F: - Chapitre 9 - p.128/259 FR 187/376 EN
D11:15 17/12/2020 - F13:36 - Chapitre 9 - p.129/259 FR 189/376 EN

Notes : 
------

1 self
Dans le cas où je commencerais un code, celui-ci commencerais avec les lettres ci-dessous : 
f=false, n=nil, s=self, super, t=thisContext, true.

2 assert:
Si je commence par "self" et continue avec le second mot "assert:" alors quelles sont les autres propositions ?
Presque toutes les lettres de l'alphabet contenant une liste plus ou moins impressionnante de choix.

testAsDate
self assert: aDateAndTime asDate equals: ('February 29, 2004' asDate translateTo: 2 hours).

3 aDateAndTime
En troisième position et derrière "assert:" quels sont les choix ?
Avec les lettres minuscules : 
f=false, n=nil, s=self, super, t=thisContext, true.
Tandis qu'avec les lettres majuscules, toutes les lettres de l'alphabet sont disponibles avec des choix.
Quant à "aDateAndTime", aucune proposition (aDateAndTime is Undeclared). Alors peut-on se fier à ce programme ?

Recherche : 
-----------

Finder> (selectors) isLogging
	(Browse>
SUnitExtensionsTest		//C'est une classe
TestCase subclass: #SUnitExtensionsTest
	instanceVariableNames: 'stream'
	classVariableNames: ''
	package: 'SUnit-Tests-Core'

TestAsserter class		//C'est une classe mais pas de "_" ? dans le volet classe s'affiche "TestAsserter"
SUnit-Core-Kernel		//N'affiche aucun package ?
TestAsserter class
	instanceVariableNames: ''

TestCase			//C'est une classe
TestAsserter subclass: #TestCase
	instanceVariableNames: 'testSelector expectedFails'
	classVariableNames: 'Announcers DefaultTimeLimit HistoryAnnouncer'
	package: 'SUnit-Core-Kernel'

Note : 
------
Ci-dessus ce sont 3 classes, mais : 
La 1re, ce nomme "SUnitExtensionsTest" sans "class" dans "Finder" et  n'a pas de symbole (C) dans le volet classe et porte le même nom,
La 2e, ce nomme "TestAsserter class" dans "Finder" et dans le volet classe a le symbole (C) et porte le nom "TestAsserter",
tandis que l'onglet s'appelle "TestAsserter class".
La 3e, ce nomme "TestCase" sans "class" dans "Finder" et a le symbole (C) ainsi que le même nom.


12:14 17/12/2020
134. Chap.9 - p.127 FR 188 EN - Prise en charge de la journalisation - Logging support
"dans un flux"
"Vous pouvez choisir de vous connecter en remplaçant isLogging dans votre classe de test"
"vous devez également choisir où vous connecter en  remplaçant failureLog  pour répondre à un flux approprié"
Ou est-il l'exemple concret ? L’objet vivant ? le flux ? 
Remplacer isLogging -> ^true et ^false, mis à part ça ? (d'emmerde de toi)
Tiens, deux, trois clés et débrouille-toi.
?

Note : 
------
Sauter les tests - Skipping tests
Dans ce paragraphe, il y a un exemple contrairement à celui du dessus. (logging support)
C'est le jour et la nuit.

Recherches : 
-----------

Finder> (classes) OCCompiledMethodIntegrityTest

testBlocvkTemps
testNotUsedArgument
testPragmas
testPrimitive
testRemoteTempInVector
testUndeclaredVariable


Code OCCompiledMethodIntegrityTest :
-----------------------------------

TestCase subclass: #OCCompiledMethodIntegrityTest
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'OpalCompiler-Tests-Misc'
This class contains tests


Finder> (selectors) testPragmas

OCCompiledMethodIntegrityTest
RBParserTest

(Smalltalk globals hasClassNamed: #Compiler)
"Compiler" existe en tant que "selectors", mais pas en tant que "classes" alors qu'il s'agit de "hasClassNamed" ?
Finder> (selectors) Compiler
Finder> (classes) Compiler

Finder> (source)  #Compiler
compilerSettingsOn:
	AbstractComplier class

dependencies
	ManifestKernel class

evaluate:
	ZnReadEvalPrintDelegate


9.8 Continuer après une panne - Continuing after a failure

Note : 
------
Au début du livret, le code pouvait être testé, alors que plus le lecteur avance dans les chapitres et plus il est 
impossible de tester le code ou alors il manque des classes et/ou des méthodes.

Playground> Print it (CTRL+P) ou Dot it (CTRL+D)> Unknown variable: Continuing please correct, or cancel:
aCollection do: [ :each | self assert: each even ]

Transcript> Print it (CTRL+P) ou Dot it (CTRL+D)> Unknown variable: Continuing please correct, or cancel:
aCollection do: [ :each | self assert: each even ]

Recherche : 
----------

Note : 
------
Une liste impressionnante s'affiche lors de la recherche "aCollection".
Néanmoins s'arrête et affiche la dernière ligne. (?)

Finder> (source) aCollection
????????
	Collection
| aCollection
	"Return all the elements that appear in self or in aCollection"
	"'abc' | 'cbe' >>> 'bcea'"
	
	^ self union: aCollection

9.9 Implémentation SUnit

Notes : Figure 9-13
-----
Je ne comprends rien à ce schéma, il n'est pas clair.
Du côté du petit bonhomme de quel "run" s'agit-il ? (Classe, méthode ?)
Sous le petit bonhomme, s'agit'-il du clavier ? 

Pour la prochaine fois, faire un schéma en se basant sur les classes et les méthodes dans Pharo, pour essayer
de comprendre ce qui est indiqué dans la figure 9-13.

D11:15 17/12/2020 - F13:36 - Chapitre 9 - p.129/259 FR 189/376 EN
-------------------------------------------------------------------------------------------------------17/12/2020 fin



-------------------------------------------------------------------------------------------------------18/12/2020 debut
D11:10 18/12/2020 - F: - Chapitre 9 - p.129/259 FR 189/376 EN
D11:10 18/12/2020 - F13:51 - Chapitre 9 - p.129/259 FR 189/376 EN

interruption 20mn

Playground (CTRL+O+W)> ProfStef go
Transcript (CTRL+O+T)> ProfStef go
ProfStef next. (CTRL+D) leçon suivante)
ProfStef previous. (CTRL+D) leçon précédente - antérieur)

Comparaison du code : 
---------------------

1
aCollection do: [ :each | self assert: each even ]

2
aCollection do: [ :each | self assert: each even description: each printString, ' is not even' resumable: true ]

Pourquoi les crochets ? [ ]
Pourquoi mettre ":each" alors qu’"each" est présent sans les ":" ?
Pourquoi le 1er guillemet a un espace alors que le second non ? (' is not even') 
Pourquoi mettre les guillemets sur "is not even" au lieu de "each printString, is not even" ?


Test code : 
----------- 

Transcript (CTRL+O+T)> aCollection xxxx (CTRL+D) ou (CTRL+P)> Unknown variable: aCollection please correct, or cancel:
										Declare new temporary variable
										Declare new instance variable
										Cancel
Playground (CTRL+O+W)> aCollection xxxx (CTRL+D) ou (CTRL+P)> #aCollection is missing, and does not understand #do:
Transcrypt message : UndefinedObject>>DoIt (aCollection is Undeclared)

"Toutes les autres méthodes d'assertion que nous avons vues ne peuvent pas être reprises par défaut; 
assert: p description: s équivaut à assert: p description: s resumable: false."

Aucune reprise, encore un cadeau-surprise.
Pourquoi la reprise n'est-elle pas possible alors que l'objet est vivant ?

Faire un schéma décrypté de la figure 9-13

D11:10 18/12/2020 - F13:51 - Chapitre 9 - p.129/259 FR 189/376 EN
--------------------------------------------------------------------------------------------------------18/12/2020 fin



-------------------------------------------------------------------------------------------------------19/12/2020 debut
D09:41 19/12/2020 - F: - Chapitre 9 - p.129/259 FR 189/376 EN
- 15 mn - 10 mn
D09:41 19/12/2020 - F13:44 - Chapitre 9 - p.129/259 FR 189/376 EN

1er Comparaison entre la Figure 9-13 et les codes Pharo
--------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Packages				Sous-classes			Classes				Protocoles 	Méthodes	Descriptions
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SUnit-Core-Kernel TestAsserter		#TestCase			:TesCase (C)ou# ?		running		run:		>-1-->-- demande le résultat de "runCase:" se trouvant de "(C)TestResult"
 										 				   							   \/1
 										 				    							    |
 								 				    									    |
SUnit-Core-Kernel Object		#TestResult			(C)TestResult			running		runCase:	<-1---------------------------------|1
SUnit-Core-Kernel Object		#TestResult			(C)TestResult			running		runCase:	>-2-->-- aTestCase annonce TestCase démarré et "runCaseManaged" puis l'arrêt avec résultats pannes, sauter, avertissement, erreur							|			
																								\/2
																								|
SUnit-Core-Kernel TestAsserter		#TestCase			(C)TestCase			running		runCaseManaged	<-2----<------------------------------------------------|2		
SUnit-Core-Kernel TestAsserter		#TestCase			(C)TestCase			running		runCaseManaged	>-3----- runTestCase:
Kernel-Processes  ProcessLocalVariable #CurrentExecutionEnvironment 	(C)CurrentExecutionEnvironment	accessing	default
													inheriting	installValue:intoForked:from:
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Questions : Figure 9-13
-----------

Il y a "run" du côté du bonhomme, mais il s'agit duquel ? Où le situer dans Pharo ?

  O
 -|-
 / \
  |
  |___run_?______
  |
  ?

Pourquoi ":TesCase" alors qu'il s'agit d'une classe et d'une sous-classe symbolisées par (C) ou # au lieu de ":"?
Est-ce que c'est pour perturber encore plus le lecteur ? ":TesCase"
En comparant le contenu de la "figure 9-13" aux différents codes de Pharo alors je constate une différence.

La figure 9-13 indique "runCase:" entrant dans ":TestResult" puis "runCase" sortant alors qu'il n'existe pas dans ":TestResult".

Note : 
------
Depuis "System browser" volet "package" touches claviers "CTRL+F", la recherche de "(C)CurrentExecutionEnvironment" est rapide, mais celle de retour vers "(C)TestCase" est aventureux.
Le "Filtre" de "Choose class", m'indique "(C)ClassTestCase" (package: 'SUnit-Core-Utilities') au lieu de "(C)TestCase" (package: 'SUnit-Core-Kernel') alors qu'il y a une différence en un "C" et un "T".

2e Comparaison entre la Figure 9-13 et les codes Pharo
--------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Packages			Sous-classes	Classes		Protocoles   Méthodes			Descriptions
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     run			>-1---->-- résultats "TestResult" "runCase:", annonce "TestResource" "resources"
SUnit-Core-Kernel Object	#TestResult	(C)TestResult	running	     runCase:			<-1.1--<------------------------------<|1.1		   |1.2		|1.3
SUnit-Core-Kernel TestAsserter	#TestResource	(C)TestResource	accessing    resources			<-1.2--<--------------------------------------------------<|		|
SUnit-Core-Kernel TestAsserter	#TestResource	(C)TestResource	accessing    resources			>-1.3-->-- class resources ?------------------------------------------->|		

SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     run:			>-2---->-- résultats "runCase:" ou "runCase" ?
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     runCase			<-2.1--<------------------------------<|2.1
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     runCase			>-2.2-->-- self resources, setUp, performTest -- anonce tearDown, CleanUpInstanceVariables			
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	accessing    resources			<-2.3--<-----------<|2.3   \|2.4       \|2.5		    \|2.6	       \|2.7
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	accessing    resources			>-2.3-->-- class resources ?|		|		     |		     	|
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     setUp			<-2.4--<-------------------<|		|		     |		     	|
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     setUp			>-2.4-->-- "Hooks that subclasses xxxx"	|		     |		     	|
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	private	     perfomTest			<-2.5--<-------------------------------<|		     |		     	|
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	private	     perfomTest			>-2.5-->-- self perform: testSelector asSymbol		     |		     	|
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     setUp			<-2.6--<----------------------------------------------------<|		     	|
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     setUp			>-2.6-->-- "Hooks that subclasses xxxx"						|
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	private	     CleanUpInstanceVariables	<-2.7--<-----------------------------------------------------------------------<|
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	private	     CleanUpInstanceVariables	>-2.7-->-- class allInstVarNames do: (il ne s'agit pas d'une classe = allInstVarNames)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

D09:41 19/12/2020 - F13:44 - Chapitre 9 - p.129/259 FR 189/376 EN
-------------------------------------------------------------------------------------------------------19/12/2020 fin



-------------------------------------------------------------------------------------------------------21/12/2020 debut
D11:13 21/12/2020 - F: - Chapitre 9 - p.129/259 FR 189/376 EN
D11:13 21/12/2020 - F13:35 - Chapitre 9 - p.129/259 FR 189/376 EN

Vérifications, corrections, compréhensions. 

2e Comparaison entre la Figure 9-13 et les codes Pharo
--------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Packages			Sous-classes	Classes		Protocoles   Méthodes			Descriptions - Q=Question - R=Réponse
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     run			>-1Q---->-- résultats "TestResult" "runCase:", annonce "TestResource" "resources"
SUnit-Core-Kernel Object	#TestResult	(C)TestResult	running	     runCase:			<-1.1Q--<------------------------------<|1.1		   \|1.2	       
SUnit-Core-Kernel Object	#TestResult	(C)TestResult	running	     runCase:			>-1.1R-->-- aTestCase annonce "TestCase" démarré et ----->  | --------> "runCaseManaged", "TestCase" arrêt -> résultats pannes, sauter, avertissement, erreur.
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TestCase	running	     runCaseManaged		<-1.5Q--<------------------------<|1.5			    |		
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TestCase	running	     runCaseManaged		>-1.5R-->-- CurrentExecutionEnvironment runTestCase: self   |		
SUnit-Core-Kernel TestAsserter	#TestResource	(C)TestResource	accessing    resources			<-1.2Q--<--------------------------------------------------<|1.2		
SUnit-Core-Kernel TestAsserter	#TestResource	(C)TestResource	accessing    resources			>-1.2R-->-- ^self class resources ?		

SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     run:			>-2Q---->-- résultats "runCase:" ou "runCase" ?
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     runCase			<-2.1Q--<------------------------------<|2.1
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     runCase			>-2.1R-->-- self resources, setUp, performTest -- anonce tearDown, CleanUpInstanceVariables			
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	accessing    resources			<-2.2Q--<-----------<|2.2    \|2.3       \|2.4		     \|2.5	        \|2.6
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	accessing    resources			>-2.2R-->-- class resources ? |		  |		      |		     	 |
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     setUp			<-2.3Q--<--------------------<|2.3	  |		      |		     	 |
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     setUp			>-2.3R-->-- "Hooks that subclasses xxxx"  |		      |		     	 |
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	private	     perfomTest			<-2.4Q--<--------------------------------<|2.4		      |		     	 |
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	private	     perfomTest			>-2.4R-->-- self perform: testSelector asSymbol		      |		     	 |
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     setUp			<-2.5Q--<----------------------------------------------------<|2.5		 |
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	running	     setUp			>-2.5R-->-- "Hooks that subclasses xxxx"					 |
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	private	     CleanUpInstanceVariables	<-2.6Q--<-----------------------------------------------------------------------<|2.6
SUnit-Core-Kernel TestAsserter	#TestCase	(C)TesCase	private	     CleanUpInstanceVariables	>-2.6R-->-- class allInstVarNames do: (il ne s'agit pas d'une classe = allInstVarNames)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

TestCase
instanceVariableNames: 'testSelector expectedFails'
	classVariableNames: 'Announcers DefaultTimeLimit HistoryAnnouncer'

TestResource
instanceVariableNames: 'name description'
	classVariableNames: ''

TestResult 
instanceVariableNames: 'timeStamp failures errors passed skipped'
	classVariableNames: ''


12:06 21/12/2020
Autre schéma plus simple ?
-------------------------------------------------------
(C)TesCase	running	     run 
				\----> (C)TestResult (M)runCase: self (runCase: ou runCase ?) - assurer TestResource resetResources: resources	
				 	    		\ 						     \---> (C)TestResource resetResources: ? (M)resources ----> class resources ? (classe resources inconnue)
					     		 \
					      		  \----> runCase: aTestCase ? (C)TestCaseStarted (M)runCaseManaged, class failure (TestTailure) ?, class skip (TestSkip) ?, class warning (Warning) ?, classe error (Error) ? (symboles et noms ?)
				  										\		\			       \						   \----> Exception subclass: #Error - (M)defaultAction, (M)isResumable, (M)sunitAnnonce:toResult:
													 	 \		 \				\----> Exception subclass: #TestSkip - (M)defaultAction, (M)sunitAnnonce:toResult:
													  	  \ 		  \
													   	   \		   \----> Exception subclass: #TestFailure - (M)defaultAction, (M)isResumable, (M)sunitAnnonce:toResult:
													    	    \---->runCaseManaged CurrentExecutionEnvironment runTestCase:
(C)TesCase	running	     run: 
				 \----> aResult (TestResult ?)	(M)runCase: self (runCase: ou runCase ?)
									\
									 \----> runCase  (M)resources  (M)setUp  (M)performTest	 (M)tearDown  (M)cleanUpInstanceVariables
					   						 	\    	  \		\		\		\class allInstVarNames do:
												 \	   \		 \		 \"Hooksxxxx"
												  \	    \		  \perform: testselector asSymbol  
												   \	     \"Hooksxxxx"   
												    \class resources      


Questions : 
-----------

Pourquoi "resetResources" au lieu de "resetresources" ?
Pourquoi "runCase: aTestCase" au lieu de "runCase: TestCase" ?
Pourquoi "run: aResult" au lieu de "run: TestResult" ainsi que "aResult runCase:" au lieu de "TestResult runCase:" ?
Pourquoi jouer à la devinette en mettant "aResult runCase:" qui n'est pas une classe, mais finalement rattacher à la classe "(C)TestResult runCase:" ?

De mon point de vue le lecteur ne sait pas sur quel pied danser puisqu'en prenant l'exemple de "do:", 
l'on sait qu'après les deux points une boucle est effectuée tandis que "runCase" ou "runCase:", 
le lecteur doit fournir un effort pour décrypter ce dont il s'agit.
La Figure 9-13, montre l'exécution de "run:" puis de "runCase:", c'est contradictoire avec 
la méthode "runCase" située dans la classe "TestCase".
Donc ensuite c'est de l'interprétation hypothétique à savoir que le code "run:" a une liaison 
avec la classe "TestResult" et la méthode "runCase:" alors qu'il s'agit de "aResult", 
mais étant donné que "self est le résultat de "runCase:" alors je suis en droit de penser 
qu'il y a une incohérence et pourtant ça à l'air de fonctionner. Mais comment ? 
Puisque c'est incompréhensible. 
C'est comme "resetResources: self resources", "Resources:" en majuscule, avec les deux points n'existe pas.

L'exécution de "aResult" est-elle similaire à "TestResult" ? Hasardeux, dénué de sens.


Note : 
-----
Il y a la variable "result", l'exécution "aResult" et la classe "TestResult".
L'exécution de "aResult" est-il similaire à "TestResult" ? Hasardeux, dénué de sens.

D11:13 21/12/2020 - F13:35 - Chapitre 9 - p.129/259 FR 189/376 EN
-------------------------------------------------------------------------------------------------------21/12/2020 fin



-------------------------------------------------------------------------------------------------------22/12/2020 debut
D12:43 22/12/2020 - F: - Chapitre 9 - p.129/259 FR 189/376 EN
D12:43 22/12/2020 - F13:22 - Chapitre 9 - p.129/259 FR 189/376 EN

Mise à jour
Autre schéma plus simple ?
-------------------------------------------------------
(C)TesCase	running	     run 
				\----> (C)TestResult (M)runCase: self (runCase: ou runCase ?) - assurer TestResource resetResources: resources	
				 	    		\ 						     \---> (C)TestResource resetResources: ? (M)resources ----> class resources ? (classe resources inconnue)
					     		 \
					      		  \----> runCase: aTestCase ? (C)TestCaseStarted (M)runCaseManaged, class failure (TestTailure) ?, class skip (TestSkip) ?, class warning (Warning) ?, classe error (Error) ? (symboles et noms ?)
				  										\		\			       \						   \----> Exception subclass: #Error - (M)defaultAction, (M)isResumable, (M)sunitAnnonce:toResult:
													 	 \		 \				\----> Exception subclass: #TestSkip - (M)defaultAction, (M)sunitAnnonce:toResult:
													  	  \ 		  \
													   	   \		   \----> Exception subclass: #TestFailure - (M)defaultAction, (M)isResumable, (M)sunitAnnonce:toResult:
													    	    \---->runCaseManaged CurrentExecutionEnvironment runTestCase:
(C)TesCase	running	     run: 
				 \----> aResult (TestResult ?)	(M)runCase: self (runCase: ou runCase ?)
									\
									 \----> runCase  (M)resources  (M)setUp  (M)performTest	 (M)tearDown  (M)cleanUpInstanceVariables
					   						 	\    	  \		\		\		\class allInstVarNames do:
												 \	   \		 \		 \"Hooksxxxx"
												  \	    \		  \perform: testselector asSymbol  
												   \	     \"Hooksxxxx"   
												    \class resources      

D12:43 22/12/2020 - F13:22 - Chapitre 9 - p.129/259 FR 189/376 EN
-------------------------------------------------------------------------------------------------------22/12/2020 fin



-------------------------------------------------------------------------------------------------------24/12/2020 debut
D11:08 24/12/2020 - F: - Chapitre 9 - p.129/259 FR 189/376 EN
D11:08 24/12/2020 - F13:13 - Chapitre 9 - p.131/259 FR 192/376 EN

Listing 9-14 Passer le cas de test au résultat du test
Playground (CTRL+O+W)>
TestCase >> run: aResult> Do it (CTRL+D) ou Print it (CTRL+P) = Variable or expression expected
aResult runCase: self> Do it (CTRL+D) ou Print it (CTRL+P) = #aResult is missing and does not understand #runCase:

Note : 
------
Le listing 9-14, je ne peux que regarder les erreurs s'afficher.
Le soi-disant objet vivant ne peut même pas être manipulé, compris, exploité.

9.9 SUnit implementation

Playground (CTRL+O+W)>
TestCase >> run
| result |
result := self classForTestResult new.
[ self run: result ]
ensure: [ self classForTestResource resetResources: self
resources ].
^ result> Print it (CTRL+P) = nil

Playground (CTRL+O+W)>
TestCase >> run> Print it (CTRL+P) = KeyNotFound: key nil not found in MethodDictionary

Playground (CTRL+O+W)>
TestResult >> runCase: aTestCase> Print it (CTRL+P) = Variable or expression expected

Playground (CTRL+O+W)>
TestCase class >> testSelectors> Print it (CTRL+P) = KeyNotFound: key nil not found in MethodDictionary

Playground (CTRL+O+W)>
TestCase >> runCase> Print it (CTRL+P) = KeyNotFound: key nil not found in MethodDictionary

Note : 
------
"The expression MyTestCase build-SuiteFromSelectors returns a suite containing all the tests defined in the MyTestCase class. 
The core of this process is:"
"L'expression MyTestCase build-SuiteFromSelectors renvoie une suite contenant tous les tests définis dans la classe MyTestCase. 
Le cœur de ce processus est:"
Là, je suis perdu.

"TestSuite qui contient les tests pertinents."
Donc, il doit y avoir des tests "non pertinents" ? (hors de propos, inopportun, mal venu)

Note : 
------
À ce niveau de lecture, je suis blasé par les tests précédents qui m'apprennent seulement combien 
le chemin est tortueux et parfois incompréhensible.
Au final, ça fonctionne, mais je ne sais toujours pas comment ces soi-disant objets vivants fonctionnent ou interagissent.
Je suis frustré de toutes ces erreurs.

Notes : 
------
1.
p. 130 FR 191 EN.
C'est bien beau toutes ces explications, mais moi je veux voir concrètement ce que ça donne.
EN
"The class TestResource and its subclasses keep track of their currently created singleton instances 
that can be accessed and created using the class method TestResource class >> current. 
This instance is cleared when the tests have finished running and the resources are reset."
FR
"La classe TestResource et ses sous-classes gardent une trace de leurs instances de singleton actuellement créées
qui peuvent être accédées et créées à l'aide de la méthode de  classe TestResource class >> current . 
Cette instance est effacée lorsque les tests sont terminés et que les ressources sont réinitialisées."

2.
p. 130 FR 191 EN.
9.10 A piece of advives on testing - Un conseil sur les tests
Encore un conseil sur les tests.

3.
p. 130 FR 191 EN.
MDR !
Ça, c'est la meilleure.
"While the mechanics of testing are easy,"
"Bien que la mécanique des tests soit facile,"
Les flèches de direction haut, bas, droite et gauche et le clic de souris pour tirer, ça s'est facile.
Tandis que les tests précédents interagissent avec des classes, sous-classes, packages, méthodes, protocoles, codes et autres tests.
C'est tellement emmêlé qu'au fur et à mesure, je ne cherche même plus à savoir qui fait quoi dans ce méli-mélo.

4.
p. 131 FR 192 EN.
"l'écriture de bons tests ne l'est pas."
"writing good tests is not."
J'aimerais bien savoir à quel niveau sont situés les tests précédents.
Peut-être faudrait-il repenser tout le concept.

5.
p. 131 FR 192 EN.
Listing 9-18, si ça, ce n’est pas du code accompagné d'un chapitre littéraire alors les poules auront des dents.

6.
p. 131 FR 192 EN.
Tout ce méli-mélo en plus d'être incompréhensible.
Du concret, y'en a marre du blabla. 
"dans un test dont la classe de cas de test a la classe de ressources dans ses #ressources"

7.
p. 131 FR 192 EN.
"Try to build your tests so that they do not overlap."
"Essayez de construire vos tests de manière à ce qu'ils ne se chevauchent pas."
Cette remarque est pertinente parce que justement il y a un problème de conception.
Ces récents paragraphes ne m'ont rien appris de plus pour coder des tests.
Créer un test, je ne sais pas. 
Autrement dit, "écrire un code pour faire un test, je ne sais pas".
Tout ce que j'ai su faire ce sont des schémas pour essayer de comprendre tous ces enchevêtrements tortueux et parfois incompréhensibles.

8.
p. 131 FR 192 EN.
"It is annoying to have many tests covering the same functionality,"
"Il est ennuyeux d'avoir de nombreux tests couvrant la même fonctionnalité,"
À mon avis, ce n'est pas restreint aux tests, mais également aux packages contenant des classes, sous-classes, méthodes, protocoles, 
méthodes ainsi que des "non-classes " (dans le volet classe, certaines n'ont pas le symbole (C)).
Ou bien dans le code, apparais "class xxxx", alors le lecteur découvre qu'elle n'existe pas 
et c'est comme pour ainsi dire envoyer de la poudre aux yeux.

9.
p. 131 FR 192 EN.
"because one bug in the code will then break many tests at the same time."
"car un bogue dans le code interrompra alors plusieurs tests en même temps."
C'est amusant, car plus le lecteur avance dans ce livret et plus l'objet disparait pour laisser place au code.

10.
p. 131 FR 192 EN.
"Black’s rule, below."
"la règle de Black, below."
Qu'est-ce que c'est déjà cette règle ?
1er Recherche dans le livret : rien n'a été trouvé
(black, below, black's, black rule, rule black)
2e Recherche dans le livret : Black's Rule
(Black’s rule -> p. 193)
Il n'y a aucun lien pour mettre le lecteur sur le chemin.
Par contre, ça apparait à la prochaine page comme tout ce qui a été présenté jusqu'à maintenant.

11.
p. 131 FR 192 EN.
"it is important to be able to separate them from true unit tests"
"il est important de pouvoir les séparer des vrais tests unitaires"
Donc en résumé, il y a des vrais tests et des faux. (:-)
Je lance la pierre, mais il va y avoir des faux tests ou peut-être bien des vrais tests pour les packages, objets, super-classe, classe, sous-classe, protocoles, méthodes,
métaclasses, classes abstraites, variables d'instance, variables non déclarés, variables partagées, variables non partagées globales 
etc..........................................................................................................................
ligne 7272
D11:08 24/12/2020 - F13:13 - Chapitre 9 - p.131/259 FR 192/376 EN
-------------------------------------------------------------------------------------------------------24/12/2020 fin



-------------------------------------------------------------------------------------------------------31/12/2020 debut
D09:16 31/12/2020 - F: - Chapitre 9 - p.131/259 FR 192/376 EN
10:20 pause incident reprise 12:07
D09:16 31/12/2020 - F12:52 - Chapitre 10 - p.133/259 FR 196/376 EN

12.
p. 131 FR 192 EN.
"These are called acceptance tests (or integration tests, or functional tests)."
"Ceux-ci sont appelés tests d'ac-ceptance (ou tests d'intégration, ou tests fonctionnels)."
Bingo !
Comme cité en 11. 
Donc, il y a effectivement des tests d'acceptantes, d'intégrations, fonctionnels, que sais-je encore.

Contradictoire.
"Tests that break Feathers’ rules may make good acceptance tests."
"Les tests qui enfreignent les règles de Feathers peuvent constituer de bons tests d'acceptation."

Certains tests d'acceptantes doivent être séparés des vrais tests unitaires.
Ainsi que des faux. :-)

p. 132 FR 193 EN.
"Donc, ayez une propriété en tête lorsque vous écrivez un test."
"So, have a property in mind when you write a test."

Note : 
------
Le résumer du chapitre a permis de définir quelques tests pour la classe Set.
Avec le temps qui passe, je ne sais même plus à quoi ça ressemble ces tests.
Sinon il ne m'est pas possible de faire une représentation mentale de ces tests ou ces objets ou bien ces codes.


p. 132 FR 195 EN
Chapitre 10 - Cours de base - basic classes (des classes simple)

10:20 31/12/2020 - fin 12:24 31/12/2020
135. Chap.10 - p. 132 FR 195 EN - Basic classes
"Pharo est un langage vraiment simple mais puissant."
"Pharo is a really simple language but powerful language."
Jusqu'à maintenant, je n'ai rien vu du langage simple et puissant.
Le langage est tellement simple et puissant que je n'ai pas réussi à faire fonctionner le jeu "The Lights Out game".
Tandis que les tests c'est tout simplement impossible d'en réaliser malgré un langage simple et puissant.
Est-ce que j'ai pu jouer à "The Lights Out game" ? Non
Est-ce que je sais réaliser un petit programme simple et puissant ? Non
Est-ce que je sais faire des tests simples et puissants ? Non

"Une partie de sa puissance ne réside pas dans le langage mais dans ses bibliothèques de classes."
"Part of its power is not in the language but in its class libraries."
Les bibliothèques de classes sont réalisées avec du crabe farci ? 
Il ne s'agit plus de syntaxe et d'objet, mais de langage ainsi que des bibliothèques de classes.

12:34 31/12/2020
p. 133 FR 195 EN
"Object est la racine de la hiérarchie d'héritage." - "la véritable racine de la hiérarchie est ProtoObject"
"Object is the root of the inheritance hierarchy." - "the true root of the hierarchy is ProtoObject" 
"ProtoObject, qui est utilisé pour définir des entités minimales qui se font passer pour des objets"
"ProtoObject, which is used to define minimal entities that masquerade as objects"

	Classes		Méthodes
ProtoObject
	|> Object
		|> 	400 méthodes

12:46 31/12/2020
136. Chap.10 - p. 132 FR 195 EN - 10.1 Object - Objet
Remarque : vous pouvez compter le nombre de méthodes dans une classe comme ceci :
---------
Note: You can count the number of methods in a class like so:
----
Playground (CTRL+O+W)> 	Object selectors size> (CTRL+P)= 443
			Object class selectors size> (CTRL+P)= 30

Comment ça fonctionne exactement ?
Lorsque je clique sur une autre classe ou une méthode, le résultat est le même.
:-(

D09:16 31/12/2020 - F12:52 - Chapitre 10 - p.133/259 FR 196/376 EN
-------------------------------------------------------------------------------------------------------31/12/2020 fin



-------------------------------------------------------------------------------------------------------01/01/2021 debut
D12:06 01/01/2021 - F: - Chapitre 10 - p.133/259 FR 196/376 EN
D12:06 01/01/2021 - F13:11 - Chapitre 10 - p.133/259 FR 196/376 EN

	Classes					Méthodes
ProtoObject
	|> Object comportement par défaut commun à tous les "objets normaux" ?
	          (accès, copie, comparaison, gestion des erreurs, envoi de messages, récupérations)
	          messages utilitaires ?
		  l'object n'a aucune variable d'instance.
						|
						|>		400 méthodes

Note : 
------
la classe "Object" n'a aucune variable d'instance.

Pourtant, j'ai listé ci-dessous certaines variables d'instance rattachée à "Object" !!

Finder> Object (search : classes) = Object -> Browse
System Browser> ProtoObject subclass: #Object - package: 'Kernel-Objects'
Object-> Inst. side = accessing, asserting, associating, etc....
Object-> Class side = class initialization, documentation, instance creation

Rappels : 
---------
11:58 14/10/2020
61. Chap. 6 6.4 Methods - p.74 FR 106 EN
"Cette pratique a une certaine valeur, mais elle encombre également l'interface de vos classes, 
et pire, elle expose son état privé au monde."
Parce que le fait qu'une méthode soit publique et qu'elle puisse accéder à toutes les variables d'instance "privées"
c'est ne pas exposer son état privé au monde ?

67. Chap. 6 - p.86 FR 124 EN - Variables globales
p.86 FR 124 EN
"Les variables globales sont accessibles partout. Chaque classe est nommée par une variable globale."
p.86 124 EN
"La pratique recommandée est de limiter strictement l'utilisation de variables globales."

"superclasse" -> page 78/259 FR
"Chaque classe de Pharo hérite de son comportement et de la description de sa structure d'une seule superclasse. 

p.74 FR 107 EN 
6.5 Le côté instance et le côté classe 
Figure 6-2
SystemBrowser(CTRL+O+B)> Graphics-Primitives> Color (cocher Inst. side) = Color (côté instance "Int. side")
SystemBrowser(CTRL+O+B)> Graphics-Primitives> Color class (cocher Class side) = Color class (côté classe "Class side")

Paragraphe : Impression - Printing

D12:06 01/01/2021 - F13:11 - Chapitre 10 - p.133/259 FR 196/376 EN
-------------------------------------------------------------------------------------------------------01/01/2021 fin



-------------------------------------------------------------------------------------------------------02/01/2021 debut
D13:03 02/01/2021 - F13:33 - Chapitre 10 - p.133/259 FR 196/376 EN

Paragraphe : Impression - Printing

Classe 
Object -> envoie -> forme imprimée (Print It) -> printString

		Méthode (de modèle)
		printString -> message -> printOn: -> récepteur

Notes : 
-------
"Object >> printOn:", méthode qui sera remplacé le plus fréquemment.
OpalCompiler ne redéfinit pas printOn:	

	
classe 		methode		argument	representation
		printString
Object 		printOn:	stream		String		
OpalCompiler

Question : 
----------
"Object" est en blanc alors qu'"OpalCompiler" est en rouge ?
Plus tard, lors d'un copier/coller "OpalCompiler" est devenu blanc ?

Playground (CTRL+O+W)> Object new printString (CTRL+P)= 'an Object'
Playground (CTRL+O+W)> OpalCompiler new printString (CTRL+P)= 'an OpalCompiler'

D13:03 02/01/2021 - F13:33 - Chapitre 10 - p.133/259 FR 196/376 EN
-------------------------------------------------------------------------------------------------------02/01/2021 fin



-------------------------------------------------------------------------------------------------------07/01/2021 debut
D09:16 07/01/2021 - F00:00 - Chapitre 10 - p.133/259 FR 196/376 EN
D09:16 07/01/2021 - F13:27 - Chapitre 10 - p.134/259 FR 198/376 EN

classe 		methode				argument	representation
Object		printString (methode de modèle)
Object 		printOn:			stream(aStream)	String		
OpalCompiler	(printString et printOn n'existe pas dans cette classe)
Color
Object		storeOn: - (côté instance) ---> stream(aStream)
							\/
							read (lu)
Object		readFrom: - (côté classe) ------------> \/
							\/
							\/
Object		storeOn: - (côté instance) ---> flux d'arguments -----> expression ----> recréer le récepteur
									récepteur -> printOn: ---> version textuelle
									récepteur auto-évaluative -> printOn: ---> version textuelle 
À retenir :
-----------

(côté instance "Int. side") - (côté classe "Class side")

* For example, the value of the object true is itself i.e., the object true. 
We call such objects self-evaluating objects.

D09:16 07/01/2021 - F13:27 - Chapitre 10 - p.134/259 FR 198/376 EN

Question : 
---------
"The default implementation simply writes the class name preceded by a or an."
"L'implémentation par défaut écrit simplement le nom de classe précédé d'un a ou d'un an."

Si "Object new printString='an Object'" affiche "an" et que "LRUCache new printString='a LRUCache(#0 0/16 [ 1 ] 0%)'" affiche "a" qu'est-ce qui les différencie ?
Pourquoi l'un affiche "a" et l'autre "an" ? (Réponse plus bas - recherche avec les mots clés "Pourquoi l'un affiche")

Recherche : 
----------
Différence entre "a" et "an" ?

		message reçu ?			
	      ----------------			
	      |	      	      |			
Object->  String  X  Stream <-			   	  
    /		  X	      \	    		 
receiver     message selector message argument      
    |	   	  X   	        |     X   	
    |		 ms             |      ma 	
  printOn:(2)     X  --->----->--       X  	
    |		  X /		         X	
(keymessage) (1) printString <- (class send) <- Object     
      	     |				     | 		  
	     ----------------------------------			
	           a message send


représentation :

représentation auto-évaluative : 
messages (expressions) renvoient des objets (valeurs)
					|
				objects (valeurs) = moi-même
					|
				objet -> true = true (objet auto-évalué)

Note : 
------
Peut-on vraiment dire qu'il "autoévalue" alors qu'il s'agit d'une copie de la valeur "true".
Car une "auto-évaluation" c'est, prendre plusieurs éléments en compte puis un résultat en ressort.	

Constat : 
---------
Ce qui se trouve dans le paragraphe "Printing", après "OpalCompiler new printString" est incompréhensible.
Trop de blabla, l'un fait ceci et l'autre c'est cela.
C'est à y perdre son latin.

------------------------------------------------------------------------------RAPPELS DEBUT
RAPPELS
-------
* Comparaison entre la Figure 5-2 p.88/376 EN et Figures 5-4, 5-5 p.93/376 EN

			message					message binary
		----------------				-------
		|		|				|     |
	total		<= max				total	 + 20 (10 ne peut pas être le total, il manque quelque chose)
    /		|   	         \	    		/	 |   \
receiver     message selector message arguments      receiver	m.s.   m.a.
recepteur	|   / |   /  \  /		                 |     |
    \		ms ma ms ma ms ma			\       ms     ma
	        |  |  |  |  |  |				 |     |
	Color 	r: 1  g: 0  b: 0 		   10 # Somme    +  1: 10 2: 20 (ajouts 1: et 2:)
	       |		| 		  Pourtant : .. un message binaire envoyé au récepteur 10 ?
		-----------------


* Comparaison entre la Figure 5-2 p.88/376 EN et les Figures 5-4, 5-5 + Exemples 1 et 2 p.93/376 EN

		message unary yellow				    message binary + 20
	      ----------------					 -------------------
	      |	      	      |					 |                  |
objet->	  aPen    X  aColor <-			   objet->   aPen      X     120 <-	  
    /		  X	      \	    			/	       X   	    \     
receiver     message selector message argument      	receiver   m.selector  	 message argument
    |	   	  X   	        |     X   		|	       X     	     |      X
    |		 ms             |      ma 		|	       ms     	     |       ma
  color:(2)       X  --->----->--        X  		go:(2)	       X  --->----->--         X
    |		  X /		         X		|	       X /		       X
(keymessage) (1) Color <- (class send) <- yellow     (keymessage) (1) 100 <- (objet send) <- + 20 
      	     |				     | 		  	 |				 |
	     ----------------------------------			 ---------------------------------
	           a message send					a message send


	 aPen color: Color yellow				 aPen go: 100 + 20
	|------------------------|				|-----------------|
	        a message					     a message

Note : 
-----
p.70/259 FR : ..., dont le sélecteur est composé d'un ou plusieurs caractères : +, -, *, etc.
------------------------------------------------------------------------------RAPPELS FIN

11:44 07/01/2021
Question : 
----------
Dans le listing 10-1, pourquoi trois crochets sont-ils présents après "aStream" alors qu'ils manquent dans le code ?
((P)Colors-Base, (C)Color (Inst. side), (P)printing, (M)printOn:, aStream)

(Pharo code - copier/coller)
printOn: aStream
	| name |
	(name := self name).
	name = #unnamed
		ifFalse: [ 
			^ aStream
				nextPutAll: 'Color ';
				nextPutAll: name ].
	self storeOn: aStream

Playground (CTRL+O+W)> 	testcase=true
			Color red printString (CTRL+P)> 'Color red'

Playground (CTRL+O+W)> Color red printString (CTRL+P)> 'Color red'

Playground (CTRL+O+W)> 	testcase=true (CTRL+P)> false

(Le résultat est le même avec "true" ou "false" ?)
Playground (CTRL+O+W)> 	testcase=false				    
			Color red printString (CTRL+P)> 'Color red'

11:59 07/01/2021
"Vous pouvez voir une version imprimée d'une valeur d'objet lorsque vous imprimez l'objet dans une aire de jeux. 
Voici quelques exemples de telles expressions auto-évaluées."

"You can see a printed version of an object value when you print the object in a playground. 
Here are some examples of such self-evaluating expressions."

De mon point de vue c'est une version "miroir". (une copie)

Exceptions :
----------
"Playground" ajoute des parenthèses aux valeurs : 
3@4
>>> (3@4)

{10@10. 100@100}
>>> {(10@10). (100@100)}

Unknown : Unknown variable: Nautilus please correct, or cancel:
---------
{Nautilus new . 100@100}

Note : 
------

À retenir :
-----------

:-( 

137. Chap.10 - p. 134 FR 197 EN - Impression - Printing
"N'oubliez pas que les tableaux littéraux ne peuvent contenir que des littéraux."
"Remember that literal arrays can only contain literals."
Il y a beaucoup de choses à ne pas oublier, du coup j'effectue une recherche pour un rappel.

Recherche : littéraux
-----------
p.60 FR 4.8 Résumé du chapitre 
"Il existe cinq types d'objets littéraux: les nombres (5, 2.5, 1.9e15, 2r111), 
les caractères ( $ a ), les chaînes ( 'hello'), les symboles ( #hello ) 
et les tableaux ( # ('hello' #hi )  ou  {1. 2. 1 + 2}  )"

p.54 FR 4.1 Éléments syntaxiques
Tout ce qui est entre parenthèses doit être une constante de compilation. 
Par exemple, # (27 (true false) abc) est un tableau littéral de trois éléments.

Question : 
----------
Pourquoi ajoute-t-il des dièses ?

#(10@10 100@100)
>>> #(10 #@ 10 100 #@ 100)

Traduction : 
------------
behavior = and adds extra behavior = et ajoute un comportement supplémentaire
p.134 FR 198 EN
method specializations implement self-evaluating behavior = les spécialisations de méthodes implémentent des autos-évaluations supplémentaires 

D09:16 07/01/2021 - F13:27 - Chapitre 10 - p.134/259 FR 198/376 EN
-------------------------------------------------------------------------------------------------------07/01/2021 fin



-------------------------------------------------------------------------------------------------------10/01/2021 debut
D12:07 10/01/2021 - F: - Chapitre 10 - p.134/259 FR 198/376 EN
D12:07 10/01/2021 - F13:15 - Chapitre 10 - p.135/259 FR 199/376 EN

Listing 10-2 - 
Point >> printOn: aStream
Finder> printOn: (selectors)> printOn:> Browse> Implementors of printOn: (438)> Point - printOn: - Kernel
Listing 10-3
Interval >> printOn: aStream
Finder> printOn: (selectors)> printOn:> Browse> Implementors of printOn: (438)> Unknown, inexistant (aucun interval)
System Browser> volet package (CTRL+F)> Interval> []Interval
Listing 10-4
Finder> Object (selectors)> Object> ? anObject
Finder> anObject ?
Finder> = anObject (Source)> = ----\/			(le message -> "=")
				anObject> Browse


package 						classe		protocole	methode		sous-classe	Variable d'instance	Variable de class
Kernel-BasicObjects		Object			(C)Point	printing	printOn:	#Point		x y			''	vide
Collections-Sequenceable-Base	SequenceableCollection	[]Interval ?	printing	printOn:	#Interval	start stop step		''	vide
Kernel-Objects			ProtoObject		(C)Object	comparing	=		#Object		''	vide		DependentsFields

Notes : 
------
Variables déclarées dans la classe (x,y ou start, stop, step), mise en formes et activée dans la méthode.
Cela ne me semblait pas évident au départ ou illisible, mais maintenant j'ai su lier ces valeurs. (?) 

* are self-evaluating (playground, transcript)
1 to: 10 (CTRL+P)
>>> (1 to: 10) "intervals are self-evaluating"

De mon point de vue, c'est juste une copie (miroir) de ce qui a été envoyé.


À retenir :
-----------

:-(

Le message "=" teste l'égalité des objects (si deux objets représentent la même valeur).
Le message "==" teste l'identité de l'objet (si deux expressions représentent le même objet).

Il faudrait un système mnémotechnique, une grille, un jeu, un puzzle pour se rappeler tous ces "mots" associés à des "concepts".

Identiy and equality - stop

D12:07 10/01/2021 - F13:15 - Chapitre 10 - p.135/259 FR 199/376 EN
-------------------------------------------------------------------------------------------------------10/01/2021 fin


-------------------------------------------------------------------------------------------------------11/01/2021 debut
D10:10 11/01/2021 - F: - Chapitre 10 - p.135/259 FR 199/376 EN
D10:10 11/01/2021 - F12:02 - Chapitre 10 - p.135/259 FR 199/376 EN

Identiy and equality - reprise

138. Chap.10 - p. 135 FR 199 EN - Identity and equality
Listing 10-5 - Listing 10-6.
La classe "Complex" n'apparaît pas dans le volet "package" de "system browser", mais plutôt "ComplexBorder".
Le package " SciSmalltalk/PolyMath", n'existe pas.
Comment veux-tu tester "l'objet" alors que le package n'existe pas ?
Un livret avec trop de bla-bla, figé et bloquant. L'objet vivant à manipuler on en est loin.

La classe et les méthodes auraient pu être autre part.
Création de la classe "Complex" et des méthodes "= anObject" et "hash", rien ne fonctionne.
C'est aussi simple qu'une syntaxe qui peut tenir sur une carte postale. :-(


139. Chap.10 - p. 135 FR 199 EN - Identity and equality 2

Notes : 
-------

À retenir :
-----------

:-If)


"Si vous remplacez =, vous devez envisager de remplacer le  hachage. 
Si des instances de votre classe sont déjà utilisées comme clés dans un dictionnaire, 
vous devez vous assurer que les instances considérées comme égales ont la même valeur de hachage:"

"If you override =, you should consider overriding hash. 
If instances of your class are ever used as keys in a Dictionary, 
then you should make sure that instances that are considered to be equal have the same hash value:"

Avec des "Si" on peut mettre Paris en bouteille.

MDR ! 
Elle est bien bonne celle là.

"Notez que Pharo a un comportement d'égalité étrange par rapport aux autres Smalltalks. 
Par exemple, un symbole et une chaîne peuvent être égaux. 
(Nous considérons cela comme un bogue, pas une fonctionnalité.)"

"Note that Pharo has some strange equality behaviour compared to other Smalltalks. 
For example a symbol and a string can be equal. 
(We consider this to be a bug, not a feature.)"

Ce "bogue" est à l'image de tout ce qu'a pu rencontrer le lecteur lors de la lecture de ce livret.
Des méli-mélo à y perdre son latin et la cerise sur le gâteau "la considération d'un bogue".

D10:10 11/01/2021 - F12:02 - Chapitre 10 - p.135/259 FR 199/376 EN
-------------------------------------------------------------------------------------------------------11/01/2021 fin



-------------------------------------------------------------------------------------------------------12/01/2021 debut
D10:25 12/01/2021 - F00:00 - Chapitre 10 - p.135/259 FR 199/376 EN


À retenir : - :-(
----------

Le message "=" teste l'égalité des objects (si deux objets représentent la même valeur).
Le message "==" teste l'identité de l'objet (si deux expressions représentent le même objet).
Le message "==" est une méthode primitive de ProtoObject.
Le message "~=" teste l'inégalité de l'objet
Un symbole et une chaîne peuvent être égaux.

Playground (CTRL+O+W)> #'lulu' = 'lulu' (CTRL+P)> true
Playground (CTRL+O+W)> 'lulu' = #'lulu' (CTRL+P)> true

10:40 12/01/2021
Appartenance à la classe

Interroger n'importe quel objet sur sa classe : 
-----------------------------------------------

Playground (CTRL+O+W)> 1 class (CTRL+P)> SmallInteger
Playground (CTRL+O+W)> 2 class (CTRL+P)> SmallInteger
Playground (CTRL+O+W)> 3 class (CTRL+P)> SmallInteger
Playground (CTRL+O+W)> 100 class (CTRL+P)> BoxedFloat64
Playground (CTRL+O+W)> +5 class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> -5 class (CTRL+P)> SmallInteger
Playground (CTRL+O+W)> *5 class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> /5 class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> =5 class (CTRL+P)> Variable or expression expected ->


Playground (CTRL+O+W)> 0.1 class (CTRL+P)> BoxedFloat64
Playground (CTRL+O+W)> 0.2 class (CTRL+P)> BoxedFloat64
Playground (CTRL+O+W)> 0.3 class (CTRL+P)> BoxedFloat64
Playground (CTRL+O+W)> 0.132 class (CTRL+P)> BoxedFloat64

Playground (CTRL+O+W)> . class (CTRL+P)> nil
Playground (CTRL+O+W)> , class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> ; class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> : class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> ! class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> ? class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> / class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> § class (CTRL+P)> Unknown character ->
Playground (CTRL+O+W)> * class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> µ class (CTRL+P)> UndefinedObject
Playground (CTRL+O+W)> $ class (CTRL+P)> Character
Playground (CTRL+O+W)> £ class (CTRL+P)> Unknown character ->
Playground (CTRL+O+W)> ¤ class (CTRL+P)> Unknown character ->
Playground (CTRL+O+W)> ² class (CTRL+P)> Unknown character ->
Playground (CTRL+O+W)> & class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> {  } class (CTRL+P)> 
Playground (CTRL+O+W)> "" class (CTRL+P)> nil
Playground (CTRL+O+W)> " class (CTRL+P)>
Playground (CTRL+O+W)> '' class (CTRL+P)> ByteString
Playground (CTRL+O+W)> ' class (CTRL+P)> Unmatched'in string literal. ->
Playground (CTRL+O+W)> {  } class (CTRL+P)> Array
Playground (CTRL+O+W)> {  class (CTRL+P)> expected } ->				//La réponse n'est pas le même que la parenthèse. (?)
Playground (CTRL+O+W)> (  ) class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> (  class (CTRL+P)> ')' expected  ->			//La réponse n'est pas le même que l'accolade. (?)
Playground (CTRL+O+W)> [ ]  class (CTRL+P)> BlockClosure
Playground (CTRL+O+W)> [  class (CTRL+P)> ']' expected  ->			//La réponse n'est pas le même que l'accolade. (?)
Playground (CTRL+O+W)> - class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> ` class (CTRL+P)> Unknown character ->
Playground (CTRL+O+W)> _ class (CTRL+P)> UndefinedObject
Playground (CTRL+O+W)> \ class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> ^ class (CTRL+P)> nil
Playground (CTRL+O+W)> ¨ class (CTRL+P)> Unknown character ->
Playground (CTRL+O+W)> @ class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> ° class (CTRL+P)> Unknown character ->
Playground (CTRL+O+W)> ) class (CTRL+P)> Unknown input at end ->
Playground (CTRL+O+W)> ] class (CTRL+P)> Unknown input at end ->
Playground (CTRL+O+W)> + class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> = class (CTRL+P)> Variable or expression expected ->
Playground (CTRL+O+W)> } class (CTRL+P)> Unknown input at end ->
Playground (CTRL+O+W)> 5/5 class (CTRL+P)> Instance of SmallInteger class did not understand #isZero
Playground (CTRL+O+W)> 5 / 5 class (CTRL+P)> Instance of SmallInteger class did not understand #isZero
Playground (CTRL+O+W)> 5 / 8 class (CTRL+P)> Instance of SmallInteger class did not understand #isZero
Playground (CTRL+O+W)> 8/5 class (CTRL+P)> Instance of SmallInteger class did not understand #isZero
Playground (CTRL+O+W)> 8*5 class (CTRL+P)> Instance of SmallInteger class did not understand #adaptToNumber:andSend:
Playground (CTRL+O+W)> class class (CTRL+P)> UndefinedObject
Playground (CTRL+O+W)> anObject class (CTRL+P)> UndefinedObject
Playground (CTRL+O+W)> aObject class (CTRL+P)> UndefinedObject
Playground (CTRL+O+W)> Object class (CTRL+P)> Object class
Playground (CTRL+O+W)> ProtoObject class (CTRL+P)> ProtoObject class


12:43 12/01/2021
140. Chap.10 - p. 136 FR 200 EN - isMemberOf:
Interroger un objet rattaché à une instance d'une classe : 
----------------------------------------------------------

Playground (CTRL+O+W)> 1 isMemberOf: SmallInteger (CTRL+P)> true		

Finder ne trouve pas "isMemberOf:" dans "SmallInteger" ?
Rien n'est cohérent, "Playground" affiche "true" alors que "Finder" n'affiche rien.
Tandis que "System Browser" affiche "SmallInteger" sans "isMemberOf:" et vice-versa.
C'est à y perdre son latin.

Solution : 
----------
Il faut cocher "Object" dans "instance side" situé dans le volet "protocole" afin d'y faire apparaître "isMemberOf:".

Ci-dessous schémas "Object" et "SmallInteger" : 
-----------------------------------------------

package 		     classe	    protocole	      		  méthode      		sous-classe  immediateSubclass  Variable d'instance  Variable de class
Kernel-Objects	ProtoObject  (C)Object	    class membership  		  isMemberOf:  		#Object	    	/	        '' vide		     'DependentsFields'
Kernel-Numbers	Integer	     £ SmallInteger instance side (cocher object) isMemberOf: (Object)	   /	     #SmallInteger      '' vide		     '' vide
					    class membership

Classe		 Protocole		 Méthode			
(C)Object ------ class membership -----> isMemberOf:
    /|\
  Instance 
  de la
   classe
    /|\
£ SmallInteger > 1 instance side 	   		//SmallInteger est l'instance de la classe Object = true
		 |-> 2 (cocher object)  	
		 3 class membership ---> isMemberOf: (Object)

Questions : 
---------
Je ne comprends pas pourquoi "SmallInteger" est l'instance de la classe "Object" alors que les autres classes
(Magnitude, Number, Integer) ne le sont pas et malgré que "isMemberOf: (Object) soit affiché dans le volet méthode.

Parce que "SmallInteger" fait partie de la fin de la liste alors cela fait de lui une instance ?
Il y a quelque chose qui m'échappe dans cette histoire.

C'est étonnant.
Pourquoi la classe "Object" est-elle en haut de la liste alors que dans le volet protocole c'est inversé ?

Pourquoi "SmallInteger" est-il "true" alors que les autres classes sont "false" ? 
Outre sa position, qu'est-ce qui différencie "SmallInteger" des autres ?
Playground (CTRL+O+W)> 1 isMemberOf: ProtoObject (CTRL+P)> false
Playground (CTRL+O+W)> 1 isMemberOf: Object (CTRL+P)> false
Playground (CTRL+O+W)> 1 isMemberOf: Magnitude (CTRL+P)> false
Playground (CTRL+O+W)> 1 isMemberOf: Number (CTRL+P)> false
Playground (CTRL+O+W)> 1 isMemberOf: Integer (CTRL+P)> false
Playground (CTRL+O+W)> 1 isMemberOf: SmallInteger (CTRL+P)> true

D10:25 12/01/2021 - F13:11 - Chapitre 10 - p.136/259 FR 200/376 EN
-------------------------------------------------------------------------------------------------------12/01/2021 fin



-------------------------------------------------------------------------------------------------------14/01/2021 debut
D10:35 14/01/2021 - F: - Chapitre 10 - p.136/259 FR 200/376 EN
D10:35 14/01/2021 - F12:45 - Chapitre 10 - p.136/259 FR 200/376 EN

Note : 
------
Pharo est écrit en lui-même, vous pouvez vraiment naviguer dans sa structure en utilisant la bonne combinaison
de messages de superclasse et de classe (voir le chapitre : Classes et métaclasses - pages 250 FR 363 EN). 

"écrit en lui-même" ?

141. Chap.10 - p. 136 FR 200 EN - isKindOf:
"Pourquoi "SmallInteger" est-il "true" alors que les autres classes sont "false" ? "

Réponse : 
---------
Lorsque "isMemberOf:" est lu dans "Playground" avec le code "^self class == aClass" alors celui-ci indique "false" 
pour (Magnitude, Number, Integer) contrairement au code "isKindOf:". (Ci-dessous)

Test : 
------
J'ai copié le code de "isKindOf:" et collé dans celui de "isMemberOf:" et toutes les classes ont été "true".
Ensuite, lorsque j'ai modifié le contenue de "isKindOf:", Pharo s'est figé. (Dans le gestionnaire "en cours d'exécution (?))
Fonctionne d'un côté, mais pas de l'autre.

isMemberOf:
-----------
isMemberOf: aClass 
	"Answer whether the receiver is an instance of the class, aClass."

	^self class == aClass

isKindOf:
---------
isKindOf: aClass
	"Answer whether the class, aClass, is a superclass or class of the receiver.
	The current implemementation allows for a Trait to be used as argument"

	^ self class == aClass or: [ self class inheritsFrom: aClass ] 

11:57 14/01/2021
142. Chap.10 - p. 136 FR 200 EN - String

Note : 
------
Pourquoi lors de la recherche de "Sting", celle-ci n'existe pas dans "Object" ?

(isKindOf: = méthode, String = classe)
"1 isKindOf: String
>>> false"

Réponse : (déjà expliqué dans un précédent chapitre : certes, mais ce n'est pas simple)
--------
C'est subtil et il faut être attentif.
Dans le volet classe, tu peux avoir affiché "Object" ou "Object class", heu !!!
Pour différencier les "Objets", il faut regarder ce qui est inscrit dans la barre de titre.
(À mon avis, cette subtilité doit être source d'erreur).
Enfin bon.
Par défaut, sont cochés "Hier., Inst. side, Methods", alors affiche "Object".
Lorsque "Class side" est coché alors s'affiche dans la barre de titre "Object class".

Sauf que si tu n'es pas attentif et ne lis pas ce qui est affiché dans les deux bandeaux 
alors tu ne comprends pas et tu cherches. (le String :-))

Mais c'est vicieux, car lorsque "Object class" et affiché dans la barre de titre alors "String" devrait s'afficher.
Sauf que, lorsque tu cliques sur "SmallInteger - non class" pour ensuite mettre "Class side" 
alors s'affiche seulement les classes "ProtoObject, Object, Magnitude, Number, Integer, SmallInteger".
Donc "String" est à l’oubliette.
Ensuite, pour le faire revenir c'est toute une histoire.
Ce n’est pas simple cette histoire.
Il change de package (String) : Galère.

12:32 14/01/2021

143. Chap.10 - p. 136 FR 200 EN - String2

Enfin, j'ai trouvé l'astuce. (Côté intuitif, il faudra repasser. "le string")

1 Object>>isKindOf: - SmallInteger - Hier. - Inst. side 
Pour passer à String, cliquer sur Object puis Flat, Hier. et enfin Filter.. String)

2 Object - String - Hier. Inst. side
Pour passer à SmallInteger, dans Filter.. enlever String et mettre SmallInteger puis Flat, Hier.)

   Packages			Classes		Méthodes
00 Kernel-Numbers		Object		isKindOf:
01 Kernel-Numbers		Object		isMemberOf:
01 Kernel-Numbers		SmallInteger
02 Collections-Strings-Base	String

Donc, jouer avec Flat, Hier. et Hier., Flat. :-)

D10:35 14/01/2021 - F12:45 - Chapitre 10 - p.136/259 FR 200/376 EN
-------------------------------------------------------------------------------------------------------14/01/2021 fin



-------------------------------------------------------------------------------------------------------15/01/2021 debut
D11:02 15/01/2021 - F11:27 - Chapitre 10 - p.136/259 FR 200/376 EN

"Object >> respondsTo: répond si le récepteur comprend le sélecteur de message donné en argument."
Le truc c'est qu'il ne répond pas "true".

1 respondsTo: #, >>> false
1 respondsTo: #hello >>> false
1 respondsTo: 'hello' >>> false
1 respondsTo: 5 >>> false
1 respondsTo: 1.9e15 >>> false
1 respondsTo: a >>> false
1 respondsTo: $ >>> A Character was expected ->
1 respondsTo: ( # ('hello' #hi ) >>> Expecting a literal type ->
1 respondsTo: 'hello' #hi >>> End of statement list encountered ->
1 respondsTo: {1. 2. 1 + 2} >>> false
1 respondsTo:  >>> false

Rappel : 
--------
p.60 FR 4.8 Résumé du chapitre 
"Il existe cinq types d'objets littéraux: les nombres (5, 2.5, 1.9e15, 2r111), 
les caractères ( $ a ), les chaînes ( 'hello'), les symboles ( #hello ) 
et les tableaux ( # ('hello' #hi )  ou  {1. 2. 1 + 2}  )"

D11:02 15/01/2021 - F11:27 - Chapitre 10 - p.136/259 FR 200/376 EN
-------------------------------------------------------------------------------------------------------15/01/2021 fin



-------------------------------------------------------------------------------------------------------17/01/2021 debut
D11:40 17/01/2021 - F: - Chapitre 10 - p.136/259 FR 200/376 EN
D11:40 17/01/2021 - F14:23 - Chapitre 10 - p.137/259 FR 202/376 EN

"Au lieu de prendre des décisions basées sur la classe de l'objet, 
vous devez simplement envoyer un message à l'objet et le laisser décider (sur la base de sa classe) 
comment il doit se comporter. (Ce concept est parfois appelé typage canard)."
"Instead of making decisions based on the class of object, 
you should simply send a message to the object and let it decide (on the basis of its class) 
how it should behave. (This concept is sometimes referred to as duck typing)"

"La copie d'objets présente des problèmes subtils."
"Copying objects introduces some subtle issues."
Ha bon ! 
Et bien, ce n'est qu'une pierre supplémentaire mise à la suite des autres problèmes subtils qu'est l'utilisation
de Pharo.
Rappel : Listing 10-4
--------
"Il faudrait un système mnémotechnique, une grille, un jeu, un puzzle pour se rappeler tous ces "mots" associés à des "concepts".

	Object
	\|/
	copie superficielle	"shallowCopy est une méthode primitive qui crée une copie superficielle d'un objet."
	\|/
	partage de référence
	\|/
Variable d'instance <-> accessible par référence

Questions : 
----------

Quel est l'intérêt de mettre "a1" en seconde ligne ? Le premier code la réponse est identique, mais par la suite cela change.

a1 := { { 'harry' } }.
a1
>>> #(#('harry'))

Quel est l'intérêt de mettre des accolades ?

a1 := { 'harry' }.
>>> #('harry')

a1 := 'harry'.
>>> 'harry'

a1 := harry.
>>> nil

a1 := (harry).
>>> nil 

a1 := ( harry ).
>>> nil

a1 := { harry }.
>>> #(nil)

a1 := #harry.
>>> #harry

1 exemple : copie
Playground (CTRL+O+W)> a1 := { { 'harry' } }. (CTRL+P)> #(#('harry'))
Playground (CTRL+O+W)> a2 := a1 shallowCopy. (CTRL+P)> #(#('harry'))

2 exemple : copie
Playground (CTRL+O+W)> a1 := #harry. (CTRL+P)> #harry
Playground (CTRL+O+W)> a2 := a1 shallowCopy. (CTRL+P)> #harry

a1 := Object. (CTRL+P)> Object
a2 := a1 shallowCopy. (CTRL+P)> Object

a1 := Magnitude. (CTRL+P)> Magnitude
a2 := a1 shallowCopy. (CTRL+P)> Magnitude

a1 := readSlotNamed:. (CTRL+P)> Variable or expression expected ->
a2 := a1 shallowCopy. (CTRL+P)> Magnitude

a1 := #readSlotNamed:. (CTRL+P)> #readSlotNamed:
a2 := a1 shallowCopy. (CTRL+P)> #readSlotNamed:


a1 := { { 'harry' } }. (CTRL+P)> #(#('harry'))
a2 := a1 shallowCopy. (CTRL+P)> #(#('harry'))
(a1 at: 1) at: 1 put: 'sally'. 'sally'


a1 := { { 'harry' } }. (CTRL+P)> #(#('harry'))
a1 (CTRL+P)> #(#('harry'))
a2 := a1 shallowCopy. (CTRL+P)> #(#('harry')) 
a2 (CTRL+P)> #(#('harry'))
(a1 at: 1) at: 1 put: 'sally'. (CTRL+P)> 'sally'
a1 (CTRL+P)> #(#('sally'))
a2 (CTRL+P)> #(#('sally'))		//"le sous-tableau est partagé!" - "the subarray is shared!"

Playground (CTRL+O+W)> shawlloCopy (CTRL+M)> Implementors of shallowCopy (9)

package				classe		protocole	méthode		sous-classe	classe Variable	
Kernel-Objects	ProtoObject	(C)Object	copying		shallowCopy	#Object		DependentsFiels

"Object >> shallowCopy est une méthode primitive qui crée une copie superficielle d'un objet."

Question : 
----------
"shallowCopy est une méthode primitive qui crée une copie superficielle d'un objet."
(Dico. : superficielle - Qui ne concerne que la surface; qui est à la surface. La couche superficielle.)
Si la copie n'est que superficielle alors comment afficher le reste ?

"Puisque a2 n'est qu'une copie superficielle de a1, les deux tableaux partagent une référence 
au tableau imbriqué qu'ils contiennent."
(Dico. : imbriquer - S’imbriquer : être disposé de façon à se chevaucher. [Figuré] Être étroitement relié.)
Pourquoi écrire "copie superficielle" alors qu'il s'agit d'une copie ?
Dans ce cas, tous les OS et la copie d'un fichier sont superficiels.

a1 est le tableau principal, donc a2 copie la valeur située dans a1, 
est-ce que l'on peut affirmer que cette valeur est partagée puisque a2 devient par la suite un tableau ?
(Qui sera ensuite copié par a3)

"Object >> deepCopy fait une copie arbitrairement profonde d'un objet."
(Dico. : arbitrairement - Caractère de ce qui ne dépend que de la seule volonté, du libre arbitre, 
de la fantaisie, de ce qui n’est pas régi par un jugement ou des règles fixes et précises.)
Comment savoir ce qu'il copie de ce qu'il rejette ?


a1 := { { { 'harry' } } }.		#(#(#('harry')))
a2 := a1 deepCopy.			#(#(#('harry')))
(a1 at: 1) at: 1 put: 'sally'.		'sally'
a1					#(#('sally'))
a2					#(#(#('harry')))

Lorsque les codes ci-dessus sont relancés, il n'y a pas de copie "arbitraire" puisque la réponse est la même.

"Le problème avec deepCopy est qu'il ne se terminera pas lorsqu'il est appliqué à une structure mutuellement 
récursive :"
(Dico. : récursive - [Didactique] Qui peut être répété de façon indéfinie, par l’application de la même règle)
(Dico. : mutuellement - D’une manière mutuelle; l’un l’autre, réciproquement.)

A l'étape 3, Pharo affiche un message d'erreur puis plante.
Directement à l'étape 4, s'affiche "nil" au lieu de "!''... does not terminate!''!".
a1 := { 'harry' }.			#('harry')
a2 := { a1 }.				#(#('harry'))
a1 at: 1 put: a2.			Fatal VM erro - Sorry but the VM has crashed. Reason: out of memory. Current byte code: -1 Primitive index: -1. This information will be stored in the file "crash.dmp with a complete stack dump
a1 deepCopy				nil

fin deepCopy

D11:40 17/01/2021 - F14:23 - Chapitre 10 - p.137/259 FR 202/376 EN
-------------------------------------------------------------------------------------------------------17/01/2021 fin



-------------------------------------------------------------------------------------------------------22/01/2021 debut
D09:57 22/01/2021 - F: - Chapitre 10 - p.137/259 FR 202/376 EN
D09:57 22/01/2021 - F13:12 - Chapitre 10 - p.138/259 FR 202/376 EN

11:28 22/01/2021
144. Chap.10 - p. 137 FR 202 EN - copy
1. "Object >> shallowCopy" est une méthode primitive qui crée une copie superficielle d'un objet."

2. "Object >> deepCopy" fait une copie arbitrairement profonde d'un objet."
"Le problème avec deepCopy est qu'il ne se terminera pas lorsqu'il est appliqué à une structure mutuellement récursive :"

3. "Object >> copy" Répondez à une autre instance comme le récepteur. Les sous-classes remplacent généralement postCopy;
ils ne remplacent généralement pas shallowCopy."
"Une autre solution consiste à utiliser la copie de message. Il est implémenté sur Object comme suit:"(p 137 FR 202 EN - Listing 10-7)

copy = shallowCopy

	copy
	  \|--<---|-----<----|\
  /|-->	^self shalloCopy postCopy
  /|			     |\
  /|	postCopy >-----------|\
  /|--< ^ self


Notes : 
------
copy : Les autres (shalloCopy, deepCopy, postCopy) sont également implémentés sur Object.
L'explication de l'objet "copy" est très succincte, de plus, "copy" emploie d'autres "Objets".
Enfin, "copy" utilise l'objet "postCopy" qui fait usage de "^self", qui lui même renvoie "^self".
Pourquoi "copy" n'est-il pas plus indépendant ? C’est nébuleux cette histoire.

4. "Object >> postCopy"

postCopy  
^ self 
    |> "chaque sous-classe peut décider de personnaliser la méthode postCopy qui agit comme un hook."
    |> "vous devez remplacer postCopy pour copier toutes les variables d'instance qui ne doivent pas être partagées."
    |> "il y a de fortes chances que postCopy fasse toujours un super postCopy pour s'assurer que l'état 
        de la superclasse est également copié."


À retenir : 
-----------
"vous devez remplacer postCopy pour copier toutes les variables d'instance qui ne doivent pas être partagées."


Questions : 
-----------
Qu'est-ce qu'un hook ?
Quelles sont les sous-classes qui peuvent décider de personnaliser la méthode postCopy ?

Remplacer "postCopy" pour copier toutes les variables d'instance, encore une tâche à ajouter à la longue liste de l'oubli.

Il y a de fortes chances, mais de toute évidence ce n'est pas sur que "postCopy" fasse toujours un "super postCopy".
Comment en être sur ou pas ?

Il y a beaucoup de choses qui peuvent être faites ou pas, au petit bonheur la chance.
Enfin de compte, il y a des objets et du code qui font un peu ce qu'ils veulent sans savoir vraiment ce qu'ils font.
La nébuleuse s'épaissit.

D'un côté, le lecteur essaie de comprendre comment programmer "Smalltalk-Pharo" rapidement et efficacement. 
Mais comprendre rapidement c'est impossible puisque ces objets, ces codes, les interrelations et ces modes de fonctionnement 
s'apparentent à des situations confuses, nébuleuses et une prise de tête indéniable. 

[faut pas se prendre la tête]
https://www.fun-mooc.fr/courses/course-v1:inria+41010+self_paced/about


Codes : shallcopy, deepcopy, copy, postcopy
-------

SHALLOWCOPY
-----------
shallowCopy
	"Answer a copy of the receiver which shares the receiver's instance variables. 
It should never be overridden. I'm invoked from the copy template method. 
Subclasses that need to specialize the copy should specialize the postCopy hook method."
	
	| class newObject index |
	<primitive: 148>
	class := self class.
	class isVariable
		ifTrue: 
			[index := self basicSize.
			newObject := class basicNew: index.
			[index > 0]
				whileTrue: 
					[newObject basicAt: index put: (self basicAt: index).
					index := index - 1]]
		ifFalse: [newObject := class basicNew].
	index := class instSize.
	[index > 0]
		whileTrue: 
			[newObject instVarAt: index put: (self instVarAt: index).
			index := index - 1].
	^ newObject


DEEPCOPY
--------
deepCopy
	"Answer a copy of the receiver with its own copy of each instance variable. 
deepCopy does a deep copy. 
It should never be overridden and only be used if you want to get these very specific semantics.
It doesn't handle cycles, #veryDeepCopy does. 
In the future we will make it handle cycles and deprecate veryDeepCopy"


	| newObject class index |
	class := self class.
	(class == Object) ifTrue: [^self].
	class isVariable
		ifTrue: 
			[index := self basicSize.
			newObject := class basicNew: index.
			[index > 0]
				whileTrue: 
					[newObject basicAt: index put: (self basicAt: index) deepCopy.
					index := index - 1]]
		ifFalse: [newObject := class basicNew].
	index := class instSize.
	[index > 0]
		whileTrue: 
			[newObject instVarAt: index put: (self instVarAt: index) deepCopy.
			index := index - 1].
	^newObject


COPY
-----
copy
	"Answer another instance just like the receiver. 
Subclasses typically override postCopy; they typically do not override shallowCopy. 
Copy is a template method in the sense of Design Patterns. 
So do not override it. Override postCopy instead. 
Pay attention that normally you should call postCopy of your superclass too."

	^self shallowCopy postCopy


POSTCOPY
---------
postCopy
	"I'm a hook method in the sense of Design Patterns TemplateHook/Methods. 
I'm called by copy. 
self is a shallow copy, subclasses should copy fields as necessary to complete the full copy"

	^ self 


Notes : 
-------
Tu es obligé de te prendre la tête si tu veux un tant soit peu essayer de comprendre tout ce bric-à-brac.
D'un côté, tu essaies de comprendre et de l'autre on t'assomme.(La grosse batte du capitaine caverne)
Mais c'est très nettement vaseux, une perte de temps indéniable, indigeste et prise de tête.

[faut pas se prendre la tête]
https://www.fun-mooc.fr/courses/course-v1:inria+41010+self_paced/about

p.138 FR 202 EN - Debogage - Debugging
Le retour du débogage (chap. 7 - chap. 10)


Note : 
------
Conversion gif 4,76Mo en vidéo = 3gp 4,16Mo ou swf 4,23Mo (reste à régler le flou de l'image).


 package 				sous-classe	instanceVariableNames	classVariableNames	classe		protocol	méthode
1 Kernel-Objects	ProtoObject	#Object			''		'DependentsFields'	(C)Object	halting		halt
3 Kernel-Exceptions	Exception	#Halt			''			''		(E)Halt		
2 Kernel-Exceptions	Object		#Exception	'messageText tag signaler	''		(E)Exception
							signalContext 
							handlerContext
							outerContext'	
4 Collections-Stack-BaseLinkedList	#Stack			''			''		()Stack		removing	pop


Descriptions : 
--------------
'halt' : Pour définir un point d'arrêt, insérer "self halt" ou "1 halt" ou "haltOnce" ou "haltIf:" dans le corps de la méthode.
'assert:' : Attends un bloc comme argument et si le bloc prend la valeur "true" l'exécution continue 
sinon une exception "AssertionFailure sera déclenchée. Si cette exception n'est pas interceptée autrement, 
le débogueur s'ouvrira à ce stade de l'exécution. 
"assert:" est particulièrement utile pour soutenir la conception par contrat. 


Notes : 
-------
Il existe une méthode "halt" et une classe "(E)Halt". (minis. / majus.) - symbole classe "éclair" au lieu de "C) ?
"Have a look at the class Halt which is an special exception." - "Jetez un oeil à la classe Halt qui est une exception spéciale."
C'est à dire une "exception spéciale" ? L'allusion est la classe "Exception".

La conception par contrat ?

"L'utilisation la plus courante consiste à vérifier les conditions préalables non triviales aux méthodes 
publiques des objets." - Comment fais-tu ça ?


Codes : halt, haltOnce, haltIf:, Halt, Exception, pop
------
halt
	"This is the typical message to use for inserting breakpoints during debugging."
	<debuggerCompleteToSender>
	Halt now

haltOnce
	<debuggerCompleteToSender>
	Halt once.

haltIf: condition
	<debuggerCompleteToSender>
	Halt if: condition.

Exception subclass: #Halt
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'Kernel-Exceptions'

Object subclass: #Exception
	instanceVariableNames: 'messageText tag signaler signalContext handlerContext outerContext'
	classVariableNames: ''
	package: 'Kernel-Exceptions'

pop
	"Returns the first element and remove it from the stack."

	^self removeFirst 

D09:57 22/01/2021 - F13:12 - Chapitre 10 - p.138/259 FR 202/376 EN
-------------------------------------------------------------------------------------------------------22/01/2021 fin



-------------------------------------------------------------------------------------------------------23/01/2021 debut
D11:26 23/01/2021 - F: - Chapitre 10 - p.138/259 FR 202/376 EN
D11:26 23/01/2021 - F13:10 - Chapitre 10 - p.138/259 FR 203/376 EN

Complète les informations et les codes ci-dessus.
Cela évite d'écrire des notes en doublon.

12:26 23/01/2021
145. Chap.10 - p. 138 FR 202 EN - assert: or assert:
"Ne confondez pas  Object >> assert: avec TestCase >> assert:, qui se produit dans le cadre de test SUnit (voir le chapitre  : SUnit).
Alors que le premier attend un bloc comme argument (en fait, il prendra tout argument qui comprend la valeur, y compris un booléen ), 
le second attend un booléen. Bien que les deux soient utiles pour le débogage, ils ont chacun un objectif très différent."


Note :
------
Le problème c'est que tu as vite fait de confondre "assert:" et "assert:" puisque "Playground" affiche "Object >> assert:",
tandis que l'autre n'est pas affiché.
Après une recherche, "TestCase >> assert:" n'existe pas, mais apparaît dans "TestAsserter". 


Recherche : 
-----------
TestCase >> assert:, "Playground" ou "Finder" n'affiche rien.

12:47 23/01/2021
146. Chap.10 - p. 138 FR 202 EN - Listing 10-8 - 10-9

Les codes des Listings "10-8" et "10-9" sont différents du programme Pharo 8.0.0.
Non seulement les codes sont différents d'un programme à un autre, en supplément, ceux-ci doivent être contrôlés 
pour en connaitre l'usage.
Ensuite, tu t'interroges sur le fait qu'il y a marqué "subclassResponsibility", est-ce une erreur de mettre "subclass"
ou alors est-ce le nom correct ? 
Du coup, tu vérifies.

Listing 10-8
"Stack >> pop								Pile >> pop
	"Return the first element and remove it from the stack."	"Retournez le premier élément et retirez-le de la pile."
	self assert: [ self isNotEmpty ].				affirmation automatique: [self isNotEmpty ].
	^ self linkedList removeFirst element"				^ self linkedList removeFirst élément

Pharo 8.0.0
"Stack >> pop
	"Returns the first element and remove it from the stack."
	^self removeFirst"

Listing 10-9
Object >> subclassResponsibility					Object >> sous-classeResponsabilité
"This message sets up a framework for the behavior of the class'	"Ce message définit un cadre pour le comportement des sous-classes de la classe.
subclasses.	
Announce that the subclass should have implemented this message."	Annoncez que la sous-classe aurait dû implémenter ce message."
self error: 'My subclass should have overridden ', thisContext		erreur auto: 'Ma sous-classe aurait dû être remplacée', sélecteur d'expéditeur thisContext printString
sender selector printString

Object >> subclassResponsibility
	"This message sets up a framework for the behavior of the class' subclasses.
	Announce that the subclass should have implemented this message."
	SubclassResponsibility signalFor: thisContext sender selector

D11:26 23/01/2021 - F13:10 - Chapitre 10 - p.138/259 FR 203/376 EN
-------------------------------------------------------------------------------------------------------23/01/2021 fin



-------------------------------------------------------------------------------------------------------24/01/2021 debut
D11:54 24/01/2021 - F11:56 - Chapitre 10 - p.138/259 FR 203/376 EN

L'appel pour jouer à FS est très fort, malheureusement pour programmer Pharo, ce n'est pas le cas, au contraire
c'est un boulet qu'il faut traîner et ce n'est pas du tout amusant.


-------------------------------------------------------------------------------------------------------24/01/2021 fin



-------------------------------------------------------------------------------------------------------26/01/2021 debut
D10:19 26/01/2021 - F: - Chapitre 10 - p.138/259 FR 203/376 EN
pause 10:30 - reprise - D11:15 26/01/2021

La gestion des erreurs - Error handing
protocol = Error handling

D10:19 26/01/2021 - F11:46 - Chapitre 10 - p.138/259 FR 203/376 EN
-------------------------------------------------------------------------------------------------------26/01/2021 fin



-------------------------------------------------------------------------------------------------------30/01/2021 debut
D11:02 30/01/2021 - F	- Chapitre 10 - p.138/259 FR 203/376 EN
pause 30 mn
D11:02 30/01/2021 - F13:30 - Chapitre 10 - p.139/259 FR 204/376 EN

Perte de temps.

Note : 
------
Avec des "Si" on peut mettre Paris en bouteille.

méthodes :
--------
deprecated: : Sending self deprecated: - Obsolète:. Envoi auto-obsolète: 
Obsolète: . Envoi  auto-obsolète: signale que la méthode actuelle ne doit plus être utilisée, 
si l'obsolescence a été activée.

doesNotUnderstand: : Il peut être utile de remplacer doesNotUnderstand: pour fournir un autre comportement. 

error et error: : (En général, il est préférable de lever vos propres exceptions personnalisées, 
afin de pouvoir distinguer les erreurs provenant de votre code de celles provenant des classes du noyau.)

subclassResponsibility : Les méthodes abstraites sont mises en œuvre par con-vention avec la sous-classe de corps 
selfResponsibility.
Si une classe abstraite est instanciée par accident, alors les appels à des méthodes abstraites entraîneront 
l'exécution de Object >> subclassResponsibility.  
Magnitude, Number et Boolean sont des exemples classiques de classes abstraites que nous verrons bientôt 
dans ce chapitre.
p.126 FR 184 EN
"TestCase est une classe abstraite conçue pour être sous-classée."
p. 78 FR 113 EN
class abstraite		méthodes
magnitude		<, =, hash, >, >=, <=, max:, min: entre: et:

Rappel : p. 78 FR 113 EN - Une bière svp !
--------
"Méthodes abstraites et classes abstraites 
Une classe abstraite est une classe qui existe pour être sous-classée, plutôt que pour être intégrée. 
Une classe abstraite est généralement incomplète, en ce sens qu'elle ne définit pas toutes les méthodes 
qu'elle utilise. Les méthodes «placeholder», celles que les autres méthodes supposent (re) définir, 
sont appelées méthodes abstraites."


package 			classe	         sous-classe	instance Variable	          classVariable		     protocol	                methode
Kernel-Objects	  ProtoObject	(C)Object	 #Object	      ''		          'DependentsFields'	     deprecation                deprecated:
Kernel-Exceptions Warning	(Z)Deprecation	 #Deprecation   'context explanationString        'Active Log RaiseWarning   accessing	                explanationString
								deprecationDate versionString     ShowWarning'
								rule condition'
Kernel-Objects	  ProtoObject	(C)Object	 #Object	      ''		          'DependentsFields'	     reflective operations	doesNotUnderstand:
Kernel-Objects	  ProtoObject	(C)Object	 #Object	      ''		          'DependentsFields'	     error handing		error
Kernel-Objects	  ProtoObject	(C)Object	 #Object	      ''		          'DependentsFields'	     error handing		error:
Kernel-Objects	  ProtoObject	(C)Object	 #Object	      ''		          'DependentsFields'	     error handing		subclassResponsibility

Note : 
------
Je serais curieux de voir toutes les étapes qu'empreindrait ce signal pour passer entre tous ces codes, objets, variables, etc.
Sois disant, que "Pharo" utilise des objets. Ce serait bien de créer une carte visuelle de ces étapes.


Kernel-Objects                      								
	|----> (C)Object
		   |----> depraction
				|----> deprecated:
Kernel-Exceptions <------------------------|
	|----> (Z)Deprecation
			|----> accessing
				   |----> explanationString

 

DEPRECATED: :
-------------
deprecated: anExplanationString
	"Warn that the sending method has been deprecated"
	
	Deprecation new
		context: thisContext sender;
		explanation: anExplanationString;
		signal

EXPLANATIONSTRING :
------------------
explanationString

	^ explanationString


DOESNOTUNDERSTAND: :
-------------------
doesNotUnderstand: aMessage 
	<debuggerCompleteToSender>
	 "Handle the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message 
(typically sent from the machine when a message is sent to the receiver and no method is defined for that selector)."
	"Testing: (3 activeProcess)"
		
	| exception resumeValue |
	(exception := MessageNotUnderstood new)
		message: aMessage;
		receiver: self.
	resumeValue := exception signal.
	^exception reachedDefaultHandler
		ifTrue: [aMessage sentTo: self]
		ifFalse: [resumeValue]

ERROR :
-------
error
	"Throw a generic Error exception."

	^self error: 'Error!'.

ERROR: :
--------
error: aString 
	"Throw a generic Error exception."

	^Error new signal: aString


SUBCLASSRESPONSIBILITY :
------------------------
subclassResponsibility
	"This message sets up a framework for the behavior of the class' subclasses.
	Announce that the subclass should have implemented this message."

	SubclassResponsibility signalFor: thisContext sender selector


initialize comme méthode de hook vide - initialize as an empty hook method
new comme méthode de modèle côté classe - new as a class-side template method

Listing 10-10
Playground (CTRL+O+W)> ProtoObject initialize (CTRL+M)> Implementors of initialize [1660]
ProtoObject	initialize	Kernel
initialize
	"Subclasses should redefine this method to perform initializations on instance creation"

Playground (CTRL+O+W)> Behavior new (CTRL+M)> Implementors of initialize [169]
ProtoObject	new	Kernel
new
	"Answer a new initialized instance of the receiver (which is a class) with no indexable variables. Fail if the class is indexable."

	^ self basicNew initialize

shouldNotImplement suite

D11:02 30/01/2021 - F13:30 - Chapitre 10 - p.139/259 FR 204/376 EN
-------------------------------------------------------------------------------------------------------30/01/2021 fin



-------------------------------------------------------------------------------------------------------4/02/2021 debut
D09:47 04/02/2021 - F: - Chapitre 10 - p.139/259 FR 204/376 EN
D09:47 04/02/2021 - F10:20 - Chapitre 10 - p.139/259 FR 204/376 EN



Un exemple typique est  Collection >> remove:  
qui est hérité par Dictionary  mais marqué comme non implémenté. 
(Un dictionnaire fournit à la place removeKey:).


ShouldNotImplement
-------------------

Collection>>remove:
Dictinary>>remove: - shouldNotImplement

package					sous-classe	inst.Variab.N. 	clas.Variab.N.	classe		protocol	methode		code
Collections-Abstract	Object 		#Collection	''		''		()Collection	removing	remove:		remove: oldObject ^ self remove: oldObject ifAbsent: [self errorNotFound: oldObject]
Collections-Unordered	HashedCollection#Dictionary	''		''		(Dictionary	removing	remove:		remove: anObject self shouldNotImplement


Testing Essai
-------------
Les méthodes de test n'ont rien à voir avec les tests SUnit! 
Une méthode de test est celle qui vous permet de poser une question sur l'état du récepteur et renvoie un booléen.


À retenir :
-----------

En général, de telles méthodes sont à éviter car l'interrogation d'un objet pour sa classe est une forme de violation de l'encapsulation.

Interrogation >	Violation >	Classe	methode 
d'un Object	encapsulation	Object	isArray
					is-Boolean
					isBlock
					isCollectin


À retenir :
-----------

Au lieu de tester un objet pour sa classe, il suffit d'envoyer une requête et de laisser l'objet décider comment le gérer.

Note : 
-----
Selon le Code de l'objet, ça peut tourner au vinaigre, d'un côté il y a une violation et de l'autre c'est au petit bonheur la chance de celui-ci.

Néanmoins, certaines de ces méthodes de test sont indéniablement utiles.

Note : 
------
Indéniablement utiles pour une "vilotation d'encapsulation" ?
Certaines de ces méthodes ! donc il faut faire le trie.

Finder> isNil	> Selectors
	notNil	> Selectors

package				superclass	sous-classe	inst.Variab.N. 	clas.Variab.N.	classe		protocol	methode		code
Kernel-Objects	ProtoObject	nil		#ProtoObject	''		''		(C)ProtoObject	testing		isNil		isNil
														overridden			"Coerces nil to true and everything else to false."
																		^false
Kernel-Objects	Object				#UndefinedObject				(C)UndefinedObject																		
															

D09:47 04/02/2021 - F10:20 - Chapitre 10 - p.139/259 FR 204/376 EN
-------------------------------------------------------------------------------------------------------4/02/2021 fin



-------------------------------------------------------------------------------------------------------05/02/2021 debut
D09:25 05/02/2021 - F - Chapitre 10 - p.139/259 FR 204/376 EN
D09:25 05/02/2021 - F13:00 - Chapitre 10 - p.140/259 FR 206/376 EN

"le modèle de conception Null Object"


Initialize
----------
"méthode clé qui ne se produit pas dans Object mais dans ProtoObject"

Instances	classe		protocol	         méthode
Nouvellement <------------ Initializer <---- définie <-- nouvelle méthode par défaut
Créées
Automatiquement			       <-- surcharge <-- initialize hook
Initialisées

Rappel :
--------
c'est vicieux, car lorsque "Object class" et affiché dans la barre de titre alors "String" devrait s'afficher.
Sauf que, lorsque tu cliques sur "SmallInteger - non class" pour ensuite mettre "Class side" 
alors s'affiche seulement les classes "ProtoObject, Object, Magnitude, Number, Integer, SmallInteger".

				(C) ProtoObject
				(C)   Object
				(E)	Magnitude

"La méthode devrait normalement effectuer une super initialisation pour établir l'invariant de classe 
pour toutes les variables d'instance héritées."

Note : 
------
"La méthode devrait normalement...". Il y a souvent une incertitude qui est signalée.


Numéros
-------

A savoir : 
----------
Numéros = Objets = accessible = extensible (que tout autre partie de la hiérarchie des classes)

"La racine abstraite de cette hiérarchie est Magnitude"
* Est-ce que le symbole (E) équivaut à une classe "abstraite" ?

"Magnitude est le parent non seulement des classes Number, mais aussi d'autres classes prenant en charge les
opérations de comparaison, telles que Characte , Duration et Timespan."
* Playground (CRL+O+W)> Magnitude (CTRL+M)> System browser, affiche l'ensemble des classes rattachés à Magnitude.


Classe Magnitude -> "Les méthodes < et = sont abstraites." 
* "Abstract" est indiqué dans le volet protocol.

Classe Number -> "les méthodes +, -, * et / comme étant abstraits"

Classe Magnitude et Number -> "Les autres opérateurs sont définis de manière générique."
* génrique = relatif au genre.




package			  	sous-classe	inst.Variab.N. 	clas.Variab.N.	classe		protocol	methode	     code
----------------------------------------------------------------------------------------------------------------------------------
			      | immediateScl.|
				-------------
Kernel-BasicObjects Magnitude  #Character	''		'CharSet	(E)   Character
								CharacterTable
								DigitValues'
----------------------------------------------------------------------------------------------------------------------------------
Kernel-Numbers      Magnitude  	#Number		''		''		(E)   Number	arithmetic	+	     + aNumber "Answer the sum of the receiver and aNumber."	self subclassResponsibility
												abstract
												overriden

Kernel-Numbers      Magnitude  	#Number		''		''		(E)   Number	printing	printOn:      printOn: aStream self printOn: aStream base: 10
												overridden
												overrides
Kernel-Numbers      Magnitude  	#Number		''		''		(E)   Number	printing	printOn:base: printOn: aStream base: base xxxx self subclassResponsibility 
												abstract
												overridden
												overrides
----------------------------------------------------------------------------------------------------------------------------------
Kernel-Chronology   Magnitude  	#Timespan	'start duration'''		(E)   Timespan   
----------------------------------------------------------------------------------------------------------------------------------
Kernel-Numbers	    Object	#Magnitude	''		''		(E)   Magnitude	testing		< 	      < aMagnitude "Answer whether the receiver is less than the argument." ^self subclassResponsibility
												abstract
												overridden
-----------------------------------------------------------------------------------------------------------------------------------

D09:25 05/02/2021 - F13:00 - Chapitre 10 - p.140/259 FR 206/376 EN
-------------------------------------------------------------------------------------------------------05/02/2021 fin



-------------------------------------------------------------------------------------------------------19/02/2021 debut
D11:23 19/02/2021 - F - Chapitre 10 - p.140/259 FR 206/376 EN
D11:23 19/02/2021 - F13:52 - Chapitre 10 - p.143/259 FR 210/376 EN

"La méthode Number >> printOn: est implémentée en termes d'abstrait."
"Les méthodes de troncature xxxxx"
"État de ce qui est tronqué. - Couper une partie importante de." 

La partie calcul est redondante puisque ç’a été fait avec ProStef.
De plus, le code, l'objet concrètement qu'est-ce que ça apporte de plus ?
Ces calculs ne me servent à rien pour dépanner le jeu LightOut.

"Il s'agit d'un excellent exemple de coercition automatique et de gestion exacte d'un nombre."
Définition : coercition : "Pouvoir de contraindre qqn à se soumettre à la loi. 
Action, fait de contraindre. Employer des moyens de coercition."

"À faire Essayez d'afficher le résultat de 1000 factoriel. Il faut plus de temps pour l'afficher que pour le calculer! "
Ça veut dire quoi ça, essayer d'afficher ? 
Après la création du code pour un jeu, puis l'utilisation de ProStef à ce niveau "Essayer d'afficher le résultat" c'est pour débutant.
Il est ou le code pour créer concrètement des programmes, déboguer ? 
C'est "Essayage" est un retour au début du livret ?
(Quelle perte de temps !)

Classe "Float"

"Les fractions sont représentées par des variables d'instance"

A		Integer (parent abstrait)
			|
B		1	2	3 -> (implémentations concrètes entières ?)
			|
C		méthodes numériques abstraties 

		SmallInteger ------- NO --------
			|			|
	      (instances compacte)	[n'est pas stocké en tant que référence - bits]
			|		(1 bit d'une référence indique si l'objet est un SmallInteger ou non)
			bits		(la machine virtuelle fait abstraction de cela, vous ne pouvez pas le voir directement lors de l'inspection de l'objet.)

SmallInteger : 
--------------
SmallInteger n'a aucune ligne qui le rattache à un "Package" malgré que "Kernel" soit sélectionné dans le volet "Package". ?


package		sous-classe	inst.Variab.N. 	clas.Variab.N.	classe			protocol	methode		code
----------------------------------------------------------------------------------------------------------------------------------
aucune ligne	aucune ligne	'minVal maxVal'	aucune ligne	(E) SmallInteger class	constant	minVal		minVal	"Answer the minimum value for a SmallInteger."	^ minVal
aucune ligne	aucune ligne	'minVal maxVal'	aucune ligne	(E) SmallInteger class 	constant	maxVal		maxVal	"Answer the maximum value for a SmallInteger."	^ maxVal

Playground (CTRL+O+W)> SmallInteger maxVal = ((2 raisedTo: 30) - 1) (CTRL+P)> true
			SmallInteger maxVal = ((2 élevé à : 30) - 1)

Playground (CTRL+O+W)> SmallInteger minVal = (2 raisedTo: 30) negated (CTRL+P)> true
			SmallInteger minVal = (2 elevé à : 30) annulé 

Playground (CTRL+O+W)> (SmallInteger maxVal + 1) class (CTRL+P)> LargePositiveInteger
Playground (CTRL+O+W)> (SmallInteger minVal - 1) class (CTRL+P)> LargeNegativeInteger

Playground (CTRL+O+W)>	| n |
		(1)	n := 2. (CTRL+P)> 2 
		(2)	3 timesRepeat: [ n := n * n ]. (CTRL+P)> 3 // 3 ? ((1) 2x2=4-> n, (2) 4x4=16-> n, (3) 16x16=256-> n)
		(3)	n (CTRL+P)> 256

10.3 Caractères
Déjà signalé "Charactère" page 206. (Ci-dessous copie)

package			  	sous-classe	inst.Variab.N. 	clas.Variab.N.	classe		protocol	methode	     code
----------------------------------------------------------------------------------------------------------------------------------
			      | immediateScl.|
				-------------
Kernel-BasicObjects Magnitude  #Character	''		'CharSet	(E)   Character
								CharacterTable
								DigitValues'


"Le caractère est défini comme une sous-classe de  Magnitude"

"Les caractères imprimables sont représentés dans Pharo comme  $ <char>. Par exemple: $ a <$ b"

"Les caractères non imprimables peuvent être générés par diverses méthodes de classe."

Sous Windows lorsque l'utilisateur appuie sur la touche clavier "Alt + [numéros]" alors un caractère s'affiche.
par exemple : 
Alt + 123 = { 
Alt + 127 = caractère Unicode (Ce fichier contient des caractères au format Unicode qui seront perdues si vous l'enregistrez comme un fichier texte au format ANSI.
Pour conserver les informations Unicode, cliquez sur Annuler ci-dessous puis sélectionnez une des options Unicode à partir de la liste
déroulante Encodage. Voulez-vous continuer ?)
Alt + 128 = Ç

Playground (CTRL+O+W)> Character value: 1 (CTRL+P)> Character home
Playground (CTRL+O+W)> Character value: 2  (CTRL+P)> Character value: 2

Figure 10-14 - A décortiquer 13:52 19/02/2021

D11:23 19/02/2021 - F13:52 - Chapitre 10 - p.143/259 FR 210/376 EN
-------------------------------------------------------------------------------------------------------19/02/2021 fin



-------------------------------------------------------------------------------------------------------21/02/2021 debut
D12:24 21/02/2021 - F - Chapitre 10 - p.143/259 FR 210/376 EN
D12:24 21/02/2021 - F16:50 - Chapitre 10 - p.144/259 FR 211/376 EN

package			  			  sous-classe		  inst.Variab.N. clas.Variab.N.						classe				
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Collections-Abstract-Base  	Object		  #Collection		  ''		 ''							()Collection
Collections-Abstract-Base  	Object		  #SequenceableCollection ''		 ''							()SequenceableCollection
Collections-Abstract-Base  	Object		  #ArrayedCollection	  ''		 ''							()ArrayedCollection

package			  			  variable sous-classe	  inst.Variab.N. clas.Variab.N.						classe	
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Collections-Sequenceable-Base  	ArrayedCollection #Array		  ''		 ''							()Array

package			  			  sous-classe		  inst.Variab.N. clas.Variab.N.			poolDictionnaries	classe			
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Text-Core-Base			ArrayedCollection #Text			  'string runs'	 ''				'TextConstants'		()Text


Collections-Strings-Base	ArrayedCollection #String		  ''		 'AsciiOrder CSLineEnders				()String
											 CSNonSeparators CSSeparators
											 CaseInsensitiveOrder
											 CaseSensitiveOrder
											 LowercasingTable Tokenish
											 TypeTable UppercasingTable'

package			  			  variable sous-classe	  inst.Variab.N. clas.Variab.N.						classe	
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Collections-Strings-Base	String		 #ByteString		  ''		 'NonAsciiMap						()ByteString
Collections-Strings-Base	String		 #Symbol		  ''		 'NewSymbols						¶Symbol (Alt+0182)
											 OneCharacterSymbols
											 SelectorTable
											 SymbolTable'

13:19 21/02/2021 - 10.4 Strings
"Une chaîne est une collection indexée qui ne contient que des caractères." (p.143 FR 210 EN)
Définition : Indexer : Lier les variations d’une valeur à celles d’une valeur prise comme référence.
[TECHNIQUE] Placer un élément mobile en face d’un index pour ajuster un mécanisme.

Cette collection indexée reste floue.

String = Abstrait
Chaînes -> instances de la classe concrète "ByteString".

Playground (CTRL+O+W)> 'hello world' class (CTRL+P)> "ByteString"
> 'hello world' className > "'ByteString'"
> 'hello world' asText > "a Text for 'hello world'"
> 'hello world' asArray > "{$h. $e. $l. $l. $o. Character space. $w. $o. $r. $l. $d}"
> 'hello world' asActionSequence > "a WeakActionSequence('hello world')"
> 'hello world' clone > "'hello world'"

> 'hel','lo' == 'hello' > "false"
> 'hello' at: 2 put: $u; yourself > "'hullo'"
> 'hello' at: 2 put: $â; yourself > "'hâllo'"
> 'hello' at: 3 put: $i; yourself > "'heilo'"

> 'hello' at: (3+1)-2 put: $i; yourself > "'hillo'"
> 'hello' at: (3-1)+2 put: $i; yourself > "'helio'"
> 'hello' at: (5-4)+4 put: $l; yourself > "'helll'" (superman)

> 'hello' at: 2 put: $u > "$u"
> 'h','llo' at: 2 put: $u > "$u"

package			sous-classe	inst.Variab.N.	clas.Variab.N.			classe		protocol		méthode
--------------------------------------------------------------------------------------------------------------------------------------------------
Kernel-Objets	Object	#Boolean	''		'DeOptimizeMustBeBoolean'	(C)Boolean	logical operations	& (Triangle bas : remplacer par les sous-classes)
													abstract
													overridden
Kernel-Objets	Object	#Boolean	''		'DeOptimizeMustBeBoolean'	(C)Boolean	controlling		ifTrue:ifFalse: (Triangle bas : remplacer par les sous-classes)
													abstract
													overridden
Kernel-Objets	Object	#Boolean	''		'DeOptimizeMustBeBoolean'	(C)Boolean	logical operations	not (Triangle bas : remplacer par les sous-classes)
													abstract
													overridden


* Boolean est la sous-classe abstraite des classes singleton False et True. (10.5 Booleans - p.144 FR 211 EN)
Kernel-Objets	Boolean	#False		''		''				(C)False
Kernel-Objets	Boolean	#True		''		''				(C)True


À retenir :
-----------

p.97 FR 142 EN - Figure 7-10

La flèche bleu (triangle bleu) pointant vers le haut indique que "ImageMorph>>drawOn:" remplace une méthode héritée,
(c'est à dire que la méthode "drawOn:" hérite de la classe Morph, "Morhp>>drawOn:")
	1 Morph -> 2 ImageMorph -> 3 drawOn:
La flèche bleu pointant vers la bas indique que la méthode est remplacée par les sous-classes. (Qu'elle est ? c'est-à-dire la méthode ? Oui)

& (Triangle bas : remplacer par les sous-classes)
ifTrue:ifFalse: (Triangle bas : remplacer par les sous-classes)
not (Triangle bas : remplacer par les sous-classes)

Question : 
----------
Est remplacé par la sous-classe "Responsibility" ou "Boolean" ou les deux ? "Les deux, alors dans ce cas comment ça fonctionne ?"
Ce remplacement par les sous-classes reste flou.

Ou alors remplacé par les trois classes : Boolean, False et True ?
&, ifTrue:ifFalse:, not = (volet méthode : clique droit : Inheritance) -> classe -> Boolean, False, True

Lorsqu'un clic est exécuté sur le triangle et sur les lignes des méthodes (&, ifTrue:ifFalse, not), celles-ci indiquent : False, True.

Pourtant dans les codes ci-dessous, il y a "subclassResponsibility" ?

Note : 
-----
En essayant de saisir le sens de ces objets, l'opacité apparaît.


Boolean-> & :
-------------
& aBoolean 
	"Evaluating conjunction. Evaluate the argument. Then answer true if 
	both the receiver and the argument are true."	
	"true & true >>> true"
	"true & false >>> false"
	"false & true >>> false"
	"false & false >>> false"

	self subclassResponsibility

False-> & :
----------
& aBoolean 
	"Evaluating conjunction -- answer false since receiver is false."

	^self

True-> & :
---------
& aBoolean 
	"Evaluating conjunction -- answer aBoolean since receiver is true."

	^aBoolean


Boolean-> ifTrue:ifFalse: :
---------------------------
ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock
	"If the receiver is true (i.e., the condition is true), then answer the value 
	of the argument trueAlternativeBlock. If the receiver is false, answer the 
	result of evaluating the argument falseAlternativeBlock. If the receiver 
	is a nonBoolean then create an error notification. Execution does not 
	actually reach here because the expression is compiled in-line."
	
	"(true ifTrue: [ 'That is true!' ] ifFalse: [ 'That is false!' ]) >>> 'That is true!'"
	"(false ifTrue: [ 'That is true!' ] ifFalse: [ 'That is false!' ])  >>> 'That is false!'"

	self subclassResponsibility


False-> ifTrue:ifFalse :
-----------------------
ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 
	"Answer the value of falseAlternativeBlock. Execution does not
	actually reach here because the expression is compiled in-line."

	^falseAlternativeBlock value


True-> ifTrue:ifFalse :
----------------------
ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock 
	"Answer with the value of trueAlternativeBlock. Execution does not 
	actually reach here because the expression is compiled in-line."

	^trueAlternativeBlock value

Boolean-> not :
---------------
not
	"Negation. Answer true if the receiver is false, answer false if the 
	receiver is true."
	"true not >>> false"
	"false not >>> true"

	self subclassResponsibility

False-> not : 
------------
not
	"Negation -- answer true since the receiver is false."

	^true

True-> not : 
------------
not
	"Negation--answer false since the receiver is true."

	^false

16:42 21/02/2021 - p.144 FR 211 EN


À retenir :
-----------

"Il est facile d'oublier que puisque les chaînes sont des collections, elles comprennent les mêmes messages que
les autres collections:"

Question : 
----------
Les autres collections qui sont ?

Playground (CTRL+O+W)> #hello indexOf: $o (CTRL+P)> "5"
> '*or*' match: 'zorro' > "true"
> '*z*or*' match: 'zorro' "true"
> '*z*r*' match: 'zorro' > "true"

Note : 
-----
Ça en fait des chapitres à consulter, tu n'en finis plus.

D12:24 21/02/2021 - F16:50 - Chapitre 10 - p.144/259 FR 211/376 EN
-------------------------------------------------------------------------------------------------------21/02/2021 fin



-------------------------------------------------------------------------------------------------------04/03/2021 debut
D10:58 04/03/2021 - F - Chapitre 10 - p.144/259 FR 211/376 EN
D10:58 04/03/2021 - F13:41 - Chapitre 10 - p.145/259 FR 213/376 EN

Playground (CTRL+O+W)> 4 factorial > 20
ifTrue: [ 'bigger' ]
ifFalse: [ 'smaller' ] (CTRL+P)> Variable or expression expected -> (4)

Playground (CTRL+O+W)> ( 1 > 2 ) & ( 3 < 4 ) (CTRL+P)> "false"		//"Désireux,doit évaluer les deux côtés "
			> ( 1 > 2 ) and: [ 3 < 4 ] > "false"		//"Paresseux, évaluer uniquement le récepteur"
			> ( 1 > 2 ) and: [ ( 1 / 0 ) > 0 ] > "false"	//"Le bloc d'argument n'est jamais exécuté, donc aucune exception"

Boolean-> and: :
----------------
and: alternativeBlock 
	"Nonevaluating conjunction. If the receiver is true, answer the value of 
	the argument, alternativeBlock; otherwise answer false without 
	evaluating the argument."
	
	"(true and: [true]) >>> true"
	"(true and: [false]) >>> false"
	"(false and: [true]) >>> false"
	"(false and: [Error signal]) >>> false"

	self subclassResponsibility


Boolean-> or: :
---------------
or: alternativeBlock 
	"Nonevaluating disjunction. If the receiver is false, answer the value of 
	the argument, alternativeBlock; otherwise answer true without 
	evaluating the argument."
	
	"(true or: [Error signal]) >>> true"
	"(true or: [false]) >>> true"
	"(false or: [true]) >>> true"
	"(false or: [3]) >>> 3"

	self subclassResponsibility

False-> and: :
--------------
and: alternativeBlock 
	"Nonevaluating conjunction -- answer with false since the receiver is false."
	"(false and: [ 1 error ])>>> false"
	
	^self

False-> or: :
--------------
or: alternativeBlock 
	"Nonevaluating disjunction -- answer value of alternativeBlock."
	" (false or: [ true ] )>>> true "
	
	^alternativeBlock value

True-> and: :
-------------
and: alternativeBlock 
	"Nonevaluating conjunction -- answer the value of alternativeBlock since
	the receiver is true."
	"(true and: [ false ]) >>> false"
	"(true and: [ true ]) >>> true"

	^ alternativeBlock value

True-> or: :
-------------
or: alternativeBlock 
	"Nonevaluating disjunction -- answer true since the receiver is true."
	"(true or: [ 1 error ])>>> true"
	
	^ self


"À faire  Essayez d'imaginer comment et: et ou: sont mis en œuvre. Vérifiez les implémentations en Boolean, True et False."

Il n'y aurait pas un moyen avec un "printOn" d'avoir une image de la mise en oeuvre de and: et or: ?

Recherche : imaginer
----------

p.40 FR
Notez qu'il y a une petite flèche verte à côté de votre méthode (voir Figure  3-7 ) . Cela signifie que la méthode
existe dans la superclasse et qu'elle est remplacée dans votre classe.

D10:58 04/03/2021 - F13:41 - Chapitre 10 - p.145/259 FR 213/376 EN
-------------------------------------------------------------------------------------------------------04/03/2021 fin



-------------------------------------------------------------------------------------------------------09/03/2021 debut
D08:18 09/03/2021 - F - Chapitre 10 - p.145/259 FR 213/376 EN
D08:18 09/03/2021 - F13:43 - Chapitre 10 - p.147/259 FR 216/376 EN
- 30 mn
- 15 mn


À retenir : Un paquet de choses dans ce Chapitre 10.6
-----------

"Si vous remplacez =, vous devez également remplacer le hachage."

"remplacer le hachage" OK super ! Est-ce qu'il y aurait une touche "Rappel" ?
Qu'est-ce que c'est le hachage ? (Recherche de hachage dans les notes)

"[INFORMATIQUE] Opération consistant à transformer un message de taille variable en un code de taille fixe 
en appliquant une fonction mathématique dans le but d’authentifier ou de stocker ce message. 
La signature numérique et l’adressage dispersé utilisent la méthode du hachage."

Remplacer postCopy ... 
Renvoyer self subclassResponsibility ...
Remplacer printOn: ...
Remplacer la méthode de hook ...
Tous les caractères sont comme des instances uniques.
Les chaines sont mutables mais pas les symboles.
Ne pas muter les littéraux de chaine.
Les symboles sont uniques mais pas les chaines.
Les chaines et les symboles sont des collections et prennent en charges les méthodes de collection.

10:40 09/03/2021
* La liste s'allonge, et je passe plus de temps à essayer de démêler et retenir des choses plus tôt qu'à programmer. 

10.7 Collections ? (10.7) rien 10.08 Introduction

10:49 09/03/2021
10.8 Prénsentation

* "Les classes de collection forment un groupe vaguement défini de sous-classes générales de Collection et Stream"
VAGUEMENT !

Package								Sous-classe		Inst.Variab.N.	Clas.Variab.N.			Classe				Protocol			
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------- (C)ProtoObject -> (C)Object -> (C) Stream (Collections-Streams) ---------------------------------

DeprecatedFileStream-Base		ReadWriteStream		#FileStream		''		'Stderr Stdin StdioFiles	(C)Filestream (barré ?)
													Stdout TheStioHandles'

---------------------------------------------------- (C)ProtoObject -> (C)Object -> () Collection (Collections-Abstract) ---------------------------------
								VariableWord
Graphics-Primitives-Base		ArrayedCollection	#Bitmap			''		''				()Bitmap

								variableByte
Kernel-Methods				CompiledCode 		#CompiledMethod		''		''				()CompiledMethod

Collections-Abstract-Base		Collection		#SequenceableCollection	''		''				()SequenceableCollection

																					Protocol
Collections-Unordered-Dictionaries 	HashedCollection	#Dictionary		''		''				()Dictionary			array
																					tally	
Collections-Unordered-Dictionaries	Dictionary		#KeyedTree		''		''				()KeyedTree

Collections-Sequenceable-Base		SequenceableCollection	#LinkedList		'firsLink	''				()LinkedList			 
											lastLink'
---------------------
Collections-Sequenceable-Base
---------------------
Arrayed 		Ordered		Hashed		Linket		Interval
implementation		implementation	implementation	implementation	implementation
Array			Heap				LinkedList	Interval

* Figure 10-19 Certaines classes de collection classées par technique d'implémentation.

		

"La programmation avec des collections utilisant des fonctions d'ordre supérieur plutôt que des éléments individuels est un moyen
important d'élever le niveau d'abstraction d'un programme. (Figure 10-18)
La carte de fonction Lisp, qui applique une fonction d'arguemnt à chaque élément d'une liste et retourne une nouvelle liste contenant 
les résultats."

Langages de programmation fonctionnels : ML, Haskell.

* fonction - le bloc (la fonction entre crochets) renvoie true.

p.147 FR 215 EN
* "La plupart des collections séquençables sont également indexables, c'est à dire que les éléments peuvent être récupérés 
avec le message at: anIndex. Array..."

p.147 FR 215 EN
* "Keyed: les instances de Dictionary et de ses sous-classes sont accessibles par des clés au lieu d'index."
"Keyed: Instances of Dictionary and its subclasses are accessed by keys instead of indices."
Des clés ? Comment voir c'est clés ?

D08:18 09/03/2021 - F13:43 - Chapitre 10 - p.147/259 FR 216/376 EN
-------------------------------------------------------------------------------------------------------09/03/2021 fin



-------------------------------------------------------------------------------------------------------12/03/2021 debut
D17:24 12/03/2021 - F - Chapitre 10 - p.147/259 FR 216/376 EN
D17:24 12/03/2021 - F18:07 - Chapitre 10 - p.152/259 FR 223/376 EN

10.11 Exemples de classes clés
-------------------------------
Les principaux protocoles de collections sont:
* messages à:, à:mettre: - pour accéder à un élément,
* messages ajouter:, supprimer: - pour ajouter ou supprimer un élément,
* la taille des messages, isEmpty, comprend: - pour obtenir des informations sur la collection,
* les messages font:, Collect:, sélectionnez: - itérer sur la collection.

 The main protocols of collections are:
* messages at:, at:put: — to access an element,
* messages add:, remove: — to add or remove an element,
* messages size, isEmpty, include: — to get some information about the collection,
* messages do:, collect:, select: — to iterate over the collection.


17:49 12/03/2021
ordered collection - collection ordonnée
| ordCol | > (CTRL+P)> nil
ordCol := OrderedCollection new. > (CTRL+P)> "an OrderedCollection()"
ordCol add: 'Seaside'; add: 'SmalltalkHub'; addFirst: 'Monticello'. > (CTRL+P)> 'Montecillo'
ordCol > (CTRL+P)> "an OrderedCollection('Monticello' 'Seaside' 'SmalltalkHub')"

removing elements - suppression d'éléments
ordCol add: 'Monticello'. > (CTRL+P)> "'Monticello'"
ordCol remove: 'Monticello'. > (CTRL+P)> "'Monticello'"
ordCol > (CTRL+P)> "an OrderedCollection('Seaside' 'SmalltalkHub' 'Monticello')"


À retenir :
-----------

"d'autre part, vos clés sont des chaînes, il vaut mieux utiliser un dictionnaire simple, ou vous pouvez avoir des ennuis."

Blablablablablablablablablablablablablablablablablablablablablablablablablablablablablablablablablablablablablablablablablablabla:.

D17:24 12/03/2021 - F18:07 - Chapitre 10 - p.152/259 FR 223/376 EN
-------------------------------------------------------------------------------------------------------12/03/2021 fin



-------------------------------------------------------------------------------------------------------13/03/2021 debut
D09:36 13/03/2021 - F - Chapitre 10 - p.152/259 FR 223/376 EN
D09:36 13/03/2021 - F10:56 - Chapitre 10 - p.152/259 FR 223/376 EN

Synthèse des élements - p. 148 FR 217 EN
---------------------

 - The main protocols of collections 
	* messages at:, at:put:
	* messages add:, remove:
	* messages size, isEmpty, include:
	* messages do:, collect:, select:

 - Common creation protocol
	* message new: aSize
	* with: anElement
	* with: 
	* with: with:
	* with: with: with:
	* with: with: with: with:
	* with: with: with: with: with:
	* with: with: with: with: with: with:
    + aCollection
	* addAll:
	* withAll:

 - Array
	* at:
	* at: put:
	* at: anInteger
	* put: anObject

	* new:
	* with:
	* #()
   + Dynamic creation   	
	* { . }
   + Element Access
	* at: anIndex
	* at: anIndex put: an Object

 - OrderedCollection --------------------
	* add:				|
	* addFirst:			|
	* addLast:			|
	* addAll:		       \|/ ?
   + Removings Elements			|
	* remove: 			|
	* remove: ifAbsent: (variant)	|
   + Conversion				|
	* asOrderedCollection------------
   + Interval
	* (Interval from: to:) = ( to: )
	* (Interval from: to: by:) size
	* (  to: by: ) at:
	* (  to: by: ) last
	* class> from: to: by:
	* number> from: to: by:

 - Dictionary
	* :=
	* colors := Dictionary new.

	* at: aKey
	* at: aKey put: aValue
	* colors at: #yellow put: Color yellow.
	* values
	* at: aKey ifAbsent: aBlock

	* newFrom:
	* removKey
	* associations
	


* "Les dictionnaires comparent les clés par égalité. Deux clés sont considérées comme identiques 
si elles renvoient true lorsqu'elles sont comparées à l'aide de "="."

D09:36 13/03/2021 - F10:56 - Chapitre 10 - p.152/259 FR 223/376 EN
-------------------------------------------------------------------------------------------------------13/03/2021 fin



-------------------------------------------------------------------------------------------------------15/03/2021 debut
D09:34 15/03/2021 - F - Chapitre 10 - p.152/259 FR 223/376 EN
D09:34 15/03/2021 - F13:23 - Chapitre 10 - p.152/259 FR 223/376 EN


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

"Un bogue courant - :-( "


* "Un bogue courant et difficile à repérer est d'utiliser comme clé un objet dont la méthode = a été redéfinie mais pas sa méthode de hachage." 

"Nous pouvons créer un dictionnaire à partir d'une collection d'associations,
     ou |->   convertir un dictionnaire en un tableau d'associations."


SOMMAIRE 

A. Le code ne fonctionne pas, (Livret Copier/Coller -> Playground)
B. Le code fonctionne, (Livret Copier/Coller -> Playground -> Modification)
C. Le code fonctionne, (Le lecteur tape le code -> Playground) 


A. Le code ne fonctionne pas : (Livret Copier/Coller -> Playground)
------------------------------

A.1 Résultat du copier/coller livret -> Playground.

| colors |
colors := Dictionary newFrom: { #blue->Color blue . #red->Color red
. #yellow->Color yellow }.
colors removeKey: #blue.
colors associations


A.2 Dans le livret, le point de "Color red." est à la ligne suivante.
Demande de la réponse à partir de la troisième ligne. (Print It (CTRL+P))
D'une copie du code vers playground à un autre la réponse peut-être différente. (4e ligne)

1 Playground (CTRL+O+W)> | colors | 					
2 colors := Dictionary newFrom: { #blue->Color blue . #red->Color red
3 . #yellow->Color yellow }. 						(CTRL+P) > Unknow input at end ->
4 colors removeKey: #blue. 						(CTRL+P) > KeyNotFound: key #blue not found in Dictinary
5 colors associations							(CTRL+P) > #colors is missing, and does not understand #associations


A.3 Demande de la réponse à partir de la troisième ligne.
D'une copie du code vers playground à un autre la réponse peut-être différente. (4e ligne)

1 Playground (CTRL+O+W)> | colors | 										
2 colors := Dictionary newFrom: { #blue->Color blue . #red->Color red
3 . #yellow->Color yellow }. 						(CTRL+P) > Unknow input at end ->
4 colors removeKey: #blue. 						(CTRL+P) > #colors is missing, and does not understand #removeKey:
5 colors associations							(CTRL+P) > #colors is missing, and does not understand #associations


A.4 Demande de la réponse à partir de la première ligne.

1 Playground (CTRL+O+W)> | colors | 					(CTRL+P > nil					
2 colors := Dictionary newFrom: { #blue->Color blue . #red->Color red
3 . #yellow->Color yellow }. 						(CTRL+P) > Unknow input at end ->
4 colors removeKey: #blue. 						(CTRL+P) > #colors is missing, and does not understand #removeKey:
5 colors associations							(CTRL+P) > #colors is missing, and does not understand #associations


B. Le code fonctionne : (Livret Copier/Coller -> Playground -> Modification)
-----------------------

Lors des exercices avec ProfStef, les points se situent après le mot, or avec "Color blue .", j’ai pensé à une erreur de frappe.
Puis dans le livret, il y a un Enorme espace à la troisième ligne et le point de "Color red." est à la ligne suivante. (?)
Donc, j'en ai conclu qu'il s'agissait d'une erreur de copie.

B.1 Résultat du livret copier/coller -> Playground -> Modification -> Playground résultat copier/coller -> Bloc-notes.
(Suppression de l'espace situé sur la troisième ligne et aucun espace entre les points "blue" et "red".)

| colors |
colors := Dictionary newFrom: { #blue->Color blue. #red->Color red. #yellow->Color yellow }.
 "a Dictionary(#blue->Color blue #red->Color red #yellow->Color yellow )"colors removeKey: #blue.
 "Color blue"colors associations "{#yellow->Color yellow. #red->Color red}"


B.2 Demande de la réponse à partir de la première ligne.

1 Playground (CTRL+O+W)> | colors | 								(CTRL+P) > nil
2 colors := Dictionary newFrom: { #blue->Color blue. #red->Color red. #yellow->Color yellow }.  (CTRL+P) > "a Dictionary(#blue->Color blue #red->Color red #yellow->Color yellow )"
3 colors removeKey: #blue. 									(CTRL+P) > "Color blue"
4 colors associations 										(CTRL+P) > "{#yellow->Color yellow. #red->Color red}"


A. Le code ne fonctionne pas, (Livret Copier/Coller -> Playground)
B. Le code fonctionne, les points n'ont pas d'espaces, (Livret Copier/Coller -> Playground -> Modification)
C. Le code fonctionne, les points ont des espaces. (Le code est tapé dans Playground et je m'interroge sur l'espacement du point) 

C. Le code fonctionne : (Le lecteur tape le code -> Playground)
-----------------------

Il m'a fallu 02 min et 24 secondes pour taper le code et m'interroger sur l'espacement du point après "Color blue".
Étant donné que précédemment j'ai testé le code avec les points collés aux couleurs alors dans le cas présent, 
j'ai mis des espaces entre les points. 

C.1 Le lecteur tape le code dans Playground et met des espaces entre les points "blue" et "red".

1 Playground (CTRL+O+W)> | colors | 								 (CTRL+P) > nil
2 colors := Dictionary newFrom: { #blue->Color blue . #red->Color red . #yellow->Color yellow }. (CTRL+P) > "a Dictionary(#blue->Color blue #red->Color red #yellow->Color yellow )"
3 colors removeKey: #blue. 									 (CTRL+P) > "Color blue"
4 colors associations 										 (CTRL+P) > "{#yellow->Color yellow. #red->Color red}"


Notes : 
------
Pour commencer, la lecture de ce livret est barbante et prise de tête.
Ensuite, dans la majorité des cas le code présenté dans le livret est très nettement plus simple et rapide 
à le copier et le coller plutôt que de le taper.

Il serait intéressant de savoir combien de lecteurs copier et colle le code et ceux qui le tapent.

Il m'a fallu 02 min et 24 secondes pour taper le code en m'efforçant d'omettre aucune erreur.
(Code départ 10:24:00 - Fin 10:26:24 = 00:02:24 min)

Dernier point, l'appropriation du livret est différente d'un lecteur à l'autre ainsi que des créateurs et ces "Objets <-> codes" 
sont catégoriquement source d'incompréhension, d'erreurs et manque de fiabilité.


Par rapport à l'incident ci-dessus des questions se posent : 
Pour arrêter les erreurs de codage et accélérer la création de celui-ci, peut-être serait-il préférable de créer des blocs graphiques ? (Scratch, Blockly, Code.org) 
(Des intelligences artificielles communiquent en se transmettant des suites de ".").

J'ai l'impression que les programmeurs sont comme des chevaux marchant avec des oeillères 
ou rattachée à cette pensée philosophique de Bruce Lee qui dit : 
"Ne fixe pas ton intention sur ton doigt sinon tu passeras à côté de toute la beauté céleste". (Bruce Lee)


11:59 15/03/2021
IdentityDictionary

Dictionary
----------
* HashedCollection <- Dictionary (Dictionnaire) : utilise le résultat des messages "=" et "hash" pour déterminer si deux clés sont identiques.


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

Dictionary -> clés "strings". (Si vos clés sont des chaines alors il vaut mieux utiliser un dictionnaire simple sinon vous aurez des ennuis)

"Nous pouvons créer un dictionnaire à partir d'une collection d'associations, 
     ou |->   convertir un dictionnaire en un tableau d'associations."

Utiliser comme clés -> Objet globalement unique -> Strings -> Dictionary

IdentityDictionary
------------------
* Dictionary <- IdentityDictionary (Dictionnaire d'identité) : utilise le message "==" de la clé au lieu de ses valeurs.
Elle considère que deux clés sont égales uniquement si elles sont le même objet.

Utiliser comme clés -> Objet globalement unique -> Symbols ou SmallIntegers -> IdentityDictionary


Package								Sous-classe		Inst.Variab.N.	Clas.Variab.N.			Classe				Protocol			
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
						ProtoObject
						Object
						Collection
						/|
						 |
Collections-Unordered-Dictionaries	HashedCollection   <---	#Dictionary		''		''				()Dictionary
									 |
						/|----------->-----------|\
						 |
Collections-Unordered-Dictionaries	Dictionary         <---	#IdentityDictionary	''		''				()  IdentityDictionary								
		|							 |
		(?)				/|----------->-----------|\
		|				 |
System-Support-Utilities	IdentityDictionary <---	#SystemDictionary	'cachedClassNames 	''				()  	SystemDictionary
										cachedNonClassNames 
										cachedBehaviors'

(?) > Comment passe le message (signal) ? 
Est-ce que le message est envoyé de la classe "SystemDictionary" vers la classe "IdentityDictionary" ?

Ou bien la classe "SystemDictionary" transmet à son package "System-Support-Utilities", "System-Support", "Collections-Unordered"
et enfin la classe "IdentityDictionary" ?

"SystemDictionary" -> "System-Support-Utilities" -> "System-Support" -> "Collections-Unordered" -> "Collections-Unordered-Dictionaries" -> "IdentityDictionary"


Erreur : 
--------

Playground (CTRL+O+W) > 
a := 'foobar'. 				(CTRL+P) > "'foobar'"
b := a copy.  				(CTRL+P) > "'foobar'"
trouble := IdentityDictionary new.	(CTRL+P) > "an IdentityDictionary()"
trouble at: a put: 'a'; at: b put: 'b'. (CTRL+P) > "'b'"
trouble at: a 				(CTRL+P) > "'a'"
[[[testcase=true 
			trouble at: b	(CTRL+P) > "'b'"

trouble at: 'foobar' 			(CTRL+P) > KeyNotFound: key 'foobar' not found in IdentityDictionary 

D09:34 15/03/2021 - F13:23 - Chapitre 10 - p.152/259 FR 223/376 EN
-------------------------------------------------------------------------------------------------------15/03/2021 fin



-------------------------------------------------------------------------------------------------------17/03/2021 debut
D11:17 17/03/2021 - F - Chapitre 10 - p.152/259 FR 223/376 EN
- 10min
D11:17 17/03/2021 - F13:10 - Chapitre 10 - p.152/259 FR 223/376 EN


11:58 17/03/2021
Playground (CTRL+O+W)	> Smalltalk globals keys collect: [ :each | each class ] as:Set (CTRL+P) > "a Set(ByteSymbol)"
			> Smalltalk keys collect: [ :each | each class ] as:Set 	(CTRL+P) > Instance of SmalltalkImage did not understand #keys
			> #SmallIntegers keys collect: [ :each | each class ] as:Set 	(CTRL+P) > Instance of ByteSymbol did not understand #keys
			> SmallIntegers keys collect: [ :each | each class ] as:Set 	(CTRL+P) > Unknown variable: SmallIntegers please correct, or cancel:
			> Symbol keys collect: [ :each | each class ] as:Set 		(CTRL+P) > Instance of Symbol class did not understand #keys
			> Symbols keys collect: [ :each | each class ] as:Set 		(CTRL+P) > Unknown variable: Symbols please correct, or cancel:
			> #Symbols keys collect: [ :each | each class ] as:Set 		(CTRL+P) > Instance of ByteSymbol did not understand #keys
			> Symbol globals keys collect: [ :each | each class ] as:Set	(CTRL+P) > Instance of Symbol class did not understand #globals
			> #Symbols globals keys collect: [ :each | each class ] as:Set	(CTRL+P) > Instance of ByteSymbol did not understand #globals
			> Smalltalk globals keys collect: [ :each | each class ]	(CTRL+P) > Affiche une multitude de "{ByteSymbol. ByteSymbol. ByteSymbol...etc..."
			> Smalltalk globals keys collect: [ :each | each class ] as:IdentitySet		(CTRL+P) > "an IdentitySet(ByteSymbol)"
			> Smalltalk globals keys collect: [ :each | each class ] as:PluggableSet	(CTRL+P) > "a PluggableSet(ByteSymbol)"


Canard boiteux : 
----------------
"Notez que l'expression Smalltalk globals renvoie une instance de SystemDictionary".

Dans (C)SystemDictionary aucune expression "Smalltalk globals", donc où est-il ?

Finder> Search> Source	> Smalltalk globals > systemDictionary  ((M)systemDictionary est différent de (C)SystemDictionary)
			> ByteSymbols : rien
			> Symbols : rien -> globalSymbols ? (Smalltalk globals - Symbol globals ?)
			> Strings : rien
			

Note : 
------
Le raccourci clavier (CTRL+M) ne fonctionne pas dans "Finder", il faut cliquer sur le bouton "Implementors".

Package				Sous-classe		Inst.Variab.N.		Clas.Variab.N.	Classe			Protocol Method		
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Refactoring-Environment	Object	#RBBrowserEnvironment	'label searchStrings'	''		(C)RBBrowserEnvironment	private	 systemDictionary			


D11:17 17/03/2021 - F13:10 - Chapitre 10 - p.152/259 FR 223/376 EN
-------------------------------------------------------------------------------------------------------17/03/2021 fin




-------------------------------------------------------------------------------------------------------19/03/2021 debut
D12:32 19/03/2021 - F - Chapitre 10 - p.152/259 FR 223/376 EN
D12:32 19/03/2021 - F13:45 - Chapitre 10 - p.153/259 FR 224/376 EN

Tu passes ton temps à interroger les choses pour savoir où se trouve quoi et ce que c'est.

Set - classe - collection sans éléments dupliqués et sans aucun ordre.


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

* set add: non accessible avec le message at:
* Les objets placés dans un ensemble doivent implémenter les méthodes hash et =.

Playground (CTRL+O+W)	> 
s := Set new. 			(CTRL+P) > "a Set()"
s add: 4/2; add: 4; add:2.	(CTRL+P) > "2"
s size 				(CTRL+P) >"2"


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

"Vous pouvez également créer des ensembles en utilisant la classe Set>>newFrom: ou la conversion message Collection>>asSet:"

Question :
----------
Des messages sont assemblés et cet ensemble affiche "true", c'est une réponse à la création ?


SANS DOUBLON
------------

Compare deux ensembles : 
------------------------
Playground (CTRL+O+W)	> 
(Set newFrom: #( 1 2 3 1 4 )) = #(1 2 3 4 3 2 1) asSet 	(CTRL+P) > true


asSet nous offre un moyen pratique d'éliminer les doublons d'une collection:

Question :
----------
Les doublons, quels doublons ?
 
{ Color black. Color white. (Color red + Color blue + Color green) }
asSet size
>>> 2
 
Notez que  rouge + bleu + vert = blanc. 

Question : 
----------
Un ensemble de couleur est égal à blanc, mais cela n'explique pas pourquoi le résultat est "2".
Résultat ci-dessous à la 4e réponse.

La note ne m'a pas permis de comprendre contrairement au lancement du code ci-dessous.
La réponse aurait pu être "2 white", c'est calculer des grammes sans pour autant mettre 2 patates.

Playground (CTRL+O+W)	> 
{ Color black. Color white. (Color red + Color blue + Color green) }
asSet size

1: Le résultat est entre guillemet et après l'accolade.
{ Color black.	(CTRL+P) > Color white. (Color red + Color blue + Color green) } "{Color black. Color white. Color white}"
asSet size

2
{ Color black.	Color white. (CTRL+P) > (Color red + Color blue + Color green) } "{Color black. Color white. Color white}"
asSet size

3
{ Color black.	Color white. (Color red + Color blue + Color green) (CTRL+P) > } "{Color black. Color white. Color white}"
asSet size

4 : Ça y est, j'ai compris pourquoi la réponse est "2".
{ Color black.	Color white. (Color red + Color blue + Color green) } (CTRL+P) > "{Color black. Color white. Color white}"
asSet size

5
{ Color black.	Color white. (CTRL+P) > (Color red + Color blue + Color green) }
asSet size  (CTRL+P) > Error: Instances of UndefinedObject are not indexable

6: Playground n'aime pas le copier/coller provenant du livret.
{ Color black. Color white. (Color red + Color blue + Color green) } asSet size (CTRL+P) >
 "2"

D12:32 19/03/2021 - F13:45 - Chapitre 10 - p.153/259 FR 224/376 EN
-------------------------------------------------------------------------------------------------------19/03/2021 fin



-------------------------------------------------------------------------------------------------------21/03/2021 debut
D11:13 21/03/2021 - F - Chapitre 10 - p.153/259 FR 224/376 EN
D11:13 21/03/2021 - F13:47 - Chapitre 10 - p.154/259 FR 225/376 EN

Set = ensemble
Bag = sac

	Collection messages
----------------------
	union:
	intersection:
	includes - membership test - test d'appartenance

recepteur	set

		message unary yellow				    message binary + 20
	      ----------------					 -------------------
	      |	      	      |					 |                  |
objet->	          X       <-			   objet->             X         <-	  
    /		  X	      \	    			/	       X   	    \  
  receiver     message selector message argument      	receiver   m.selector  	 message argument
Convert Set					  Convert Set
    |	   	  X   	        |     X   		|	       X     	     |      X
    |		 ms             |      ma 		|	       ms     	     |       ma
   :(2)           X  --->----->--        X  		:(2)	       X  --->----->--         X
    |		  X /		         X		|	       X /		       X
(keymessage) (1)   <- (class send)  <-     	(keymessage) (1)    <- (objet send) <-  
      	     |				     | 		  	 |				 |
	     ----------------------------------			 ---------------------------------
	           a message send					a message send


	 Collection -> union: 					Collection -> intersection: 
	|------------------------|				|-----------------|
	        a message					     a message


Playground (CTRL+O+W)	>  	
			(1 to: 6) union: (4 to: 10) 	(CTRL+P) > "#(1 2 3 4 5 6 7 8 9 10)"
			(6 to: 1) union: (4 to: 10)	(CTRL+P) > "#(4 5 6 7 8 9 10)"
			(-1 to: 1) union: (4 to: 10)	(CTRL+P) > "#(0 1 4 5 6 7 8 9 10 -1)"
			(1 to: 12) union: (10 to: 4)	(CTRL+P) > "#(1 2 3 4 5 6 7 8 9 10 11 12)"
			(1 to: 5) union: (10 to: 4)	(CTRL+P) > "#(1 2 3 4 5)"
			'he1llo' intersection: 'the1re	(CTRL+P) > ' "'1eh'"	(Comparaison ?)
			#Smalltalk0 includes: $k0	(CTRL+P) > End of statement list encountered ->
			#Smalltalki includes: $ki	(CTRL+P) > Instance of Character did not understand #i
			#Smalltalki includes: $k$i	(CTRL+P) > End of statement list encountered -> 


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

"Comme nous l'expliquons ci-dessous, les éléments d'un ensemble sont accessibles à l'aide d'itérateurs (voir la section 10.12)."
Oui, super ! 

Rappel :
-------
OrderedCollections et SortedCollections stockent leurs éléments dans un tableau référencé par l'une des variables d'instance de la collection. 
Par conséquent, la baie interne peut être remplacée par une plus grande si la collection dépasse sa capacité de stockage. 

Déjà, il y a un distinguo entre les classes Ordered, Sortered et les méthodes asOrdered, asSortered et cette confusion m'incite à chercher et vérifier. 

Classes de Collection : 
-----------------------
OrderedCollection est l'une des collections qui peuvent s'agrandir et auxquelles des éléments peuvent être ajoutés séquentiellement. 
(Collection ordonnée)
153
SortedCollection conserve ses éléments dans l'ordre de tri. Par défaut, une collection triée utilise le message <= pour établir l'ordre de tri,
(Collection sortable) afin de pouvoir trier les instances de sous-classes de la classe abstraite Magnitude, 
qui définit le protocole d'objets comparables ( < ,  = ,  > ,  > = ,  entre: et: ...).

Methodes de Collection : 
------------------------

asSortedCollection tri une chaîne par exemple : "hello" -> "ehllo".


Package							Sous-classe	   Inst.Variab.N.	Clas.Variab.N.	Classe		Protocol 	Method		
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
Collections-Sequenceable-Ordered SequenceableCollection #OrderedCollection 'array 		''		()OrderedCollection
									   firstIndex 
									   lastIndex'
Collections-Sequenceable-Ordered OrderedCollection 	#SortedCollection  'sortBlock'		''		()SortedCollection

Collections-Abstract-Base	 Object			#Collection	   ''			''		()Collection	Converting	asOrderedCollection
Collections-Abstract-Base	 Object			#Collection	   ''			''		()Collection	Converting	asSortedCollection

Également : asSortedCollecion avec ":", histoire d'embrouiller le code un peu plus. 
Collections-Abstract-Base	 Object			#Collection	   ''			''		()Collection	Converting	asSortedCollection:

Note :
------
Playground affiche "implementors" lorsque c'est une méthode, mais ouvre "system browser" quand c'est une classe. (?)

Playground (CTRL+O+W)	>  
			(CTRL+M) > (implementors)
asOrderedCollection est aussi implenté dans "Object, Array2D, CompileCode, OrderedCollection, GLMAnnouncingCollection, GTSpotterIterator".
asSortedCollection est implente dans "Collection, Array2D".

	SortedCollection 
		Message <= (Etabli l'ordre de tri)
		|
		Instances de sous-classe
			|
			classe abstraite Magnitude
				|
				Protocol d'objets comparables (<, =, >=, between:, add:,...)

* asString retourne malheureusement la représentation printString, ce qui n'est pas ce que nous voulons :
* Pharo et son livret retournent malheureusement la non-représentation annoncée dans la vidéo publicitaire.

Playground (CTRL+O+W)	>  
			'hello' asSortedCollection printString	(CTRL+P) > "'a SortedCollection($e $h $l $l $o)'"
			'hello' asSortedCollection asString	(CTRL+P) > "'a SortedCollection($e $h $l $l $o)'"
			'hello' asString			(CTRL+P) > "'hello'"
			
			'hello' asSortedCollection as: String		(CTRL+P) > "'ehllo'"
			String newFrom: 'hello' asSortedCollection	(CTRL+P) > "'ehllo'"
			String withAll: 'hello' asSortedCollection	(CTRL+P) > "'ehllo'"


* Imaginez que vous souhaitiez trier des objets qui ne définissent pas la méthode <= 
Il faut le pense-bête à proximité sinon tu es à la rue.

D11:13 21/03/2021 - F13:47 - Chapitre 10 - p.154/259 FR 225/376 EN
-------------------------------------------------------------------------------------------------------21/03/2021 fin



-------------------------------------------------------------------------------------------------------26/03/2021 debut
D10:27 26/03/2021 - F - Chapitre 10 - p.154/259 FR 225/376 EN
D10:27 26/03/2021 - F - Chapitre 10 - p.154/259 FR 226/376 EN

Remarques : 
----------
"The correct answer is to either use String class>>newFrom:, String class>>withAll: or Object>>as::"

1.
'hello' asSortedCollection as: String
>>> 'ehllo'
2.
String newFrom: 'hello' asSortedCollection
>>> 'ehllo'
3.
String withAll: 'hello' asSortedCollection
>>> 'ehllo'

1. Les réponses à utiliser ne sont pas classées similairement aux sorties des codes d'exemples.  
2. La réponse à utiliser "String class>>newFrom:" - (1 String, 2 classe 3, newFrom:) n'est pas similaires à "String newFrom: 'hello' asSortedCollection" (1 String, 2 newFrom:, 3 classe)
3. "asSortedCollection" est une méthode, alors pourquoi la réponse à utiliser indique-t'elle une classe ?
4. "Object>>as::", correspondrait au 1er exemple ci-dessus, auquel il manquerait ":" ?

1.			Object>>as::
Playground (CTRL+O+W)	>  	
			'hello' as: String 			(CTRL+P) > "'hello'"
			'hello' asSortedCollection as: String 	(CTRL+P) > "'ehllo'"
			asSortedCollection 'hello' as: String 	(CTRL+P) > End of statement list encountered -> 

2.			String class>>withAll:
Playground (CTRL+O+W)	>  	
			String asSortedCollection withAll: 'hello'	(CTRL+P) > Instance of String class did not understand #asSortedCollection

3.			String class>>newFrom:
Playground (CTRL+O+W)	>  	
			String asSortedCollection newFrom: 'hello'	(CTRL+P) > Instance of String class did not understand #asSortedCollection

Playground (CTRL+O+W)	> 
			{ 5 . 2/ -3 . 5.21 } asSortedCollection 		(CTRL+P) > "a SortedCollection((-2/3) 5 5.21)"
			'{ 5 . 2/ -3 . 5.21 }' asSortedCollection as: String	(CTRL+P) > "'       -.../122355{}'"
			'5 . 2/ -3 . 5.21' asSortedCollection as: String	(CTRL+P) > "'     -.../122355'"
			String asSortedCollection withAll: { 5 . 2/ -3 . 5.21 } (CTRL+P) > Instance of String class did not understand #asSortedCollection
			String asSortedCollection withAll: '{ 5 . 2/ -3 . 5.21 }'(CTRL+P) > Instance of String class did not understand #asSortedCollection
			String asSortedCollection withAll: '5 . 2/ -3 . 5.21'	(CTRL+P) > Instance of String class did not understand #asSortedCollection


0. 00:01:43 min pour recopier le code ci-desssous dans Playground.

1. N'affiche pas le même message que celui du livret. Erreur
Playground (CTRL+O+W)	> 
col := SortedCollection 							(CTRL+P) > "SortedCollection"
sortBlock: [ :c1 :c2 | c1 luminance <= c2 luminance ].				(CTRL+P) > Variable or expression expected ->
col addAll: { Color red . Color yellow . Color white . Color black }.		(CTRL+P) > Instance of SortedCollection class did not understand #addAll:
col										(CTRL+P) > "SortedCollection"

2. Un espace est enlevé entre la 1 et 2 ligne du code ci-dessus. Fonctionne
Playground (CTRL+O+W)	> 
col := SortedCollection sortBlock: [ :c1 :c2 | c1 luminance <= c2 luminance ].	(CTRL+P) > "a SortedCollection()"
col addAll: { Color red . Color yellow . Color white . Color black }.		(CTRL+P) > "{Color red. Color yellow. Color white. Color black}"
col										(CTRL+P) >  "a SortedCollection(Color black Color red Color yellow Color white)"

* La syntaxe tient dans une carte postale, mais ensuite il faut apprendre toutes les méthodes, classes, etc.
Ce n'est plus une carte postale, mais un bottin.

Synthèse des élements - p. 148 FR 217 EN
---------------------

 - The main protocols of collections 
	* messages at:, at:put:
	* messages add:, remove:
	* messages size, isEmpty, include:
	* messages do:, collect:, select:

 - Common creation protocol
	* message new: aSize
	* with: anElement
	* with: 
	* with: with:
	* with: with: with:
	* with: with: with: with:
	* with: with: with: with: with:
	* with: with: with: with: with: with:
    + aCollection
	* addAll:
	* withAll:

 - Array
	* at:
	* at: put:
	* at: anInteger
	* put: anObject

	* new:
	* with:
	* #()
   + Dynamic creation   	
	* { . }
   + Element Access
	* at: anIndex
	* at: anIndex put: an Object

 - OrderedCollection --------------------
	* add:				|
	* addFirst:			|
	* addLast:			|
	* addAll:		       \|/ ?
   + Removings Elements			|
	* remove: 			|
	* remove: ifAbsent: (variant)	|
   + Conversion				|
	* asOrderedCollection------------
   + Interval
	* (Interval from: to:) = ( to: )
	* (Interval from: to: by:) size
	* (  to: by: ) at:
	* (  to: by: ) last
	* class> from: to: by:
	* number> from: to: by:

 - Dictionary
	* :=
	* colors := Dictionary new.

	* at: aKey
	* at: aKey put: aValue
	* colors at: #yellow put: Color yellow.
	* values
	* at: aKey ifAbsent: aBlock

	* newFrom:
	* removKey
	* associations


p. 154 FR 226 EN
1.
String with: $A
>>> 'A'
2.
String with: $h with: $i with: $!
>>> 'hi!'
3.
String newFrom: #($h $e $l $l $o)
>>> 'hello'

? Object>>as:: - 'hello' asSortedCollection as: String

p. 152 FR 223 EN
Symbols (actually, ByteSymbols, which contain only 8-bit characters)
Symbols (en fait, ByteSymbols, qui ne contiennent que des caractères 8 bits)
Symbols (en fait, ByteSymbols, contient que des caractères 8 bits)

D10:27 26/03/2021 - F12:25 - Chapitre 10 - p.154/259 FR 226/376 EN
-------------------------------------------------------------------------------------------------------26/03/2021 fin



-------------------------------------------------------------------------------------------------------06/04/2021 debut
D10:56 06/04/2021 - F - Chapitre 10 - p.154/259 FR 226/376 EN

8 bits = ByteString
32 bits = WideString

Instances de String

Les chaînes sont délimitées par des guillemets simples, une chaîne peut contenir un seul quote:
pour définir une chaîne avec un guillemnt simple, nous devons la taper deux fois.

Ci-dessous, à la 1re ligne, il affiche le 3e caractère en partant de la gauche "'",
tandis qu'à la 2e ligne, il n’indique aucune correspondance alors qu'il s'agit là encore de "'",
à la 3e ligne, il affiche "i".

Donc, je ne comprends pas.
Pourquoi à la 1re ligne, Playground affiche "'" mais pas à la 2e ? Puisqu'ensuite il affiche "i" ?

Playground (CTRL+O+W)	> (at: = à: ) - (to = à:)
			'l''idiot' at: 2		(CTRL+P) > "$'"
			'l'idiot' at: 2			(CTRL+P) > Unmatched'in string literal.->
			'lidiot' at: 2			(CTRL+P) > "$i"
			'ldiot' at: 2 			(CTRL+P) > "$d"
			'l''idiot' at: 3		(CTRL+P) > "$i"
			s := 'no', ' ', 'worries'.	(CTRL+P) > "'no worries'"
			
			s := 'no', ' ', 'worries'.
			s				(CTRL+P) > "'no worries'"

			s := 'no', 'a''', 'worries'.	(CTRL+P) > "'noa''worries'"
			s := 'no', '''a', 'worries'.	(CTRL+P) > "'no''aworries'"
			s := 'no', ''a'', 'worries'.	(CTRL+P) > End of statement list encountered->
			
			s at: 4 put: $h; at: 5 put: $u.	(CTRL+P) > "$u"
			s at: 4 put: $h; at: 5 put: $u.			(Playground a mis les mots précédents dans une table "no worries", puis s'ajoute ceux-là.) 
			s				(CTRL+P) > "'no''huorries'"
			
			(1 to: 3), '45'			(CTRL+P) > "#(1 2 3 $4 $5)"
			(1 at: 3), '45'			(CTRL+P) > Error:Instances of SmallInteger are not indexable (at to ?)

D10:56 06/04/2021 - F12:20 - Chapitre 10 - p.155/259 FR 226/376 EN
-------------------------------------------------------------------------------------------------------06/04/2021 fin

 

-------------------------------------------------------------------------------------------------------09/04/2021 debut
D10:26 09/04/2021 - F - Chapitre 10 - p.155/259 FR 226/376 EN
D10:26 09/04/2021 - F - Chapitre 10 - p.157/259 FR 230/376 EN

"s" contient "no worries" et Playground l'affiche sans prendre en compte l'espace vide ''.
s := 'no', ' ', 'worries'.
s
>>> 'no worries'

"s" contient "no worries" et le code remplace la 4e lettre w -> h et la 5e o -> u et Playground affiche "no hurries".
s at: 4 put: $h; at: 5 put: $u.
s
>>> 'no hurries'


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

Notez que la méthode virgule est définie par Collection, elle fonctionnera donc pour tout type de collection !
Note that the comma method is defined by Collection, so it will work for any kind of collection!

Playground (CTRL+O+W)	>
			(1 to: 3), '45'		(CTRL+P) > Error:Instances of SmallInteger are not indexable
			(1 to: 3), '45'		(CTRL+P) > "#(1 2 3 $4 $5)" //Fermeture et réouverture de Playground suite au message ci-dessus


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

Notez que le nombre de caractères et l'intervalle doivent avoir la même taille.
Note that the number of characters and the interval should have the same size.


Méthodes : 
----------
s replaceAll: 		$n 	with: $N.
s replaceFrom: 		4 to: 5 with: 'wo'.

Méthode : Particularité :  
-------------------------
les arguments sont des sous-chaînes plutôt que des caractères individuels, et leurs tailles ne doivent pas nécessairement correspondre.
s copyReplaceAll: 	'rries' with: 'mbats'

Playground (CTRL+O+W)	>
		(1 to: 6) copyReplaceAll: (3 to: 5) with: { 'three' . 'etc.' }	(CTRL+P) > "#(1 2 'three' 'etc.' 6)"
		(1 to: 6) copyReplaceAll: (4 to: 5) with: { 'three' . 'etc.' }	(CTRL+P) > "#(1 2 3 'three' 'etc.' 6)"
		(1 to: 6) copyReplaceAll: (5 to: 6) with: { 'three' . 'etc.' }	(CTRL+P) > "#(1 2 3 4 'three' 'etc.')"
		(1 to: 6) copyReplaceAll: (6 to: 6) with: { 'three' . 'etc.' }	(CTRL+P) > "#(1 2 3 4 5 'three' 'etc.')"


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

Notez que match: est envoyé au modèle et non à la chaîne à rechercher. 
Note that match: is sent to the pattern and not the string to be matched.


modèle -> ? correspond ? -> chaîne
message match:

modèle * -> série arbitraire de caractères - 	'Linux *' match: 'Linux mag'		(CTRL+P) > "true"
modèle # -> correspondre à un seul caractère - 	'GNU#Linux #ag' match: 'GNU/Linux tag'	(CTRL+P) > "true"

Playground (CTRL+O+W)	>
			'Linux *' match: 'Linux mag'	(CTRL+P) > "true"
			'LInux *' match: 'Linux mag'	(CTRL+P) > "true"
			'LINUX *' match: 'Linux mag'	(CTRL+P) > "true"
			'Linux *' match: 'LInux mag'	(CTRL+P) > "true"
			'Linux *' match: 'LINUX mag'	(CTRL+P) > "true"

			'GNU#Linux #ag' match: 'GNU/Linux tag'	(CTRL+P) > "true"

Package						Sous-classe	   	Inst.Variab.N.	Clas.Variab.N.	Classe			Protocol 	Method		
-------------------------------------------------------------------------------------------------------------------------------------------------------
Regex-Core			Object		#NameOfSubclass
Regex-Core-Tests		TestCase	#RxParserTest
Regex-Help			Object		#NameOfSubclass
Collections-Abstract-Base	Collection	#SequenceableCollection	''		''		()SequenceableCollection


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

La plupart des méthodes liées aux sous-chaînes renvoient des instances String.
Most of the substring-related methods return String instances.

Mais les messages qui renvoient toujours un élément de la collection String, renvoient une instance de Character.
But the messages that always return one element of the String collection, return a Character instance.

Messages : Collection -> isEmpty ,  includes:  et  anySatisfy:  
Messages : Chaînes ------/\


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

Il y a trois messages qui sont utiles pour gérer la chaîne templating: Format:, expandMacros et expandMacrosWith:. 
There are three messages that are useful to manage string templating: format:, expandMacros and expandMacrosWith:.

Playground (CTRL+O+W)	>
		'{1} is {2}' format: {'Pharo' . 'prise de tête'}			(CTRL+P) > "'Pharo is prise de tête'"
		'{1} est {2}' format: {'Pharo' . 'prise de tête'}			(CTRL+P) > "'Pharo est prise de tête'"
		'{1} code {2} est {3}' format: {'Le' . 'Pharo' . 'prise de tête'}	(CTRL+P) > "'Le code Pharo est prise de tête'"


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

Les messages de la famille expandMacros proposent une substitution de variable, ...................................................


Classe -> String -> messages -> asLowercase, asUppercase and capitalized
'XYZ' asLowercase //en minuscules
>>> 'xyz'

'xyz' asUppercase // en majuscule
>>> 'XYZ'

'hilaire' capitalized //capitalisé
>>> 'Hilaire'

'Hilaire' uncapitalized //non capitalisé
>>> 'hilaire'

'1.54' asNumber
>>> 1.54

Remarque : 
----------
Il n'y a pas que ça, qui est trop long.
'cette phrase est sans aucun doute beaucoup trop longue' contrat à:20
'this sentence is without a doubt far too long' contractTo: 20 
>>> 'envoi...trop long'
>>> 'this sent...too long'


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

Notez qu'il existe généralement une différence entre demander à un objet sa représentation sous forme de chaîne
en envoyant le message printString et le convertir en chaîne en envoyant le message asString.

Note that there is generally a difference between asking an object its string representation 
by sending the message printString and converting it to a string by sending the message asString.

Un symbole est similaire à une chaîne mais est garanti d'être globalement unique. 
Pour cette raison, les symboles sont préférés aux chaînes comme clés pour les dictionnaires, en particulier pour les instances d'IdentityDictionary .

Voir aussi le chapitre : Classes de base pour plus d'informations sur les chaînes et les symboles.

Représentation sous forme de chaîne.
#ASymbol printString
>>> '#ASymbol'

Conversion en chaîne. message -> asString. 
#ASymbol asString
>>> 'ASymbol'

10.12 Itérateurs de collection

-----------------------------------------------------------Rappel Syntaxe dans une coquille de noix DEBUT
Rappel : 
--------
(Syntaxe dans une coquille de noix p.53 - see also Chapter : Syntax in a Nutshell p.75)
"Chapitre 4 La syntaxe en bref - Chapter 4 Syntax in a nutshell"

Anglais pidgin ?
[LINGUISTIQUE] Langue seconde crée à partir de plusieurs systèmes linguistiques, 
à la capactité d’expression limitée et utilisée simplement comme langue de relation. 
Pidgin anglais, pidgin français.


Package 		Sous-classe	Inst.Variab.N.	Clas.Variab.N.	Classe	Protocol 	Methode
-------------------------------------------------------------------------------------------------------
Kernel-Chonology-Extras	?		''		Aucune		£Week	accessing	startDay

startDay: aSymbol						//startDay: = méthode. 
(DayNames includes: aSymbol)					//Daynames = méthode. Contient-il l'argument d'un jour correcte ? (jour correct) Oui
ifTrue: [ StartDay := aSymbol ]					//StartDay = variable. Oui = Affectation (jour correct)
ifFalse: [ self error: aSymbol, ' is not a recognised day
name' ]

-----------------------------------------------------------Rappel Syntaxe dans une coquille de noix FIN


messages -> boucles -> collections
			-> objets : entiers, blocs
messages -> conditions -> collections
			-> objets : entiers, blocs

messages bas niveau -> to:do: (évalue un bloc avec un argument -> nombre initial ... nombre final)

hiérarchie de collecte -> itérateurs de haut niveau (code plus robuste et compact).

Playground (CTRL+O+W)	>
			#('bob' 'joe' 'toto') do: [:each | Transcript show: each; cr]. (CTRL+P) > "#('bob' 'joe' 'toto')"
			#('bob' 'joe' 'toto') faire: [: each | Transcription spectacle: chacun; cr].


D10:26 09/04/2021 - F13:14 - Chapitre 10 - p.157/259 FR 230/376 EN
-------------------------------------------------------------------------------------------------------09/04/2021 fin




-------------------------------------------------------------------------------------------------------10/04/2021 debut
D10:24 10/04/2021 - F - Chapitre 10 - p.157/259 FR 230/376 EN
D10:24 10/04/2021 - F13:23 - Chapitre 10 - p.158/259 FR 231/376 EN

Collections indexées :  Array, OrderedCollection, SortedCollection
Messsage : doWithIndex: -> accès à l'index en cours -> liaison -> do: -> défini -> classe -> Number

Collections ordonnées : 
Message : reverseDo: -> parcourt la collection dans l'ordre inverse

Classe Number ? Non, c'est défini dans la classe SequenceableCollection.

Package 		  		Sous-classe		Inst.Variab.N.	Clas.Variab.N.	Classe			 Protocol 	Methode
----------------------------------------------------------------------------------------------------------------------------------------------------
Kernel-Numbers		  Magnitude 	#Number			''		''		Number	
Collections-Abstract-Base Collection	#SequenceableCollection ''		''		()SequenceableCollection enumrating	doWithIndex:


Playground (CTRL+O+W)	>
#('bob' 'joe' 'toto') do: [:each | Transcript show: each; cr].					(CTRL+P) > "#('bob' 'joe' 'toto')"
#('bob' 'joe' 'toto') doWithIndex: [ :each :i | (each = 'joe') ifTrue: [ ^ i ] ]		(CTRL+P) > "2"

| res |												(CTRL+P) > "nil"
res := ''.											(CTRL+P) > "''"
#('bob' 'joe' 'toto') do: [ :e | res := res, e ] separatedBy: [ res := res, '.' ].		(CTRL+P) > "#('bob' 'joe' 'toto')"
res												(CTRL+P) > "'bob.joe.toto'"

| res |												(CTRL+P) > "nil"
res := ''.											(CTRL+P) > "''"
#('bob' 'joe' 'toto') do: [:each | Transcript show: each; cr].					(CTRL+P) > "#('bob' 'joe' 'toto')"
res												(CTRL+P) > "''"	


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

Notez que ce code n'est pas particulièrement efficace car il crée des chaînes intermédiaires et il serait préférable d'utiliser
un flux d'écriture pour mettre en mémoire tampon le résultat (voir Chapitre : Flux - Streams p.237 EN).

Playground (CTRL+O+W)	>
String streamContents: [ :stream | #('bob' 'joe' 'toto') asStringOn: stream delimiter: '.' ]	(CTRL+P) > "'bob.joe.toto'"
[#('bob' 'joe' 'toto') stream delimiter: '.'].							(CTRL+P) > "[ #('bob' 'joe' 'toto') stream delimiter: '.' ]"
[ :stream | #('bob' 'joe' 'toto')  delimiter: '.' ].						(CTRL+P) > "[ :stream | #('bob' 'joe' 'toto') delimiter: '.' ]"
[ stream | #('bob' 'joe' 'toto')  delimiter: '.' ].						(CTRL+P) > "[ stream | #('bob' 'joe' 'toto') delimiter: '.' ]"


12:02 10/04/2021
Dictionnaires


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

Message -> do: -> valeurs -> Dictionary 

Les messages appropriés à utiliser sont keysDo:, valuesDo:, et associationsDo:, qui itérer respectivement sur clés (touches), valeurs ou associations. 
The proper messages to use are keysDo:, valuesDo:, and associationsDo:, which iterate respectively on keys, values or associations.

Playground (CTRL+O+W)	>
colors := Dictionary newFrom: { #yellow -> Color yellow. #blue -> Color blue. #red -> Color red }. 	(CTRL+P) > "a Dictionary(#blue->Color blue #red->Color red #yellow->Color yellow )"
colors keysDo: 		[:key | Transcript show: key; cr ]. 						(CTRL+P) > "a Dictionary(#blue->Color blue #red->Color red #yellow->Color yellow )"
colors valuesDo: 	[:value | Transcript show: value; cr ].						(CTRL+P) > "a Dictionary(#blue->Color blue #red->Color red #yellow->Color yellow )"
colors associationsDo: 	[:value | Transcript show: value; cr].						(CTRL+P) > "a Dictionary(#blue->Color blue #red->Color red #yellow->Color yellow )"

12:36 10/04/2021
Collecting results (collect:)

Si vous souhaitez appliquer une fonction aux éléments d'une collection et obtenir une nouvelle collection avec les résultats, 
plutôt que d'utiliser do:, vous êtes probablement mieux en utilisant collect:, ou l'une des autres méthodes d'itération. 

If you want to apply a function to the elements of a collection and get a new collection with the results, 
rather than using do:, you are probably better off using collect:, or one of the other iterator methods.

Heu ! Non, je ne le souhaite pas. :-)


La plupart d'entre elles peuvent être trouvées dans le protocole d'énumération de Collection et ses sous-classes.
Most of these can be found in the enumerating protocol of Collection and its subclasses.

Remarque : 
----------
Il n'y a pas quelque chose de plus intuitif, plus simple que d'aller chercher toutes ces choses ou retenir plusieurs catégories ?

DO: : méthode
-----

Playground (CTRL+O+W)	>
| double | 							(CTRL+P) > "nil"
double := OrderedCollection new.				(CTRL+P) > "an OrderedCollection()"
#(1 2 3 4 5 6) do: [ :e | double add: 2 * e ]. 			(CTRL+P) > "#(1 2 3 4 5 6)"
double								(CTRL+P) > "an OrderedCollection(2 4 6 8 10 12)"

#(1 2 3 4 5 6) do: [ :e | 2 * e ] 				(CTRL+P) > "#(1 2 3 4 5 6)"
#(1 2 3 4 5 6) do: [ :e | double add: 2 * e ]			(CTRL+P) > "#(1 2 3 4 5 6)"

COLLECT: : méthode
----------

Playground (CTRL+O+W)	>
#(1 2 3 4 5 6) collect: [ :e | 2 * e ] 				(CTRL+P) > "#(2 4 6 8 10 12)"

Remarque : 
----------
collect: est disséminé un peu partout (Implementors of collect: (28)), c'est difficile de savoir ce qu'il lit comme code.

Package 		  				Sous-classe	Inst.Variab.N.	Clas.Variab.N.	Classe		Protocol 	Methode
----------------------------------------------------------------------------------------------------------------------------------------------------
Collections-Abstract-Base 	   Object		#Collection	''		''		()Collection	enumerating	collect:
Collections-Unordered-Dictionaries HashedCollection	#Dictinary	''		''		()Dictinary	enumerating	collect:

Avantage de collect: -> collection d'entiers -> génère -> collection de valeurs absolues

Un autre avantage de la deuxième solution est qu'elle fonctionnera également pour les ensembles et les sacs.
A further advantage of the second solution is that it will also work for sets and bags. 


DO: : méthode
-----

Playground (CTRL+O+W)	>
aCol := #( 2 -3 4 -35 4 -11).							(CTRL+P) > "#(2 -3 4 -35 4 -11)"
result := aCol species new: aCol size.						(CTRL+P) > "#(nil nil nil nil nil nil)"
1 to: aCol size do: [ :each | result at: each put: (aCol at: each) abs ]. 	(CTRL+P) > "1"
result 										(CTRL+P) > "#(2 3 4 35 4 11)"



COLLECT: : méthode
----------

Playground (CTRL+O+W)	>
#( 2 -3 4 -35 4 -11) collect: [ :each | each abs ]				(CTRL+P) > "#(2 3 4 35 4 11)"
#(1 2 3 4 5 6) collect: [ :each | each abs ]					(CTRL+P) > "#(1 2 3 4 5 6)"


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

En règle générale, vous devez éviter d'utiliser do :, sauf si vous souhaitez envoyer des messages à chacun des éléments d'une collection.
Generally you should avoid using do:, unless you want to send messages to each of the elements of a collection.

Notez que l'envoi du message collecte: renvoie le même type de collecte que le destinataire. 
Pour cette raison, le code suivant échoue. (Une chaîne ne peut pas contenir de valeurs entières.)

Note that sending the message collect: returns the same kind of collection as the receiver. 
For this reason the following code fails. (A String cannot hold integer values.)

D10:24 10/04/2021 - F13:23 - Chapitre 10 - p.158/259 FR 231/376 EN
-------------------------------------------------------------------------------------------------------10/04/2021 fin



-------------------------------------------------------------------------------------------------------11/04/2021 debut
D12:23 11/04/2021 - F - Chapitre 10 - p.158/259 FR 231/376 EN
D12:23 11/04/2021 - F13:40 - Chapitre 10 - p.160/259 FR 233/376 EN

Playground (CTRL+O+W)	>
		'' asArray collect: [ :ea | ea asciiValue ] 		(CTRL+P) > "#(9562 9556 9577 9574)"
		'123' asArray collect: [ :ea | ea asciiValue ]		(CTRL+P) > "#(49 50 51)"
		(1 to: 5) collect: [ :ea | ea * 2 ]			(CTRL+P) > "#(2 4 6 8 10)"			
		(2 to: 20) select: [ :each | each isPrime ]		(CTRL+P) > "#(2 3 5 7 11 13 17 19)"
		(2 to: 20) reject: [ :each | each isPrime ]		(CTRL+P) > "#(4 6 8 9 10 12 14 15 16 18 20)"

*"Le message detect: renvoie le premier élément du récepteur qui correspond à l'argument de bloc."		
		'through' detect: [ :each | each isVowel ]		(CTRL+P) > "$o"
		'threugh' detect: [ :each | each isVowel ]		(CTRL+P) > "$e"
		'thraugh' detect: [ :each | each isVowel ]		(CTRL+P) > "$a"
		'thrdugh' detect: [ :each | each isVowel ]		(CTRL+P) > "$u"	//argument de bloc "u" ?
		'thrdugih' detect: [ :each | each isVowel ]		(CTRL+P) > "$u"
		'thrdiguh' detect: [ :each | each isVowel ]		(CTRL+P) > "$i"
		'thruidgh' detect: [ :each | each isVowel ]		(CTRL+P) > "$u"
		'thriudgh' detect: [ :each | each isVowel ]		(CTRL+P) > "$i"
		'thurigh' detect: [ :each | each isVowel ]		(CTRL+P) > "$u"
		'thourigh' detect: [ :each | each isVowel ]		(CTRL+P) > "$o"

Smalltalk globals allClasses detect: [:each | '*cobol*' match: each asString] ifNone: [ nil ]	(CTRL+P) > "nil"
		(1 to: 100) inject: 0 into: [ :sum :each | sum + each ]				(CTRL+P) > "5050"

factorial := [ :n | (1 to: n) inject: 1 into: [ :product :each | product * each ] ]. 		(CTRL+P) > "[ :n | (1 to: n) inject: 1 into: [ :product :each | product * each ] ]"
factorial value: 10										(CTRL+P) > "3628800"

#(1 2 3) inject: 0 into: [ :sum :each | sum + each ]						(CTRL+P) > "6"

-----------------------------------------------------------------------
Package 			Subclass	Protocol	Methode
-----------------------------------------------------------------------
Collection-Abstract-Base Object #Collection	enumerating	collect:, select:, reject:, detect:, inject:into:


#(1 2 3 4 5 6) 			collect: 	[ :e | 2 * e ]
#( 2 -3 4 -35 4 -11) 		collect: 	[ :each | each abs ]
'abc' 			asArray collect: 	[ :ea | ea asciiValue ]
(1 to: 5) 			collect: 	[ :ea | ea * 2 ]
(2 to: 20) 			select: 	[ :each | each isPrime ]
(2 to: 20) 			reject: 	[ :each | each isPrime ]
'through' 			detect: 	[ :each | each isVowel ]
(1 to: 100) 			inject: 0 into: [ :sum :each | sum + each ]
#(1 2 3) 			inject: 0 into: [ :sum :each | sum + each ]

D12:23 11/04/2021 - F13:40 - Chapitre 10 - p.160/259 FR 233/376 EN
-------------------------------------------------------------------------------------------------------11/04/2021 fin



-------------------------------------------------------------------------------------------------------12/04/2021 debut
D08:59 12/04/2021 - F - Chapitre 10 - p.160/259 FR 233/376 EN
D08:59 12/04/2021 - F12:34 - Chapitre 10 - p.162/259 FR 237/376 EN

- 15 mns pause.

* nombreux autres messages d'itérateur dans la classe Collection.

Playground (CTRL+O+W)	>
Smalltalk globals allClasses count: [ :each | 'Collection' match: each asString ]		(CTRL+P) > "1"
Smalltalk globals allClasses count: [ :each | 'Collection*' match: each asString ]		(CTRL+P) > "10"
Smalltalk globals allClasses count: [ :each | 'SequenceableCollection*' match: each asString ]	(CTRL+P) > "1"
Smalltalk globals allClasses count: [ :each | 'HashedCollection*' match: each asString ]	(CTRL+P) > "1"
Smalltalk globals allClasses count: [ :each | 'ArrayedCollection*' match: each asString ]	(CTRL+P) > "1"

Remarque : 
----------
Ça passe d'une ligne de code sans variables à une autre plus longue.

Playground (CTRL+O+W)	>
| colors |									(CTRL+P) > "nil"
colors := {Color white . Color yellow . Color blue . Color orange}.		(CTRL+P) > "{Color white. Color yellow. Color blue. Color orange}"
colors includes: Color blue. 							(CTRL+P) > "true"

colors := {Color white . Color yellow . Color blue . Color orange} includes: Color blue.	(CTRL+P) > "true"

ANSATISFY :
-----------

colors anySatisfy: [ :c | c red > 0.5 ]								(CTRL+P) > "true"

Package 				Subclass	Class		Protocol	Methode
----------------------------------------------------------------------------------------------------
Collections-Abstract-Base Object	#Collection	()Collection	enumerating	anySatisfy:

anySatisfy: aBlock
	"Evaluate aBlock with the elements of the receiver.
	If aBlock returns true for any element return true.
	Otherwise return false."
	"#(1 3) anySatisfy: [ :each | each even ] >>> false"
	"#(1 2) anySatisfy: [ :each | each even ] >>> true"

	self do: [:each | (aBlock value: each) ifTrue: [^ true]].
	^ false

ADD
----

add: newObject 
	"Include newObject as one of the receiver's elements. Answer newObject. 
	ArrayedCollections cannot respond to this message."

	self subclassResponsibility

Une erreur courante avec add: l'erreur suivante est l'une des erreurs Smalltalk les plus fréquentes.
A common mistake with add: The following error is one of the most frequent Smalltalk mistakes.


Ici, la collection de variables ne contient pas la collection nouvellement créée mais plutôt le dernier numéro ajouté.
En effet, la méthode add: renvoie l'élément ajouté et non le récepteur.

| collection |
collection := OrderedCollection new add: 1; add: 2.
collection

Playground (CTRL+O+W)	>
| collection |							(CTRL+P) > "nil"
collection := OrderedCollection new add: 1; add: 2.		(CTRL+P) > "2"
collection 							(CTRL+P) > "2"

Le code suivant donne le résultat attendu :

| collection |
collection := OrderedCollection new.
collection add: 1; add: 2.
collection

Playground (CTRL+O+W)	>
| collection |							(CTRL+P) > "nil"
collection := OrderedCollection new.				(CTRL+P) > "an OrderedCollection()"
collection add: 1; add: 2.					(CTRL+P) > "2"
collection 							(CTRL+P) > "an OrderedCollection(1 2)"


collection := OrderedCollection new add: #(1 2).		(CTRL+P) > "#(1 2)"
collection := OrderedCollection new add: #[1 2].		(CTRL+P) > "#[1 2]"
collection := OrderedCollection new add: 1 & 2.			(CTRL+P) > "0"


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

Remarque :  
----------
* You can also use the message yourself to return the receiver of a cascade of messages:

Évidemment, c'est aussi simple que la syntaxe contenue sur une carte postale.

C'est bien beau "yourself", mais dans toute la panoplie alphabétique suggérée par Playground comment sais-tu qu'il faut mettre "yourself" ?
Je peux très bien mettre (acceptBasic, backtrack, category, cause, cc) ou alors passer en revue tous les mots jetés sur le menu !

Finder > newObject (Source) > add: -> OrderedCollection -> 
							add: newObject
							^self addLast: newObject

| collection |
collection := OrderedCollection new add: 1; add: 2; yourself

-----------------------------------------------------------------Exemples - Modifications DEBUT

| colors |									
colors := {Color white . Color yellow . Color blue . Color orange}.		
colors includes: Color blue. 

colors := {Color white . Color yellow . Color blue . Color orange} includes: Color blue.	(CTRL+P) > "true"

colors anySatisfy: [ :c | c red > 0.5 ]	

collection := {OrderedCollection new add: 1} add: 2.
collection := {add: 1 . add: 2} OrderedCollection new.

| double | 							(CTRL+P) > "nil"
double := OrderedCollection new.				(CTRL+P) > "an OrderedCollection()"
#(1 2 3 4 5 6) do: [ :e | double add: 2 * e ]. 			(CTRL+P) > "#(1 2 3 4 5 6)"
double								(CTRL+P) > "an OrderedCollection(2 4 6 8 10 12)"


| res |												(CTRL+P) > "nil"
res := ''.											(CTRL+P) > "''"
#('bob' 'joe' 'toto') do: [ :e | res := res, e ] separatedBy: [ res := res, '.' ].		(CTRL+P) > "#('bob' 'joe' 'toto')"
res												(CTRL+P) > "'bob.joe.toto'"

String streamContents: [ :stream | #('bob' 'joe' 'toto') asStringOn: stream delimiter: '.' ]

------------------------------------------------------------------Exemples - Modifications FIN


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

* Encore autre chose à retenir et une erreur à ne pas faire.

Suppression d'un élément de la collection sur laquelle vous êtes en train d'itérer.
Une autre erreur que vous pouvez faire est de supprimer un élément d'une collection sur laquelle vous êtes en train d'itérer. 
Removing an element of the collection you are iterating 
on Another mistake you may make is to remove an element from a collection you are currently iterating over.

p. 160 FR - 234 EN 
(?) - Les codes ci-dessous renvoient la même chose, donc je ne sais pas, c'est l'incertitude, la surprise, l'incompréhension.

Playground (CTRL+O+W)	>
| range |									(CTRL+P) > "nil"
range := (2 to: 20) asOrderedCollection. 					(CTRL+P) > "an OrderedCollection(2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)"
range do: [ :aNumber | aNumber isPrime ifFalse: [ range remove: aNumber ] ].	(CTRL+P) > "an OrderedCollection(2 3 5 7 11 13 17 19)"
range 										(CTRL+P) > "an OrderedCollection(2 3 5 7 11 13 17 19)"

| range |									(CTRL+P) > "nil"
range := (2 to: 20) asOrderedCollection. 					(CTRL+P) > "an OrderedCollection(2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)"
range copy do: [ :aNumber | aNumber isPrime ifFalse: [ range remove: aNumber ] ].(CTRL+P) > "an OrderedCollection(2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)"
range 										(CTRL+P) > "an OrderedCollection(2 3 5 7 11 13 17 19)"

11:54 12/04/2021
Redéfinir = mais pas de hachage - Redefining = but not hash - Listing 10-20 Redefi ning = and hash.


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

Bis - * Encore autre chose à retenir et une erreur à ne pas faire. 
Le bottin ne suffit plus. :-(

* Une erreur difficile à repérer est lorsque vous redéfinissez = mais pas de hachage.

Bis bis - * Encore autre chose à retenir et une erreur à ne pas faire. 
Le super bottin ne suffit plus. :-(

* Un autre problème désagréable se pose si vous utilisez un objet modifiable, 
c'est-à-dire un objet qui peut changer sa valeur de hachage au fil du temps, 
comme élément d'un ensemble ou comme clé d'un dictionnaire. 
Ne faites pas cela à moins que vous n'aimiez le débogage !

"à moins que vous n'aimiez le débogage" 
- Pourtant, il y a un super outil de débogage alors pour quoi s'en priver et ne pas continuer à perdre du temps ?

"Le débogueur est sans doute l'outil le plus puissant de la suite d'outils Pharo. 
Il est utilisé non seulement pour le débogage, mais également pour l'écriture de nouveau code."

Je l'adore celle-là :
"L'une des caractéristiques uniques de Pharo (et de ses ancêtres) est que pendant que vous programmez, 
vous vivez dans un monde d'objets vivants, pas dans un monde de texte de programme statique."

Remarque : 
----------
C'est impossible de ne pas se prendre la tête avec ce codage, il n'en va pas autrement.
C'est une perte de temps incommensurable.


Book >> = aBook
self class = aBook class ifFalse: [ ^ false ].			(CTRL+P) > nil
^ title = aBook title and: [ authors = aBook authors ]

Book >> hash
^ title hash bitXor: authors hash				(CTRL+P) > 0


12:29 12/04/2021
10.14 Résumé du chapitre

Remarque : 
----------
Depuis le temps que j'y suis, je ne sais même plus le contenu ou ce que j'ai pu faire.

12:33 12/04/2021
Chapitre 11 - Streams - Ruisseaux

D08:59 12/04/2021 - F12:34 - Chapitre 10 - p.162/259 FR 237/376 EN
-------------------------------------------------------------------------------------------------------12/04/2021 fin



-------------------------------------------------------------------------------------------------------/04/2021 debut
D10:26 13/04/2021 - F - Chapitre 11 - p.162/259 FR 237/376 EN
D10:26 13/04/2021 - F13:01 - Chapitre 11 - p.163/259 FR 239/376 EN

- 5 mns



 /---------------------------Lisible, Incriptible-------------------\
	Streams - flux -> parcourir -> collections séquencées
	Streams - flux -> parcourir -> fichiers
	Streams - flux -> parcourir -> flux réseau
				/\
		    |Steams - flux conversion|			
				\/
 \-------------------------collections-------------------------------/


Métaphore :
----------
				     Classes
					\/
			         Stream - Flux 
					\/
				Sous-classes	
				   	\/
				PositionableStream
					|
			    positionnement au milieu
				   	|
	     Séquence d'éléments passés - Séquence d'éléments futurs

Lire un élément :
-----------------
		  Passé	- Futur

		    SDP	- SDF
	    a b c d e f	- g h i j k l

Lecture - next
		SDP 	- SDF
	    a b c d e f	- (supprime g) h i j k l

Placement - écrire - nextPut: anElement
		    SDP	- SDF
  a b c d e f (place g)	- h i j k l

11.2 Flux vs collections

Remarque : 
----------
Cela m'aurait étonné que ça ne soit pas plus facile, encore une chose à retenir.


Collecte : 
----------
		protocole de collecte
			/\
	     	     stockage
			/\
		pas de mélange
    /\------------- collection ------------/\
Suppression				Enumération


Opérations non mélangés : 
------------------------

                 protocole de collecte
			/\
	     	     stockage
		     fichiers
		      sockets
			/\
		pas de mélange
    /\------------- collection ------------/\
Suppression				Enumération	< ReadStream, WriteStream, ReadWriteStream <------|diffusion une collection\
Lecture										< ----- ReadStream <-----------------<-- |
					Ecriture				< ----- WriteStream <----------------<-- |
Lecture					Ecriture				< ----- ReadWriteStream <------------<-- |
			/\												/|\
			>-------------------------------->--------------------> conservation -> traversée index ou référence de position
impossible -> itérer	/\	deux collections <- impossible
			/\
		  protocole collecte
			/\
impossible -> ajout	[do: ]	 suppression <- impossible
			/\
		OrderedCollection

Playground (CTRL+O+W)	>
| r | 						(CTRL+P) > "nil"
r := ReadStream on: (1 to: 1000). 		(CTRL+P) > "a ReadStream"
r next. 					(CTRL+P) > "1"
r next. 					(CTRL+P) > "2"
r next. 					(CTRL+P) > "3"

| r |
r := ReadStream on: (1 to:10).
r next.1 

Après avoir mis "1", le prochain chiffre est "3", le "2" passe où ?(1 précédent + .1 = 2 alors affiche 3)
| r |
r := ReadStream on: (1 to:10).
r next. "3"

Note : 
------
Pour remettre le compteur à zéro, faire (CTRL+P) > sur la seconde ligne "r := ReadStream on: (1 to:10)."

Remarque : 
----------
Il te rajoute "atEnd" sans t'expliquer la finalité de cette commande.
 
Décompte non fini avant 10 : atEnd
----------------------------
| r |
r := ReadStream on: (1 to:10).
r next. "9"
r atEnd. "false"

Décompte fini pendant 10 et après 10 : atEnd
-------------------------------------
| r |
r := ReadStream on: (1 to:10).
r next. "10"
r atEnd. "true"

| r |
r := ReadStream on: (1 to:10).
r next. "nil"
r atEnd. "true"

Next : ne perds pas la boule
---------------------------
"Par exemple, l'extrait de code suivant crée un flux sur un intervalle, puis lit deux éléments."

Remarque : 
----------
Il ne lit pas deux éléments, puisqu'il faut cliquer à droite de chaque ligne "next" pour afficher un élément.
Donc, il lit un élément sur la 1re ligne puis un 2e lorsque je lance (CTRL+P).
Enfin, en cliquant de nouveau sur la 1re ligne, s'affiche le 3e élément.
Dire qu'il lit deux éléments est faux puisqu'il les lit un par un jusqu'à 1000.
1 flux sur un intervalle = 1 élément

Lorsqu'un élément de 1 à 10 est lu, alors, il passe dans le passé et n'importe quel "next" affichera l'élément suivant.

| r |
r := ReadStream on: (1 to:10).
r next. "1"
r next. "2"
r atEnd.


Question : 
----------
Si "a" et "b" représente deux chaînes, quels sont les trois autres ? (String new: 5)
De plus, pourquoi en changeant "String new: 5" à "String new: 0", le résultat ne change pas ?

| w |
w := WriteStream on: (String new: 5).
w nextPut: $a.
w nextPut: $b.
w contents.

| w |					(CTRL+P) > "nil"
w := WriteStream on: (String new: 5).	(CTRL+P) > "a WriteStream"
w nextPut: $a.				(CTRL+P) > "$a"
w nextPut: $b. 				(CTRL+P) > "$b"
w contents. 				(CTRL+P) > "'ab'"

| w |					(CTRL+P) > "nil"
w := WriteStream on: (String new: 1).	(CTRL+P) > "a WriteStream"
w nextPut: $a.				(CTRL+P) > "$a"
w nextPut: $b. 				(CTRL+P) > "$b"
w contents. 				(CTRL+P) > "'ab'"

| w |					(CTRL+P) > "nil"
w := WriteStream on: (String new: 0).	(CTRL+P) > "a WriteStream"
w nextPut: $a.				(CTRL+P) > "$a"
w nextPut: $b. 				(CTRL+P) > "$b"
w contents. 				(CTRL+P) > "'ab'"

Modification () en []
----------------------
| w |					(CTRL+P) > "nil"
w := WriteStream on: [String new: 5].	(CTRL+P) > "a WriteStream"
w nextPut: $a.				(CTRL+P) > Instance of BlockClosure did not understand #grownBy:
w nextPut: $b.				(CTRL+P) > Instance of BlockClosure did not understand #grownBy:
w contents.				(CTRL+P) > Instance of BlockClosure did not understand #copyFrom:to:

Modification () en {}
----------------------
| w |					(CTRL+P) > "nil"
w := WriteStream on: (String new: 0).	(CTRL+P) > "a WriteStream"
w nextPut: $a.				(CTRL+P) > "$a"
w nextPut: $b. 				(CTRL+P) > "$b"
w contents.				(CTRL+P) > "#($a $b)"

Modification () en '' : Le résultat est le même qu'au départ.
---------------------
| w |					(CTRL+P) > "nil"
w := WriteStream on: (String new: 5).	(CTRL+P) > "a WriteStream"
w nextPut: $a.				(CTRL+P) > "$a"
w nextPut: $b. 				(CTRL+P) > "$b"
w contents. 				(CTRL+P) > "'ab'"


Exemple : test.txt
---------

Questions : 
----------
Pourquoi la classe "(c)StandardFileStream" est-elle barrée dans Playground, SystemBrowser ?
Où est créé le fichier "text.txt" ? Dans le répertoire de l'application Pharo.

* Le code ci-dessou ne fonctionne pas 

StandardFileStream
fileNamed: 'test.txt'
do: [:str | str
nextPutAll: '123';
cr;
nextPutAll: 'abcd' ].


Notes : 
------
Le fichier texte est créé dans le répertoire de Pharo.
Le code ci-dessous fonctionne après avoir enlevé les espaces.

Questions : 
-----------
1. Pourquoi s'affiche seulement "abcd" dans Playground ?
2. Dans le fichier texte aucun retour chariot ? (Code ASCII, retour chariot)

StandardFileStream fileNamed: 'test.txt' do: [:str | str nextPutAll: '123'; cr; nextPutAll: 'abcd' ].	(CTRL+P) > "'abcd'"
StandardFileStream fileNamed: 'test_1.txt' do: [:str | str nextPutAll: '123abcd' ].			(CTRL+P) > "'123abcd'"


Valeurs des codes ASCII
------------------------

exemple : 123
---------

'123' asArray collect: [ :ea | ea asciiValue ]		(CTRL+P) > "#(49 50 51)"
'cr' asArray collect: [ :ea | ea asciiValue ]		(CTRL+P) > "#(99 114)"

Playground (CTRL+O+W) -> StandardFileStream -> 
				CTRL+M(+B) -> DeprecatedFileStream-Base 
						- FileStream 
						- #StandardFileStream - 'name fileID buffer1 rwmode', 'Registry' 
						- (c)StandardFileStream
				
				CTRL+N -> Senders of StandardFileStream(2)
						|----> 	FileExistsException - fileClass - DeprecatedFileStream
						|---->	StandardFileStream - openforWrite - DeprecatedFileStream

D10:26 13/04/2021 - F13:01 - Chapitre 11 - p.163/259 FR 239/376 EN
-------------------------------------------------------------------------------------------------------/04/2021 fin



-------------------------------------------------------------------------------------------------------14/04/2021 debut
D11:44 14/04/2021 - F - Chapitre 11 - p.163/259 FR 239/376 EN
D11:44 14/04/2021 - F13:42 - Chapitre 11 - p.165/259 FR 241/376 EN

Playground (CTRL+O+W) -> StandardFileStream -> 
				CTRL+M(+B) -> DeprecatedFileStream-Base 
						- FileStream 
				       subclass - #StandardFileStream 
			  instanceVariableNames - 'name fileID buffer1 rwmode'
			     classVariableNames - 'Registry' 
				         classe	- (c)StandardFileStream
protocol : PositionableStream, WriteStream, StandardFileStream (Vars) - protocol : buffer1, fileID, name, rwmode (Vars)
		\|/		        		\|/				     \|/	    \|/
		 |------->------------------->-----------|------------<-------------<---------|--------<-----|
							\|/
		protocol - accessing -> methode - nextPutAll:

				       protocol - registry (Class side)
					methode - registry (Class side) 
							registry
							   ^Registry ifNil: [Registry := WeakRegistry new]
ProtoObject
   Object
      Stream
        PositionableStream
             WriteStream
                 ReadWriteStream
      		     FileStream
(c)			StandardFileStream
(m)  (Class side)	fileNamed: 'test.txt'
			do: [:str | str
(m) (Methods)		nextPutAll: '123';
			cr;
(m) (Methods)		nextPutAll: 'abcd' ].

Questions : 
----------
Pourquoi répéter "nexPutAll:" et "str" ? "fileNamed" n'y est qu'une fois.
Pourquoi "ReadStream" est-il absent de la liste des classes contrairement à "WriteStream" ? ('DeprecatedFileStream-Base')

StandardFileStream fileNamed: 'test.txt' do: [:str | str nextPutAll: '123'; cr; nextPutAll: 'abcd' ].
StandardFileStream fileNamed: 'test.txt' do: [:str | str nextPutAll: '123'; cr; 'abcd' ].

range copy do: [ :aNumber | aNumber isPrime ifFalse: [ range remove: aNumber ] ].


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

11.3 Streaming over collections - Reading collections
La classe ReadStream doit être utilisée pour lire les éléments des collections.
The class ReadStream should be used to read elements from collections.

package: 'Collections-Streams-Base' -> ReadStream

Les messages next et next: définis dans ReadStream sont utilisés pour récupérer un ou plusieurs éléments de la collection.
Messages next and next: defined in ReadStream are used to retrieve one or more elements from the collection.

Playground (CTRL+O+W) ->
(c)			| stream |
(c) + (c)		stream := ReadStream on: #(1 (a b c) false).
(c) + (m)		stream next.

Question : 
----------
Il met un "#" devant les lettres, mais pas le chiffre ?

Playground (CTRL+O+W) ->
| stream |						(CTRL+P) > "nil"
stream := ReadStream on: #(zw (1 (a b c) false)).	(CTRL+P) > "a ReadStream"
stream next.						(CTRL+P) > "#zw"

| stream |						(CTRL+P) > "nil"
stream := ReadStream on: #(12 (a (4 5 6) false)).	(CTRL+P) > "a ReadStream"
stream next. 						(CTRL+P) > "12"

| stream |						(CTRL+P) > "nil"
stream := ReadStream on: #(1 2 (a (4 5 6) false)).	(CTRL+P) > "a ReadStream"
stream next. 						(CTRL+P) > "1"

| stream |						(CTRL+P) > "nil"
stream := ReadStream on: #(ab (4 5 6) false).		(CTRL+P) > "a ReadStream"
stream next. 						(CTRL+P) > "#ab"

| stream |						(CTRL+P) > "nil"
stream := ReadStream on: #(45 (a b c) false).		(CTRL+P) > "a ReadStream"
stream next. 						(CTRL+P) > "45"

Note : 
------
En fait, tu n'as pas besoin de remettre "stream next." puisqu'en relançant (CTRL+P), il lit les prochains éléments.

| stream |
stream := ReadStream on: #(45 (a b c) false).	
stream next. 						(CTRL+P) > "45"			//Sans passer par la 1re et 2e ligne.
stream next. 						(CTRL+P) > "#(#a #b #c)" 

1. | stream |
2. stream := ReadStream on: #(45 (1 -5 56) false).
3. stream next. 					(CTRL+P) > "45"			//1re réponse de la 3e ligne.
3. stream next. 					(CTRL+P) > "#(1 -5 56)"		//2e réponse de la 3e ligne.
3. stream next. 					(CTRL+P) > "false"		//3e réponse de la 3e ligne.


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

Paragraphe où il faut encore retenir beaucoup de choses.

(stream peek = $-).
upToEnd
peekFor:
stream peek
reset  
setToEnd
skip: 
skipTo: 

D11:44 14/04/2021 - F13:42 - Chapitre 11 - p.165/259 FR 241/376 EN
-------------------------------------------------------------------------------------------------------14/04/2021 fin



-------------------------------------------------------------------------------------------------------15/04/2021 debut
D11:47 15/04/2021 - F - Chapitre 11 - p.165/259 FR 241/376 EN
D11:47 15/04/2021 - F13:53 - Chapitre 11 - p.165/259 FR 241/376 EN

- 5 mns

Remarque : 
----------
Il y a beaucoup de choses à retenir et ce n'est pas de cette manière que je me souviendrais de toutes ces notions "à retenir" en plus de tous les autres concepts.


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

"N'oubliez pas qu'un flux n'est pas positionné sur un élément, mais entre deux éléments."
" L'index correspondant au début du flux est 0."


(c)ReadStream : lit les éléments d'une collection
 	\|/
  	 -----> next / next : récupère un ou plusierus éléments de la collection
	 -----> upToEnd : renvoie tout, de la position actuelle à la fin du flux et définit le flux jusqu'à sa fin. (Simplification : peekFor:)
	 -----> message -> collection séquençable (comme une chaîne) pour obtenir un flux de lecture sur cette collection particulière


(c)PositionnableStream :
 	\|/
  	 -----> peek (aperçu) : quel est l'élément suivant sans aller de l'avant (regarder le 1re élément sans le consommer)
	 -----> peekFor: : avance si l'élément suivant est égal au paramètre et ne bouge pas autrement
		 |--->	"renvoie également un booléen indiquant si le paramètre est égal à l'élément."
	 -----> position: : message pour positionner le pointeur du flux


negative : variable booléenne selon le signe du nombre
number : à sa valeur absolue
 
reset / setToEnd : positionner au début ou à la fin du flux
 |---> stream reset.

skip: : utilisés pour aller vers un emplacement par rapport à la position actuelle
 |---> accepte un nombre comme argument et ignore ce nombre d'éléments
 |---> stream skip: 3. "stream is now after the d"
 |---> stream skip: -2. "stream is after the b"

skipTo: : utilisés pour aller vers un emplacement par rapport à la position actuelle
 |---> ignore tous les éléments du flux jusqu'à ce qu'il trouve un élément égal à son paramètre.
 |---> À retenir : positionne le flux après l'élément correspondant.

Notes : 
------
Ça se mélange tous ça.

Tu as la classe "Stream" du package "Collections-Streams-Base", mais le "stream" ci-dessous n'a rien à voir avec cela.
Tandis que la classe "ReadStream" du package "Collections-Streams-Base" contient la méthode "readStream" et "stream" renvoie "a ReadStream".
Donc, le "stream" je ne sais pas d'où il sort, comment démêler ce micmac ?


Question : 
----------
À quoi est rattaché "stream" ? Parce qu'il joue à la fois le rôle de variable et de classe ? (Implementors of stream (19))

| stream |
stream := 'abcde' readStream.	//position de départ = 0a 1b 2c 3d 4e
stream position: 2.		//seconde position - alors que "0" contient la première valeur de l'alphabet, donc "c" devrait être en 3es positions.
				// O = la tête à toto.
stream peek "$c"		//réponse


Analyse : 
---------

| stream |				(c)stream			//Quel package ? C'est à la fois une variable et une classe ?
Playground (CTRL+O+W) -> stream	(CTRL+P) >  "a ReadStream" 		//stream n'apparait pas dans la classe ReadStream ?
Playground (CTRL+O+W) -> stream	(CTRL+M) > Implementors of stream (19)	//"stream" où va-t-il ? Qu'est-ce qu'il fait ? Il interroge quoi ?


stream := 'abcde' readStream.		(c)stream := (m)readStream
Playground (CTRL+O+W) -> readstream (CTRL+M) > Implementors of stream (16) //"readStream" est implémenté dans 15 autres packages et l'on est en droit de se poser la question à savoir, il interroge seulement la classe ReadStream ?


stream position: 2.			(c)stream (m)position: -> méthode rattaché à (c)PositionnableStream
stream peek				(c)stream (m)peek -> méthode rattaché à (c)PositionnableStream


 			Variable -> | stream | (package ?, classe ?,  code inconnu ?)
					|
	"a ReadStream" <---	stream <-< (m)readStream <- ((c)   ReadStream)
					|
	"a ReadStream" <---	stream <-< (m)position:  <- ((c)  PositionnableStream)
					|
	 	  "$c" <---	stream <-< (m)peek 	 <- ((c)  PositionnableStream)	


D11:47 15/04/2021 - F13:53 - Chapitre 11 - p.165/259 FR 241/376 EN
-------------------------------------------------------------------------------------------------------15/04/2021 fin



-------------------------------------------------------------------------------------------------------16/04/2021 debut
D11:22 16/04/2021 - F - Chapitre 11 - p.165/259 FR 241/376 EN
D11:22 16/04/2021 - F13:58 - Chapitre 11 - p.165/259 FR 242/376 EN

- 16 mns
- 6 mns

----------------------------------------------------------------------------------------------- stream DEBUT
Playground (CTRL+O+W) -> stream	(Do it and go - CTRL+G) 
Playground (CTRL+O+W) -> stream := 'abcde' readStream.	(Do it and go - CTRL+G) 
								
			> a ReadStream
			Raw						Meta
------------------------------------------------------------------------------------------
			> Variable			Value 		Class Hierarchy
------------------------------------------------------------------------------------------
			(c) self			a ReadStream	
			| collection			'abcde'		
			E position - positioning	0		PositionableStream
			E readLimit			5		


* Elle est à l'envers par rapport à la fenêtre de la classe du SystemBrowser ?
 									Meta
------------------------------------------------------------------------------------------
			Methods						Class Hierarchy
------------------------------------------------------------------------------------------
			readStream - accessing				ReadStream
			position: - positioning				PositionableStream
			peek - accesing
									Stream
									Object
									ProtoObject
----------------------------------------------------------------------------------------------- stream FIN


----------------------------------------------------------------------------------------------- stream peek DEBUT
Playground (CTRL+O+W) -> stream	peek (Do it and go - CTRL+G) 
								
			> a Character ($a)
			> Raw						> Meta
------------------------------------------------------------------------------------------
			> Variable			Value 		Class Hierarchy
------------------------------------------------------------------------------------------
			E self				$a	


* Deux "codepoint" l'un est rattaché à deux classes "ZnCodexxx" tandis que l'autre à "Character".
			> Character			
------------------------------------------------------------------------------------------
			Key				Value			
------------------------------------------------------------------------------------------
			self				$a
(p minuscule ?)		codepoint			97		ZnCodePointReadStream or ZnCodePointWriteStream ?	
			unicode				'U+0061'		
			

* Elle est à l'envers par rapport à la fenêtre de la classe du SystemBrowser ?
 									> Meta
------------------------------------------------------------------------------------------
			Methods						Class Hierarchy
------------------------------------------------------------------------------------------
(P majuscule ?)		codePoint					Character
-------------------------------------------------------------------------------------------

Playground (CTRL+O+W) -> codepoint (CTRL+M) > 	ZnCodePointReadStream
						ZnCodePointWriteStream 

Playground (CTRL+O+W) -> codePoint (CTRL+M) > 	(P)Kernel - (C)Character - (M)codePoint
									codePoint
									"Just for ANSI Compliance"	
									^self asciiValue
----------------------------------------------------------------------------------------------- stream peek FIN

Playground (CTRL+O+W) -> ReadStream 	(Do it and go - CTRL+G) 
Playground (CTRL+O+W) -> 'a ReadStream' (Do it and go - CTRL+G) 
Playground (CTRL+O+W) -> #readStream 	(Do it and go - CTRL+G) 


* Il faut envoyer l'élément (skip, reset) à "a ReadStream" puis demander la position.
(skip: 3 -> position ? - skip: -2 -> position ? - reset -> position ?)

Playground (CTRL+O+W) ->
| stream |				(CTRL+P) > "nil"
stream := 'abcdef' readStream.		(CTRL+P) > "a ReadStream"
stream next.				(CTRL+P) > "$a"
stream skip: 3.	--------		(CTRL+P) > "a ReadStream"	---------	(CTRL+G) > Contents > abc	(0a1b2c3d)
stream skip: -2. ----- |		(CTRL+P) > "a ReadStream"	------	|	(CTRL+G) > Contents > a 	(0a1b)
stream reset.	---  | |		(CTRL+P) > "a ReadStream"	---  |	|	(CTRL+G) > Contents > abcdef
stream position. --|-|-|	-> résultats ------------------------->	   0 1	3


13:37 16/04/2021

* J'ai dû enlever les commentaires, car le code ne fonctionnait pas (Variable or expression expected ->) à cause de plusieurs espaces entre les codes.

* Voici une implémentation possible d'un algorithme utilisant atEnd 
qui prend deux collections triées comme paramètres et fusionne ces collections dans une autre collection triée :

Note : 
-----
Il le met à la fin du code plutôt qu'au début.

| stream1 stream2 result |
stream1 := #(1 4 9 11 12 13) readStream.
stream2 := #(1 2 3 4 5 10 13 14 15) readStream.

result := OrderedCollection new.
[stream1 atEnd not & stream2 atEnd not ] whileTrue: [ stream1 peek < stream2 peek ifTrue: [result add: stream1 next] ifFalse: [result add: stream2 next] ].
result addAll: stream1 upToEnd; addAll: stream2 upToEnd.
result.

| stream1 stream2 result |					(CTRL+P) > "nil"
stream1 := #(1 4 9 11 12 13) readStream.			(CTRL+P) > "a ReadStream"
						(CTRL+I) > Raw -> a ReadStream 
						Variable		Value
* self Variable = Non, Pseudo Variable = Oui	(c)self			a ReadStream
p. 54 FR 76 EN
* pseudo-variable - self est un mot clé qui fait référence à l'objet à l'intérieur duquel la méthode actuelle s'execute.
Nous l'appelon "le récepteur" parce que cet objet a reçu le message qui a entrainé l'exécution de la méthode.
self est appelé une "pseudo-variable" car nous ne pouvons pas l'assigner.

						()collection		an Array (6 items) (1 4 9 11 12 13)
						E position		0
						E readlimit		6
							> Contents
						#(1 4 9 11 12 13)
							> Meta
						Class Hierarchy		Methods		Protocol
						ReadStream		readStream	accessing
						PositionableStream
						Stream
						Object
						ProtoObject

stream2 := #(1 2 3 4 5 10 13 14 15) readStream.			(CTRL+P) > "a ReadStream"

result := OrderedCollection new.				(CTRL+P) > "an OrderedCollection()"
		|----------------------->	(CTRL+G) > Raw -> self - an OrderedCollection (0 items) 
								  array - an Array (10 items) "#(nil nil nil nil nil nil nil nil nil nil)"
												|-> (1,2,3,4,5,9,10,11,12,13)

[stream1 atEnd not & stream2 atEnd not ] whileTrue: [ stream1 peek < stream2 peek 
			ifTrue: [result add: stream1 next] 
			ifFalse: [result add: stream2 next] ].	(CTRL+P) > "nil"

result addAll: stream1 upToEnd; addAll: stream2 upToEnd.	(CTRL+P) > "a ReadStream"
						(CTRL+G) > Raw -> an Array (2 items) (14 15)
						(CTRL+G) > Meta -> addAll: -> Collection
result. 							(CTRL+P) > "an OrderedCollection(1 1 2 3 4 4 5 9 10 11 12 13 13 14 15)"
						(CTRL+G) > Raw -> self - an OrderedCollection (15 items) (1 1 2 3 4 4 5 9 10 11 12 13 13 14 15)
								  array - an Array (20 items) (1 1 2 3 4 4 5 9 10 11 12 13 13 14 15 nil nil nil nil nil)

* Pourquoi de (2 items - 14 15) ça passe à (20 items) ?

D11:22 16/04/2021 - F13:58 - Chapitre 11 - p.165/259 FR 242/376 EN
-------------------------------------------------------------------------------------------------------16/04/2021 fin



-------------------------------------------------------------------------------------------------------18/04/2021 debut
D11:56 18/04/2021 - F - Chapitre 11 - p.165/259 FR 242/376 EN
D11:56 18/04/2021 - F18:34 - Chapitre 11 - p.165/259 FR 242/376 EN

- 28 mns
- 13 mns

Rappel : 
--------
D09:16 07/01/2021 - F13:27 - Chapitre 10 - p.134/259 FR 198/376 EN

Question : 
---------

Si "Object new printString='an Object'" affiche "an" et que "LRUCache new printString='a LRUCache(#0 0/16 [ 1 ] 0%)'" 
affiche "a" qu'est-ce qui les différencie ?
Pourquoi l'un affiche "a" et l'autre "an" ?

Recherche : 
----------
Différence entre "a" et "an" ?

Réponses : 
----------

1. "The default implementation simply writes the class name preceded by a or an."
"L'implémentation par défaut écrit simplement le nom de classe précédé d'un "a" ou d'un "an"."

2. Si la classe commence par une voyelle alors "an" est envoyé à la variable "title" sinon "a".

3. Méthode Object >> printOn: est très probablement l'une des méthodes que vous remplacerez le plus fréquemment. 
Cette méthode prend comme argument un Stream sur lequel sera écrite une représentation String de l'objet. 
L'implémentation par défaut écrit simplement le nom de classe précédé de a ou an. 
Object >> printString renvoie la chaîne qui est écrite.
(p. 133 FR 196 EN - Impression - Printing)


Codes : 
-------
 
Playground (CTRL+O+W) > printOn: aStream (CTRL+M) > Implementors of printOn: (438) (Identique à dessous)
Playground (CTRL+O+W) > printOn: Object (CTRL+M) > Implementors of printOn: (438)

(pa) Kernel-Objects - ProtoObject - (c)Object - subclass : #Object - (pr) printing - (m)printOn:

code : Object -> printOn: :
---------------------------
printOn: aStream
	"Append to the argument, aStream, a sequence of characters that identifies the receiver."
	"Ajouter à l'argument, aStream, une séquence de caractères qui identifies le récepteur."

	| title |
	title := self class name.
	aStream
		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);
		nextPutAll: title

* Donc, si je comprends bien le code ci-dessus : 
	1. le nom d'une classe est envoyé à la pseudo-variable self puis à la variable "title",
	2. aStream : je ne sais pas ce qu'il fait au milieu, 
			* ajouter à l'argument aStream, une séquence de caractère qui identifie le récepteur ? 
			* Je ne comprends pas, car c'est envoyé à la variable "title" ?
			* donc, qu'est-ce qui est ajouté comme séquence de caractères ("an" ou "a" ?) ? De qui (title ?) ?
			* quel est l'intérêt de créer une variable dans le cas où cela serait envoyé à "aStream" ?
	3. Si la classe commence par une voyelle alors "an" est envoyé à la variable "title" sinon "a".


Stream :
--------

Playground (CTRL+O+W) > Stream (CTRL+I) > a Stream clas (Stream)
					Raw
					Variable d'instance	Value de la variable d'instance
(CTRL+M) -> 11 classes ?		(c)self			Stream
Implementors of superclass (8) ?	(c)superclass		Object
Implementors of methodDict (3) ?	()methoDict		a MethodDictionary (30 items) xxxxx
Implementors of format (14) ?		E format		0
Implementors of format (17) ?		(c)layout		a FixdeLayout
Implementors of organization (8) ?	(c)organization		a ClassOrganization
Implementors of subclasses (6) ?	()subclasses		an Array (13 items) xxxxx
Implementors of name (346) ?		| name			#Stream
Implementors of classPool (5) ?		()classPool		a Dictionary (0 items)
Implementors of sharedPools (12) ?	()sharedPools		an OrderedCollection (0 items)
Implementors of environment (46) ?	()environment		a SystemDictinary (9098 items) (lots of globals)
Implementors of category (40) ?		| category		#Collections-Streams-Base
	
* category, n'existe pas.

					Raw
					Variable d'instance	Value de la variable d'instance
					(c)self			Stream
					(c)superclass		Object
						(c)superclass		ProtoObject
							(c)superclass		nil	(?) - il n'est pas dans "UndefinedObject" ?


Playground (CTRL+O+W) > UndefinedObject (CTRL+I) > an UndefinedObject class (UndefinedObject)
					Raw
					Variable d'instance	Value de la variable d'instance
					(c)self			UndefinedObject
					(c)superclass		Object
						(c)superclass		ProtoObject
							(c)superclass		nil	(?) - il n'est pas dans "UndefinedObject" ?	
		
Playground (CTRL+O+W) > Collections-Streams (CTRL+M) > ReadStream
					protocol 	(pr)collection
					''		(pr)position
					''		(pr)readLimit

* Il existe une classe "collection", un protocol "collection",
		classe "position", un protocol "position",
		
* readLimit -> nil ?


Problèmes : améliorations
-----------
Depuis la fenêtre "Implementors of layout (17), j'ai lancé un "Filter..." sur le mot "FixedLayout" et m'a affiché "0",
lorsque j'ai effacé le mot "Fixed" dans la fenêtre "Filter...", la fenêtre "Implementors a affiché les 17 lignes précédentes,
mais le compteur sur le bandeau de la fenêtre était toujous à "0".
(Il faut cliquer sur une ligne pour que le total s'affiche de nouveau, alors qu'il devrait s'actualiser automatiquement.)

Playground (CTRL+O+W) > isVowel (CTRL+N) > Senders of detect: (188)
Lors de la lecture du code "BMPReadWriter" - "NextPutImage:" - "Graphics-Files,
j'ai été surpris par le nombre impressionnant de variables qui a été déclaré.
(| bhSize rowBytes rgb data colorValues depth image ppw scanLineLen pixline |),
mais surtout en bas de page du code le début et la fin de crochet (bloc).
Lorsque je clique à l'intérieur du dernier crochet en bas de page celui-ci n'affiche pas le début du crochet (bloc).
Pourquoi faut-il cliquer à l'extérieur du crochet en bas du code et à l'intérieur du crochet en début de code ?
Puisqu'en début de code c'est à l'intérieur alors à la fin cela devrait être équivalent.


nextPutAll: : p. 163 FR 239 EN - (next : prochain, put : mettre, all : tout)
-------------
StandardFileStream
fileNamed: 'test.txt'
do: [:str | str
nextPutAll: '123';
cr;
nextPutAll: 'abcd' ].


isVowel : est voyelle - est consonne ?
---------
p. 59 FR 84 EN
'hello there' select: [ :char | char isVowel ]
p. 143 FR 209 EN
Diverses méthodes de test pratiques sont intégrées: isAlphaNumeric, isCharacter, isDigit, isLowercase, isVowel, etc.
p. 159 FR 232 EN
'through' detect: [ :each | each isVowel ] >>> $o - 'à travers' détecter: [: chaque | chaque isVowel] >>> $ o



Rappel : SYNTAXE
----------------
p. 53 FR 75 EN
Chapitre 4 - La syntaxe en bref - Syntax in a nutshell

Assignment :	:= assigns an object to a variable. (Exemple : result := OrderedCollection new.)

self :				pseudo-variable - self est un mot clé qui fait référence à l'objet à l'intérieur duquel la méthode actuelle s'execute.
				Nous l'appelon "le récepteur" parce que cet objet a reçu le message qui a entrainé l'exécution de la méthode.
				self est appelé une "pseudo-variable" car nous ne pouvons pas l'assigner.

'Hello' :			la chaîne  'Bonjour' - the string 'Hello'

#Hello :			le symbole #Bonjour - the symbol #Hello

Transcript show: 'hello'; cr :	cascade de messages ( ; ) - message cascade (;)

cr : 				permet d'aller à la ligne (Transcript)

nil :				nil est l'objet non défini.
				C'est l'instance unique de la classe UndefinedObject. 
				Les variables d'instance, les variables de classe et les variables locales sont initialisées à zéro.

super :   			fait également référence au récepteur de la méthode courante, mais lorsque vous envoyez un message 
				à super, la recherche de méthode change pour qu'elle commence à partir de la superclasse de la classe 
				contenant la méthode qui utilise super. Pour plus de détails, voir le chapitre : (Le modèle d'objet Pharo p.75 FR - The Pharo Object Model p. 103 EN). 

* Les arguments et les variables locales doivent toujours commencer par des lettres minuscules. 
Les noms commençant par des majuscules sont supposés être des variables globales. 
Les noms de classe, comme Character, par exemple, 
sont simplement des variables globales faisant référence à l'objet représentant cette classe. 

Questions : 
----------

* Dans la fenêtre "Inpector on a ReadStream", "Raw" affiche deux colonnes l'une "Variable" et l'autre " Value".
 1. (c)self : L'icône rattachée à "self" indique une classe, mais celle-ci n'existe pas.
Pourquoi la classe "self" n'existe-t-elle pas alors qu'une icône classe est rattachée à celle-ci ? (réponse au-dessus ou p. 53 FR 75 EN)

 2. Si "self" est une "pseudo-variable" pourquoi est-elle dans la catégorie "Variable" ?

 3. "Nous l'appelon "le récepteur" parce que cet objet a reçu le message qui a entrainé l'exécution de la méthode.
    self est appelé une "pseudo-variable" car nous ne pouvons pas l'assigner."
   Dans ce cas, pourquoi ne pas l'envoyer à la classe "(c)Ojbect" ou "(c)ProtoObject", parce qu'il y a une confusion entre cette "pseudo-variable" et le code "^ self" ?

* ()collection, il y a 17 implémentations de collection.
 1. Laquelle est utilisée ? Que fait-elle ? Qu'elle code lit-elle ?

| stream1 stream2 result |

(m)readStream -> a ReadStream (a ReadStream = le récepteur)
			|-> (c)self -> (?) -> (pa) ?, (c) ?, (pr) ?, (m) ? - a ReadStream -> (pa)Collections-Streams-Base, (c)ReadStream, (pr)accessing, (m)readStream
			|-> ()collection -> Implementors of collection (17) -> (?) -> (pa) ?, (c) ?, (pr) ?, (m) ?  - an Array (6 items) (1 4 9 11 12 13) (an Array = le récepteur) -> (pa) Collections-Sequenceable-Base, (c) Array, (pr) ?, (m) ? 

* Au final, c'est la galère de trouver les relations lorsqu'un code fonctionne.


D11:56 18/04/2021 - F18:34 - Chapitre 11 - p.165/259 FR 242/376 EN
-------------------------------------------------------------------------------------------------------18/04/2021 fin



-------------------------------------------------------------------------------------------------------19/04/2021 debut
D09:41 19/04/2021 - F - Chapitre 11 - p.165/259 FR 242/376 EN
D09:41 19/04/2021 - F13:50 - Chapitre 11 - p.166/259 FR 243/376 EN

- 30 mns


* Au final, "self" et "nil" sont toujours dans les parages.

an OrderedCollection (15 items) xxx
	raw
	Variable d'instance	Value de la variable d'instance
	()array			an Array (20 items) xxx
	E 2			4
	|-> E self		|-> 4
	(c)16			nil
	|-> (c)self		|-> nil


Exercice entre-coupés : 
----------------------
L'exercice entre coupés fonctionne quand c'est dans la continuité sinon il faut reprendre au début.

| stream |
stream := 'abcdef' readStream.
stream next.

stream skip: 3. "stream is now after the d"
stream position.

stream skip: -2. "stream is after the b"
stream position.

stream reset.
stream position.

* Voici une implémentation possible d'un algorithme utilisant atEnd 
qui prend deux collections triées comme paramètres et fusionne ces collections dans une autre collection triée :

| stream1 stream2 result |
stream1 := #(1 4 9 11 12 13) readStream.
stream2 := #(1 2 3 4 5 10 13 14 15) readStream.

result := OrderedCollection new.
[stream1 atEnd not & stream2 atEnd not ] whileTrue: [ stream1 peek < stream2 peek ifTrue: [result add: stream1 next] ifFalse: [result add: stream2 next] ].
result addAll: stream1 upToEnd; addAll: stream2 upToEnd.
result.


stream skipTo: $e. "stream is just after the e now"
stream next.

stream contents.

---------------------------------------------------------------- TABLEAU DEBUT





negative : variable booléenne selon le signe du nombre	
   |-> Implementors of negative (5)

number : à sa valeur absolue
   |-> Implementors of number (4)


Classes : 
---------

ProtoObject
   Object
      Stream
        PositionableStream
	   ReadStream
             WriteStream
                 ReadWriteStream


TABLEAU : STREAM 
--------

Rappel : Mise à jour 11:16 19/04/2021
--------
	Mise à jour 10:09 22/04/2021
	Mise à jour 10:49 23/04/2021


11.3 Streaming over collections
print: Implementors of print: (13)
(pa)Collections-Streams-Base
(c)Object -> Inst. side
(c)Stream
 	\|/
  	 |----> (m)print: : ajoute la représentaiont textuelle du paramètre au flux 
	 |  |<-- (Methods) (pr)printing - (Vars) ?
	 |

11.3 Streaming over collections
* Méthodes de messages pratiques pour imprimer des caractères utiles dans un flux (stream), tels que  espace (space), tabulation (tab) 
et cr (retour chariot).
* ensureASpace garantit que le dernier caractère du flux est un espace; 
si le dernier caractère n'est pas un espace, il en ajoute un.



(pa)Collections-Streams-Base
(c)Stream -> Inst. side
(c)PositionableStream :
 	\|/
  	 |----> (m)peek (aperçu) : quel est l'élément suivant sans aller de l'avant (regarder le 1re élément sans le consommer) 
	 |  |<-- (Methods) (pr)accessing - (Vars) (pr)PositionableStream, (pr)position
	 |
	 |---> (m)peekFor: : avance si l'élément suivant est égal au paramètre et ne bouge pas autrement
	 |  |	      |---> "renvoie également un booléen indiquant si le paramètre est égal à l'élément."
	 |  |<-- (Methods) (pr)accessing - (Vars) (pr)PositionableStream, (pr)position
	 |
	 |---> (m)position: : message pour positionner le pointeur du flux
	 |  |<-- (Methods) (pr)positioning - (Vars) (pr)PositionableStream, (pr)position, (pr)readLimit
	 |
	 |---> (m)reset : se positionne au début ou à la fin du flux
	 |  |	    |---> stream reset.
	 |  |<-- (Methods) (pr)initialization - (Vars) (pr)PositionableStream, (pr)position 
	 |
	 |---> (m)setToEnd : se positionne au début ou à la fin du flux 
	 |  |<-- (Methods) (pr)positioning - (Vars) (pr)PositionableStream, (pr)position, (pr)readLimit 		
	 |
	 |---> (m)skip: : utilisés pour aller vers un emplacement par rapport à la position actuelle
 	 |  |	    |---> accepte un nombre comme argument et ignore ce nombre d'éléments
 	 |  |	    |---> stream skip: 3. "stream is now after the d"
 	 |  |	    |---> stream skip: -2. "stream is after the b"
	 |  |<-- (Methods) (pr)positioning - (Vars) (pr)PositionableStream, (pr)position
	 |
	 |---> (m)skipTo: : utilisés pour aller vers un emplacement par rapport à la position actuelle
 	 |  |	     |---> ignore tous les éléments du flux jusqu'à ce qu'il trouve un élément égal à son paramètre.
 	 |  |	     |---> À retenir : positionne le flux après l'élément correspondant.
	 |  |<-- (Methods) (pr)positioning - (Vars) Rien
	 |
	 |---> (m)contents : le message "contents" retourne toujours une copie de l'ensemble du flux.
 	 |  |	      |---> stream contents.
	 |  |<-- (Methods) (pr)accessing - (Vars) (pr)PositionableStream, (pr)collection, (pr)readLimit
	 |
	 |---> (m)atEnd: : certains messages permet de tester l'état du flux actuel. 
         |  |		   atEnd redevient true (vrai) si et seulement si plus aucun élément ne peut être lu.
	 |  |<-- (Methods) (pr)testing - (Vars) (pr)PositionableStream, (pr)position, (pr)readLimit
	 |
	 |---> (m)isEmpty: : retourne true (vrai) si et seulement s'il n'y a aucun élément dans la collection. 
	 |  |<-- (Methods) (pr)testing - (Vars) (pr)PositionableStream, (pr)position



(pa)Collections-Streams-Base
(c)PositionableStream -> Inst. side
(c)ReadStream : lit les éléments d'une collection - lire une collection en itérant sur ses éléments (itérant = Exécuter plusieurs fois.)
 	\|/
	 |---> (m)next : récupère un ou plusierus éléments de la collection
	 |  |<-- (Methods) (pr)accessing - (Vars) (pr)PositionableStream, (pr)collection, (pr)position, (pr)readLimit  
	 |
	 |---> (m)next: : récupère un ou plusierus éléments de la collection
	 |  |<-- (Methods) (pr)accessing - (Vars) (pr)PositionableStream, (pr)collection, (pr)position, (pr)readLimit  
	 |
	 |---> (m)upToEnd : renvoie tout, de la position actuelle à la fin du flux et définit le flux jusqu'à sa fin. (Simplification : peekFor:)
	 |  |<-- (Methods) (pr)accessing - (Vars) (pr)PositionableStream, (pr)collection, (pr)position, (pr)readLimit
	 |
	 |
	 |-(?)---> message -> collection séquençable (comme une chaîne) pour obtenir un flux de lecture sur cette collection particulière
			|-> Implementors of number (23)



11.3 Streaming over collections
(pa)Collections-Streams-Base
(c)PositionableStream -> Inst. side
(c)WriteStream : créer des collections - Les WriteStream sont utiles pour ajouter un grand nombre de données à une collection 
à différents endroits. Ils sont souvent utilisés pour construire des chaînes basées sur des parties statiques et dynamiques.
 	\|/
  	 |----> (m)nextPut: : ajoute le paramètre au flux 
	 |  |			* nexPut: sur un WriteStream est souvent le meilleur moyen de concaténer des caractères.
	 |  |			* L'utilisation de l'opérateur de concaténation par virgule ( , ) est beaucoup moins efficace
	 |  |<-- (Methods) (pr)accessing - (Vars) (pr)PositionableStream, (pr)collection, (pr)position, (pr)WriteStream, (pr)writeLimit
	 |
  	 |----> (m)nextPutAll: : ajoute chaque élément de la collectin, passé en paramètre, au flux 
	 |  |			* nextPutAll: sur un WriteStream est souvent le meilleur moyen de concaténer des caractères.
	 |  |			* L'utilisation de l'opérateur de concaténation par virgule ( , ) est beaucoup moins efficace
	 |  |<-- (Methods) (pr)accessing - (Vars) (pr)PositionableStream, (pr)collection, (pr)position, (pr)WriteStream, (pr)writeLimit
	 |
  	 |----> (m)size :  
	 |  |<-- (Methods) (pr)accessing - (Vars) (pr)PositionableStream, (pr)position, (pr)readLimit
	 |


* WriteStream : concaténation - nextPut:, nextPutAll:
-----------------------------
La raison pour laquelle l'utilisation d'un flux peut être beaucoup plus efficace est que l'utilisation d'une virgule crée une nouvelle
chaîne contenant la concaténation du récepteur et de l'argument, elle doit donc les copier tous les deux.

	stream -> (,) -> création -> chaîne récepteur + argument
						|
					copie du récepteur(1), copie du récepteur(2), etc -> caractères copiés -> exponentiels
						|
					déchets collectés
						|
	   utilisation d'un flux (optimisation) - concaténation de chaînes (dégradation) 


(pa)Collections-Streams-Base
(c)WriteStream -> Inst. side
(c)ReadWriteStream : utiliser un flux pour accéder à une collection pour lire et écrire en même temps
 	\|/
  	 |----> (m)nextPut: : ajoute le paramètre au flux 
	 |  |			* nexPut: sur un WriteStream est souvent le meilleur moyen de concaténer des caractères.
	 |  |			* L'utilisation de l'opérateur de concaténation par virgule ( , ) est beaucoup moins efficace
	 |  |<-- (Methods) (pr)accessing - (Vars) (pr)PositionableStream, (pr)collection, (pr)position, (pr)WriteStream, (pr)writeLimit
	 |



11.3 Streaming over collections
(pa)Collections-Abstract
(c)SequenceableCollection -> Class side
 	\|/
  	 |----> (m)streamContents: : crée une collection et un flux sur cette collection pour vous.
	 |  |				Il exécute ensuite le bloc que vous avez donné en passant le flux en tant que paramètre.
	 |  |				Lorsque le bloc se termine, stream-Contents: renvoie le contenu de la collection. 
	 |  |<-- (Methods) (pr)stream creation - (Vars) ?
	 |

* Le message streamContents: defined SequenceableCollection crée une collection et un flux sur cette collection pour vous. 
Il exécute ensuite le bloc que vous avez donné en passant le flux en tant que paramètre.
Lorsque le bloc se termine, stream-Contents: renvoie le contenu de la collection.



---------------------------------------------------------------- TABLEAU FIN


| stream |
stream := String new writeStream.
stream
nextPutAll: 'This Smalltalk image contains: ';
print: Smalltalk allClasses size;
nextPutAll: ' classes.';
cr;
nextPutAll: 'This is really a lot.'.
stream contents.

* Étant donné que la copie du code ne fonctionne pas, je recherche un équivalent "cr;" et autre : 

1 StandardFileStream fileNamed: 'test.txt' do: [:str | str nextPutAll: '123'; cr; nextPutAll: 'abcd' ].
2 nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);
		nextPutAll: title


Remarques : 
----------
Le code ci-dessus est copié dans Playground, mais "StandardFileStream" et "fileNamed:" sont collés alors qu'il ne le devrait pas ?
Le code "Smalltalk" affiche dans Playground "Smlltalk" les lettres "m" et "a" est concaténé.

Playground (CTRL+O+W) > 
			| stream | 				(CTRL+P) > "nil"
			stream := String new writeStream.	(CTRL+P) > "a WriteStream"
			stream 					(CTRL+P) > "a WriteStream"
1 test
nextPutAll: 'This Smalltalk image contains: ';print: Smalltalk allClasses size;nextPutAll: ' classes.'; cr;nextPutAll: 'This is really a lot.'.		(CTRL+P) > Variable or expression expected->
2 test
nextPutAll: 'This Smalltalk image contains: '; print: Smalltalk allClasses size; nextPutAll: ' classes.'; cr; nextPutAll: 'This is really a lot.'.	(CTRL+P) > Variable or expression expected->
3 test
nextPutAll: 'This Smalltalk image contains:'; print: Smalltalk allClasses size; nextPutAll: 'classes.'; cr; nextPutAll: 'This is really a lot.'.	(CTRL+P) > Variable or expression expected->
4 test
5 test
6 test
7 test
8 test
9 test
nextPutAll: ('This Smalltalk image contains:'; print: Smalltalk allClasses size; nextPutAll: 'classes.'; cr; nextPutAll: 'This is really a lot.').


13:51 19/04/2021 : C'est la merde ! 


Playground (CTRL+O+W) >
| string | 																(CTRL+P) > "nil"
string := String streamContents: [ :stream | stream print: #(1 2 3); space; nextPutAll: 'size'; space; nextPut: $=; space; print: 3. ]. (CTRL+P) > "'#(1 2 3) size = 3'"
string. 																(CTRL+P) > "'#(1 2 3) size = 3'"
 

11:24 19/04/2021
Bug de Pharo.
J'ai lancé "Playground"-> reset -> Implementors of reset (131) -> clique -> PositionableStream - reset - Collections-Streams.
Tout est figé (Pharo, Welcome, Playground, Implementors of reset (131), PositionableStream>>reset) ?

D09:41 19/04/2021 - F13:50 - Chapitre 11 - p.166/259 FR 243/376 EN
-------------------------------------------------------------------------------------------------------19/04/2021 fin



-------------------------------------------------------------------------------------------------------20/04/2021 debut
D11:13 20/04/2021 - F - Chapitre 11 - p.166/259 FR 243/376 EN
D11:13 20/04/2021 - F11:57 - Chapitre 11 - p.166/259 FR 243/376 EN

1. StandardFileStream fileNamed: 'test.txt' do: [:str | str nextPutAll: '123'; cr; nextPutAll: 'abcd' ].
2. string := String streamContents: [ :stream | stream print: #(1 2 3); space; nextPutAll: 'size'; space; nextPut: $=; space; print: 3. ].

3. Listing 6-22 - fonctionne pas
Morph >> fullPrintOn: aStream
aStream nextPutAll: self class name, ' new'

4. Listing 6-24 - fonctionne pas
BorderedMorph >> fullPrintOn: aStream
aStream nextPutAll: '('. super fullPrintOn: aStream. aStream nextPutAll: ') setBorderWidth: '; print: borderWidth; nextPutAll: ' borderColor: ', (self colorString: borderColor)

5. Listing 10-1 - fonctionne pas
Color >> printOn: aStream
| name |
(name := self name).
name = #unnamed
ifFalse: [^ aStream nextPutAll: 'Color '; nextPutAll: name ].
self storeOn: aStream]]]
[[[testcase=true
Color red printString

6. Listing 10-3
Interval >> printOn: aStream
aStream nextPut: $(;
print: start;
nextPutAll: ' to: ';
print: stop.
step ~= 1 ifTrue: [aStream nextPutAll: ' by: '; print: step].
aStream nextPut: $)

7. 11.2
StandardFileStream
fileNamed: 'test.txt'
do: [:str | str
nextPutAll: '123';
cr;
nextPutAll: 'abcd' ].


10 test
nextPutAll: 'This Smalltalk image contains:'; cr; print: Smalltalk allClasses size; cr; nextPutAll: 'classes.';  cr; nextPutAll: 'This is really a lot.'.
11 test
nextPutAll: 'This Smalltalk image contains:'; print: Smalltalk allClasses size; nextPutAll: 'classes.';  cr; nextPutAll: 'This is really a lot.'.
12 test
Smalltalk allClasses size printString "'9085'"

D11:13 20/04/2021 - F11:57 - Chapitre 11 - p.166/259 FR 243/376 EN
-------------------------------------------------------------------------------------------------------20/04/2021 fin



-------------------------------------------------------------------------------------------------------21/04/2021 debut
D13:48 21/04/2021 - F - Chapitre 11 - p.166/259 FR 243/376 EN

J'étais persuadé de la réussite de la commande "Smalltalk allClasses size printString "'9085'".

D13:48 21/04/2021 - F14:02 - Chapitre 11 - p.166/259 FR 243/376 EN
-------------------------------------------------------------------------------------------------------21/04/2021 fin



-------------------------------------------------------------------------------------------------------22/04/2021 debut
D09:41 22/04/2021 - F - Chapitre 11 - p.166/259 FR 243/376 EN
D09:41 22/04/2021 - F12:35 - Chapitre 11 - p.167/259 FR 243/376 EN


Tableau : Mise à jour 10:09 22/04/2021
---------

* C'est bizarre, car j'avais déjà essayé cette ligne (3 lignes) sans pour autant que cela fonctionne. (?)
(Sans doute qu'il n'y avait pas d'espace après les points-virgules).

* print vs printString

* "cr;" met à la suite "This is really a lot" sous Playground, mais pas sous le bloc-notes "1234-abcde".


Ligne de code numéroté
----------------------
1. | stream |
2. stream := String new writeStream.
3. stream nextPutAll: 'This Smalltalk image contains: '; print: Smalltalk allClasses size; nextPutAll: ' classes.'; cr; nextPutAll: 'This is really a lot.'.
4. stream contents.

Code copié/collé sans modification
----------------------------------
| stream | "nil"
stream := String new writeStream. "a WriteStream"
stream nextPutAll: 'This Smalltalk image contains: '; print: Smalltalk allClasses size; nextPutAll: ' classes.'; cr; nextPutAll: 'This is really a lot.'."'This is really a lot.'"
stream contents. "'This Smalltalk image contains: 9085 classes.
This is really a lot.'"

Code avec les réponses en plus des raccourcies claviers
-----------------------
Playground (CTRL+O+W) > 
| stream | 								(CTRL+P) > "nil"
stream := String new writeStream. "a WriteStream"
stream nextPutAll: 'This Smalltalk image contains: '; 
print: Smalltalk allClasses size; nextPutAll: ' classes.'; 
cr; nextPutAll: 'This is really a lot.'.				(CTRL+P) > "'This is really a lot.'"
stream contents. 							(CTRL+P) > "'This Smalltalk image contains: 9085 classes. This is really a lot.'"

11:11 22/04/2021
* Je ne comprends pas.
Pourquoi mettre un crochet en ouverture avant une variable ? [|temp|

* C'est la merde votre code, je passe plus mon temps à combler les espaces lors d'un copier/coller ou résoudre les messages d'erreur.


[| temp |
temp := String new.
(1 to: 100000)
do: [:i | temp := temp, i asString, ' ' ] ] timeToRun

-------------------------------------------------------------------------TEST DEBUT
1 test
Playground (CTRL+O+W) > 
[| temp |								(CTRL+P) > ']' expected ->
temp := String new.							(CTRL+P) > "''"
(1 to: 100000)								(CTRL+P) > "(1 to: 100000)"
do: [:i | temp := temp, i asString, ' ' ] ] timeToRun			(CTRL+P) > Variable or expression expected ->

2 test
Playground (CTRL+O+W) >
[| temp | temp := String new. (1 to: 100000) do: [:i | temp := temp, i asString, ' ' ] ] (CTRL+P) > "[ | temp |
												    temp := String new.
												    (1 to: 100000) do: [ :i | temp := temp , i asString , ' ' ] ]"
timeToRun										(CTRL+P) > Unmatched " in comment. ->


* Putain y'en a marre de perdre du temps avec ce code à deux balles.
3 test
Playground (CTRL+O+W) >
[| temp | temp := String new.						(CTRL+P) > ']' expected -> 
	(1 to: 100000) do: [:i | temp := temp, i asString, ' ' ] ]	(CTRL+P) > Unknown input at end ->
timeToRun								(CTRL+P) > "nil"


* Putain que ça m'énerve ! 
* Perdre du temps avec ce code c'est l'une des spécialités de Pharo.
* C'est tellement "cool" que c'est obligé de se prendre la tête avec cette merde. 
* 11:52 22/04/2021 le bordel est toujours bloqué et en cours d'exécution. Je peux rien faire.
* 11:57 22/04/2021 enfin j'ai repris la main sur ce programme à deux balles.

4 test
Playground (CTRL+O+W) >
| temp | temp := String new.					(CTRL+P) > 
	(1 to: 100000) do: [:i | temp := temp, i asString, ' ' ](CTRL+P) > Blocage 1-> départ 11:28 - fin 11:33 --> aucun message (Pharo.exe - Pharo Cog Spur Virtual Machine - En cours d'exécution)
									   Blocage 2-> départ 11:34 - à 11:45 Toujours pas la main. - fin 11:57 C'est quoi cette merde. (Pharo.exe - Pharo Cog Spur Virtual Machine - En cours d'exécution)
timeToRun							(CTRL+P) > "nil"


* Pharo bloque
5 test
Playground (CTRL+O+W) >
| temp |							(CTRL+P) > "nil"
temp := String new.						(CTRL+P) > "''"
(1 to: 100000) do: [:i | temp := temp, i asString, ' ' ]. 	(CTRL+P) > Blocage 1 12:01 - Arret du programme, ça m'énerve cette situation.
timeToRun							(CTRL+P) >


* Pharo bloque
* Bon et bien, je pense que ce code je vais le laisser de côté comme le jeu LightOut.
6 test
temp := String new.
(1 to: 100000) do: [:i | temp := temp, i printString, ' ' ].
temp

7 test
result := String new. 						"''"
(1 to: 10) do: [:n | result := result, n asString, ' ']. 	"(1 to: 10)"
timeToRun 							"nil"

8 test
| result | 							"nil"
result := String new.						"''"
(1 to: 10) do: [:n | result := result, n asString, ' '].	"(1 to: 10)"
timeToRun							"nil"

* Pas de crochet, un crochet, un point et pas de point, c'est vague, tu n'en sais rien.
* Ce code n'est pas propre, carré, intuitif, c'est une perte de temps.
9 test - 12:13 22/04/2021
[| temp |							(CTRL+P) > ']' expected -> 
temp := String new.						(CTRL+P) > "''"
(1 to: 100000) do: [:i | temp := temp, i asString, ' ' ]] 	(CTRL+P) > Unknown input at end ->
timeToRun							(CTRL+P) > "nil"

10 test
[| temp |							(CTRL+P) > ']' expected -> 
temp := String new.						(CTRL+P) > "''"
(1 to: 100000) do: [:i | temp := temp, i asString, ' ' ] ] 	(CTRL+P) > ']' expected -> 
timeToRun							(CTRL+P) > "nil"

* Aucune solution trouvée, je n'insiste plus et passe à autre chose.

-------------------------------------------------------------------------TEST FIN

* Ci-dessous piste pour essayer de comprendre pourquoi le code pharo "prise de tête" ci-dessus ne fonctionne pas.
* Le code de la ligne n° 4. 4.6 Conditionals and loops in a nutshell est presque identique.

* C'est une frustration relativement au maigre résultat concret obtenu et la poursuite de la lutte est une perte de temps.


----------------------------------------------Piste DEBUT - 11:51 22/04/2021
1. 11.2 Streams vs. collections
| r |
r := ReadStream on: (1 to: 1000).
r next.

2. 10.13 Some hints for using collections
factorial := [ :n | (1 to: n) inject: 1 into: [ :product :each |
product * each ] ].
factorial value: 10

3. 10.13 Some hints for using collections
(1 to: 100) inject: 0 into: [ :sum :each | sum + each ]

4. 4.6 Conditionals and loops in a nutshell
result := String new.
(1 to: 10) do: [:n | result := result, n printString, ' '].
result

5. 11.3 Streaming over collections
String streamContents: [ :tempStream | (1 to: 100000) do: [:i | tempStream nextPutAll: i asString; space ] ]

[| temp |
temp := String new.
(1 to: 100000) do: [:i | temp := temp, i asString, ' ' ] ] timeToRun

----------------------------------------------Piste FIN


12:33 22/04/2021
* Celui-ci, c'est une surprise, il fonctionne après avoir comblé les espaces.


Playground (CTRL+O+W) >

String streamContents: [ :tempStream | (1 to: 100000) do: [:i | tempStream nextPutAll: i asString; space ] ] (CTRL+P) >
 "'1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 1462 1463 1464 1465 1466 1467 1468 1469 1470 1471 1472 1473 1474 1475 1476 1477 1478 1479 1480 1481 1482 1483 1484 1485 1486 1487 1488 1489 1490 1491 1492 1493 1494 1495 1496 1497 1498 1499 1500 1501 1502 1503 1504 1505 1506 1507 1508 1509 1510 1511 1512 1513 1514 1515 1516 1517 1518 1519 1520 1521 1522 1523 1524 1525 1526 1527 1528 1529 1530 1531 1532 1533 1534 1535 1536 1537 1538 1539 1540 1541 1542 1543 1544 1545 1546 1547 1548 1549 1550 1551 1552 1553 1554 1555 1556 1557 1558 1559 1560 1561 1562 1563 1564 1565 1566 1567 1568 1569 1570 1571 1572 1573 1574 1575 1576 1577 1578 1579 1580 1581 1582 1583 1584 1585 1586 1587 1588 1589 1590 1591 1592 1593 1594 1595 1596 1597 1598 1599 1600 1601 1602 1603 1604 1605 1606 1607 1608 1609 1610 1611 1612 1613 1614 1615 1616 1617 1618 1619 1620 1621 1622 1623 1624 1625 1626 1627 1628 1629 1630 1631 1632 1633 1634 1635 1636 1637 1638 1639 1640 1641 1642 1643 1644 1645 1646 1647 1648 1649 1650 1651 1652 1653 1654 1655 1656 1657 1658 1659 1660 1661 1662 1663 1664 1665 1666 1667 1668 1669 1670 1671 1672 1673 1674 1675 1676 1677 1678 1679 1680 1681 1682 1683 1684 1685 1686 1687 1688 1689 1690 1691 1692 1693 1694 1695 1696 1697 1698 1699 1700 1701 1702 1703 1704 1705 1706 1707 1708 1709 1710 1711 1712 1713 1714 1715 1716 1717 1718 1719 1720 1721 1722 1723 1724 1725 1726 1727 1728 1729 1730 1731 1732 1733 1734 1735 1736 1737 1738 1739 1740 1741 1742 1743 1744 1745 1746 1747 1748 1749 1750 1751 1752 1753 1754 1755 1756 1757 1758 1759 1760 1761 1762 1763 1764 1765 1766 1767 1768 1769 1770 1771 1772 1773 1774 1775 1776 1777 1778 1779 1780 1781 1782 1783 1784 1785 1786 1787 1788 1789 1790 1791 1792 1793 1794 1795 1796 1797 1798 1799 1800 1801 1802 1803 1804 1805 1806 1807 1808 1809 1810 1811 1812 1813 1814 1815 1816 1817 1818 1819 1820 1821 1822 1823 1824 1825 1826 1827 1828 1829 1830 1831 1832 1833 1834 1835 1836 1837 1838 1839 1840 1841 1842 1843 1844 1845 1846 1847 1848 1849 1850 1851 1852 1853 1854 1855 1856 1857 1858 1859 1860 1861 1862 1863 1864 1865 1866 1867 1868 1869 1870 1871 1872 1873 1874 1875 1876 1877 1878 1879 1880 1881 1882 1883 1884 1885 1886 1887 1888 1889 1890 1891 1892 1893 1894 1895 1896 1897 1898 1899 1900 1901 1902 1903 1904 1905 1906 1907 1908 1909 1910 1911 1912 1913 1914 1915 1916 1917 1918 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022 2023 2024 2025 2026 2027 2028 2029 2030 2031 2032 2033 2034 2035 2036 2037 2038 2039 2040 2041 2042 2043 2044 2045 2046 2047 2048 2049 2050 2051 2052 2053 2054 2055 2056 2057 2058 2059 2060 2061 2062 2063 2064 2065 2066 2067 2068 2069 2070 2071 2072 2073 2074 2075 2076 2077 2078 2079 2080 2081 2082 2083 2084 2085 2086 2087 2088 2089 2090 2091 2092 2093 2094 2095 2096 2097 2098 2099 2100 2101 2102 2103 2104 2105 2106 2107 2108 2109 2110 2111 2112 2113 2114 2115 2116 2117 2118 2119 2120 2121 2122 2123 2124 2125 2126 2127 2128 2129 2130 2131 2132 2133 2134 2135 2136 2137 2138 2139 2140 2141 2142 2143 2144 2145 2146 2147 2148 2149 2150 2151 2152 2153 2154 2155 2156 2157 2158 2159 2160 2161 2162 2163 2164 2165 2166 2167 2168 2169 2170 2171 2172 2173 2174 2175 2176 2177 2178 2179 2180 2181 2182 2183 2184 2185 2186 2187 2188 2189 2190 2191 2192 2193 2194 2195 2196 2197 2198 2199 2200 2201 2202 2203 2204 2205 2206 2207 2208 2209 2210 2211 2212 2213 2214 2215 2216 2217 2218 2219 2220 2221 2222 2223 2224 2225 2226 2227 2228 2229 2230 2231 2232 2233 2234 2235 2236 2237 2238 2239 2240 2241 2242 2243 2244 2245 2246 2247 2248 2249 2250 2251 2252 2253 2254 2255 2256 2257 2258 2259 2260 2261 2262 2263 2264 2265 2266 2267 2268 2269 2270 2271 2272 2273 2274 2275 2276 2277 2278 2279 2280 2281 2282 2283 2284 2285 2286 2287 2288 2289 2290 2291 2292 2293 2294 2295 2296 2297 2298 2299 2300 2301 2302 2303 2304 2305 2306 2307 2308 2309 2310 2311 2312 2313 2314 2315 2316 2317 2318 2319 2320 2321 2322 2323 2324 2325 2326 2327 2328 2329 2330 2331 2332 2333 2334 2335 2336 2337 2338 2339 2340 2341 2342 2343 2344 2345 2346 2347 2348 2349 2350 2351 2352 2353 2354 2355 2356 2357 2358 2359 2360 2361 2362 2363 2364 2365 2366 2367 2368 2369 2370 2371 2372 2373 2374 2375 2376 2377 2378 2379 2380 2381 2382 2383 2384 2385 2386 2387 2388 2389 2390 2391 2392 2393 2394 2395 2396 2397 2398 2399 2400 2401 2402 2403 2404 2405 2406 2407 2408 2409 2410 2411 2412 2413 2414 2415 2416 2417 2418 2419 2420 2421 2422 2423 2424 2425 2426 2427 2428 2429 2430 2431 2432 2433 2434 2435 2436 2437 2438 2439 2440 2441 2442 2443 2444 2445 2446 2447 2448 2449 2450 2451 2452 2453 2454 2455 2456 2457 2458 2459 2460 2461 2462 2463 2464 2465 2466 2467 2468 2469 2470 2471 2472 2473 2474 2475 2476 2477 2478 2479 2480 2481 2482 2483 2484 2485 2486 2487 2488 2489 2490 2491 2492 2493 2494 2495 2496 2497 2498 2499 2500 2501 2502 2503 2504 2505 2506 2507 2508 2509 2510 2511 2512 2513 2514 2515 2516 2517 2518 2519 2520 2521 2522 2523 2524 2525 2526 2527 2528 2529 2530 2531 2532 2533 2534 2535 2536 2537 2538 2539 2540 2541 2542 2543 2544 2545 2546 2547 2548 2549 2550 2551 2552 2553 2554 2555 2556 2557 2558 2559 2560 2561 2562 2563 2564 2565 2566 2567 2568 2569 2570 2571 2572 2573 2574 2575 2576 2577 2578 2579 2580 2581 2582 2583 2584 2585 2586 2587 2588 2589 2590 2591 2592 2593 2594 2595 2596 2597 2598 2599 2600 2601 2602 2603 2604 2605 2606 2607 2608 2609 2610 2611 2612 2613 2614 2615 2616 2617 2618 2619 2620 2621 2622 2623 2624 2625 2626 2627 2628 2629 2630 2631 2632 2633 2634 2635 2636 2637 2638 2639 2640 2641 2642 2643 2644 2645 2646 2647 2648 2649 2650 2651 2652 2653 2654 2655 2656 2657 2658 2659 2660 2661 2662 2663 2664 2665 2666 2667 2668 2669 2670 2671 2672 2673 2674 2675 2676 2677 2678 2679 2680 2681 2682 2683 2684 2685 2686 2687 2688 2689 2690 2691 2692 2693 2694 2695 2696 2697 2698 2699 2700 2701 2702 2703 2704 2705 2706 2707 2708 2709 2710 2711 2712 2713 2714 2715 2716 2717 2718 2719 2720 2721 2722 2723 2724 2725 2726 2727 2728 2729 2730 2731 2732 2733 2734 2735 2736 2737 2738 2739 2740 2741 2742 2743 2744 2745 2746 2747 2748 2749 2750 2751 2752 2753 2754 2755 2756 2757 2758 2759 2760 2761 2762 2763 2764 2765 2766 2767 2768 2769 2770 2771 2772 2773 2774 2775 2776 2777 2778 2779 2780 2781 2782 2783 2784 2785 2786 2787 2788 2789 2790 2791 2792 2793 2794 2795 2796 2797 2798 2799 2800 2801 2802 2803 2804 2805 2806 2807 2808 2809 2810 2811 2812 2813 2814 2815 2816 2817 2818 2819 2820 2821 2822 2823 2824 2825 2826 2827 2828 2829 2830 2831 2832 2833 2834 2835 2836 2837 2838 2839 2840 2841 2842 2843 2844 2845 2846 2847 2848 2849 2850 2851 2852 2853 2854 2855 2856 2857 2858 2859 2860 2861 2862 2863 2864 2865 2866 2867 2868 2869 2870 2871 2872 2873 2874 2875 2876 2877 2878 2879 2880 2881 2882 2883 2884 2885 2886 2887 2888 2889 2890 2891 2892 2893 2894 2895 2896 2897 2898 2899 2900 2901 2902 2903 2904 2905 2906 2907 2908 2909 2910 2911 2912 2913 2914 2915 2916 2917 2918 2919 2920 2921 2922 2923 2924 2925 2926 2927 2928 2929 2930 2931 2932 2933 2934 2935 2936 2937 2938 2939 2940 2941 2942 2943 2944 2945 2946 2947 2948 2949 2950 2951 2952 2953 2954 2955 2956 2957 2958 2959 2960 2961 2962 2963 2964 2965 2966 2967 2968 2969 2970 2971 2972 2973 2974 2975 2976 2977 2978 2979 2980 2981 2982 2983 2984 2985 2986 2987 2988 2989 2990 2991 2992 2993 2994 2995 2996 2997 2998 2999 3000 3001 3002 3003 3004 3005 3006 3007 3008 3009 3010 3011 3012 3013 3014 3015 3016 3017 3018 3019 3020 3021 3022 3023 3024 3025 3026 3027 3028 3029 3030 3031 3032 3033 3034 3035 3036 3037 3038 3039 3040 3041 3042 3043 3044 3045 3046 3047 3048 3049 3050 3051 3052 3053 3054 3055 3056 3057 3058 3059 3060 3061 3062 3063 3064 3065 3066 3067 3068 3069 3070 3071 3072 3073 3074 3075 3076 3077 3078 3079 3080 3081 3082 3083 3084 3085 3086 3087 3088 3089 3090 3091 3092 3093 3094 3095 3096 3097 3098 3099 3100 3101 3102 3103 3104 3105 3106 3107 3108 3109 3110 3111 3112 3113 3114 3115 3116 3117 3118 3119 3120 3121 3122 3123 3124 3125 3126 3127 3128 3129 3130 3131 3132 3133 3134 3135 3136 3137 3138 3139 3140 3141 3142 3143 3144 3145 3146 3147 3148 3149 3150 3151 3152 3153 3154 3155 3156 3157 3158 3159 3160 3161 3162 3163 3164 3165 3166 3167 3168 3169 3170 3171 3172 3173 3174 3175 3176 3177 3178 3179 3180 3181 3182 3183 3184 3185 3186 3187 3188 3189 3190 3191 3192 3193 3194 3195 3196 3197 3198 3199 3200 3201 3202 3203 3204 3205 3206 3207 3208 3209 3210 3211 3212 3213 3214 3215 3216 3217 3218 3219 3220 3221 3222 3223 3224 3225 3226 3227 3228 3229 3230 3231 3232 3233 3234 3235 3236 3237 3238 3239 3240 3241 3242 3243 3244 3245 3246 3247 3248 3249 3250 3251 3252 3253 3254 3255 3256 3257 3258 3259 3260 3261 3262 3263 3264 3265 3266 3267 3268 3269 3270 3271 3272 3273 3274 3275 3276 3277 3278 3279 3280 3281 3282 3283 3284 3285 3286 3287 3288 3289 3290 3291 3292 3293 3294 3295 3296 3297 3298 3299 3300 3301 3302 3303 3304 3305 3306 3307 3308 3309 3310 3311 3312 3313 3314 3315 3316 3317 3318 3319 3320 3321 3322 3323 3324 3325 3326 3327 3328 3329 3330 3331 3332 3333 3334 3335 3336 3337 3338 3339 3340 3341 3342 3343 3344 3345 3346 3347 3348 3349 3350 3351 3352 3353 3354 3355 3356 3357 3358 3359 3360 3361 3362 3363 3364 3365 3366 3367 3368 3369 3370 3371 3372 3373 3374 3375 3376 3377 3378 3379 3380 3381 3382 3383 3384 3385 3386 3387 3388 3389 3390 3391 3392 3393 3394 3395 3396 3397 3398 3399 3400 3401 3402 3403 3404 3405 3406 3407 3408 3409 3410 3411 3412 3413 3414 3415 3416 3417 3418 3419 3420 3421 3422 3423 3424 3425 3426 3427 3428 3429 3430 3431 3432 3433 3434 3435 3436 3437 3438 3439 3440 3441 3442 3443 3444 3445 3446 3447 3448 3449 3450 3451 3452 3453 3454 3455 3456 3457 3458 3459 3460 3461 3462 3463 3464 3465 3466 3467 3468 3469 3470 3471 3472 3473 3474 3475 3476 3477 3478 3479 3480 3481 3482 3483 3484 3485 3486 3487 3488 3489 3490 3491 3492 3493 3494 3495 3496 3497 3498 3499 3500 3501 3502 3503 3504 3505 3506 3507 3508 3509 3510 3511 3512 3513 3514 3515 3516 3517 3518 3519 3520 3521 3522 3523 3524 3525 3526 3527 3528 3529 3530 3531 3532 3533 3534 3535 3536 3537 3538 3539 3540 3541 3542 3543 3544 3545 3546 3547 3548 3549 3550 3551 3552 3553 3554 3555 3556 3557 3558 3559 3560 3561 3562 3563 3564 3565 3566 3567 3568 3569 3570 3571 3572 3573 3574 3575 3576 3577 3578 3579 3580 3581 3582 3583 3584 3585 3586 3587 3588 3589 3590 3591 3592 3593 3594 3595 3596 3597 3598 3599 3600 3601 3602 3603 3604 3605 3606 3607 3608 3609 3610 3611 3612 3613 3614 3615 3616 3617 3618 3619 3620 3621 3622 3623 3624 3625 3626 3627 3628 3629 3630 3631 3632 3633 3634 3635 3636 3637 3638 3639 3640 3641 3642 3643 3644 3645 3646 3647 3648 3649 3650 3651 3652 3653 3654 3655 3656 3657 3658 3659 3660 3661 3662 3663 3664 3665 3666 3667 3668 3669 3670 3671 3672 3673 3674 3675 3676 3677 3678 3679 3680 3681 3682 3683 3684 3685 3686 3687 3688 3689 3690 3691 3692 3693 3694 3695 3696 3697 3698 3699 3700 3701 3702 3703 3704 3705 3706 3707 3708 3709 3710 3711 3712 3713 3714 3715 3716 3717 3718 3719 3720 3721 3722 3723 3724 3725 3726 3727 3728 3729 3730 3731 3732 3733 3734 3735 3736 3737 3738 3739 3740 3741 3742 3743 3744 3745 3746 3747 3748 3749 3750 3751 3752 3753 3754 3755 3756 3757 3758 3759 3760 3761 3762 3763 3764 3765 3766 3767 3768 3769 3770 3771 3772 3773 3774 3775 3776 3777 3778 3779 3780 3781 3782 3783 3784 3785 3786 3787 3788 3789 3790 3791 3792 3793 3794 3795 3796 3797 3798 3799 3800 3801 3802 3803 3804 3805 3806 3807 3808 3809 3810 3811 3812 3813 3814 3815 3816 3817 3818 3819 3820 3821 3822 3823 3824 3825 3826 3827 3828 3829 3830 3831 3832 3833 3834 3835 3836 3837 3838 3839 3840 3841 3842 3843 3844 3845 3846 3847 3848 3849 3850 3851 3852 3853 3854 3855 3856 3857 3858 3859 3860 3861 3862 3863 3864 3865 3866 3867 3868 3869 3870 3871 3872 3873 3874 3875 3876 3877 3878 3879 3880 3881 3882 3883 3884 3885 3886 3887 3888 3889 3890 3891 3892 3893 3894 3895 3896 3897 3898 3899 3900 3901 3902 3903 3904 3905 3906 3907 3908 3909 3910 3911 3912 3913 3914 3915 3916 3917 3918 3919 3920 3921 3922 3923 3924 3925 3926 3927 3928 3929 3930 3931 3932 3933 3934 3935 3936 3937 3938 3939 3940 3941 3942 3943 3944 3945 3946 3947 3948 3949 3950 3951 3952 3953 3954 3955 3956 3957 3958 3959 3960 3961 3962 3963 3964 3965 3966 3967 3968 3969 3970 3971 3972 3973 3974 3975 3976 3977 3978 3979 3980 3981 3982 3983 3984 3985 3986 3987 3988 3989 3990 3991 3992 3993 3994 3995 3996 3997 3998 3999 4000 4001 4002 4003 4004 4005 4006 4007 4008 4009 4010 4011 4012 4013 4014 4015 4016 4017 4018 4019 4020 4021 4022 4023 4024 4025 4026 4027 4028 4029 4030 4031 4032 4033 4034 4035 4036 4037 4038 4039 4040 4041 4042 4043 4044 4045 4046 4047 4048 4049 4050 4051 4052 4053 4054 4055 4056 4057 4058 4059 4060 4061 4062 4063 4064 4065 4066 4067 4068 4069 4070 4071 4072 4073 4074 4075 4076 4077 4078 4079 4080 4081 4082 4083 4084 4085 4086 4087 4088 4089 4090 4091 4092 4093 4094 4095 4096 4097 4098 4099 4100 4101 4102 4103 4104 4105 4106 4107 4108 4109 4110 4111 4112 4113 4114 4115 4116 4117 4118 4119 4120 4121 4122 4123 4124 4125 4126 4127 4128 4129 4130 4131 4132 4133 4134 4135 4136 4137 4138 4139 4140 4141 4142 4143 4144 4145 4146 4147 4148 4149 4150 4151 4152 4153 4154 4155 4156 4157 4158 4159 4160 4161 4162 4163 4164 4165 4166 4167 4168 4169 4170 4171 4172 4173 4174 4175 4176 4177 4178 4179 4180 4181 4182 4183 4184 4185 4186 4187 4188 4189 4190 4191 4192 4193 4194 4195 4196 4197 4198 4199 4200 4201 4202 4203 4204 4205 4206 4207 4208 4209 4210 4211 4212 4213 4214 4215 4216 4217 4218 4219 4220 4221 4222 4223 4224 4225 4226 4227 4228 4229 4230 4231 4232 4233 4234 4235 4236 4237 4238 4239 4240 4241 4242 4243 4244 4245 4246 4247 4248 4249 4250 4251 4252 4253 4254 4255 4256 4257 4258 4259 4260 4261 4262 4263 4264 4265 4266 4267 4268 4269 4270 4271 4272 4273 4274 4275 4276 4277 4278 4279 4280 4281 4282 4283 4284 4285 4286 4287 4288 4289 4290 4291 4292 4293 4294 4295 4296 4297 4298 4299 4300 4301 4302 4303 4304 4305 4306 4307 4308 4309 4310 4311 4312 4313 4314 4315 4316 4317 4318 4319 4320 4321 4322 4323 4324 4325 4326 4327 4328 4329 4330 4331 4332 4333 4334 4335 4336 4337 4338 4339 4340 4341 4342 4343 4344 4345 4346 4347 4348 4349 4350 4351 4352 4353 4354 4355 4356 4357 4358 4359 4360 4361 4362 4363 4364 4365 4366 4367 4368 4369 4370 4371 4372 4373 4374 4375 4376 4377 4378 4379 4380 4381 4382 4383 4384 4385 4386 4387 4388 4389 4390 4391 4392 4393 4394 4395 4396 4397 4398 4399 4400 4401 4402 4403 4404 4405 4406 4407 4408 4409 4410 4411 4412 4413 4414 4415 4416 4417 4418 4419 4420 4421 4422 4423 4424 4425 4426 4427 4428 4429 4430 4431 4432 4433 4434 4435 4436 4437 4438 4439 4440 4441 4442 4443 4444 4445 4446 4447 4448 4449 4450 4451 4452 4453 4454 4455 4456 4457 4458 4459 4460 4461 4462 4463 4464 4465 4466 4467 4468 4469 4470 4471 4472 4473 4474 4475 4476 4477 4478 4479 4480 4481 4482 4483 4484 4485 4486 4487 4488 4489 4490 4491 4492 4493 4494 4495 4496 4497 4498 4499 4500 4501 4502 4503 4504 4505 4506 4507 4508 4509 4510 4511 4512 4513 4514 4515 4516 4517 4518 4519 4520 4521 4522 4523 4524 4525 4526 4527 4528 4529 4530 4531 4532 4533 4534 4535 4536 4537 4538 4539 4540 4541 4542 4543 4544 4545 4546 4547 4548 4549 4550 4551 4552 4553 4554 4555 4556 4557 4558 4559 4560 4561 4562 4563 4564 4565 4566 4567 4568 4569 4570 4571 4572 4573 4574 4575 4576 4577 4578 4579 4580 4581 4582 4583 4584 4585 4586 4587 4588 4589 4590 4591 4592 4593 4594 4595 4596 4597 4598 4599 4600 4601 4602 4603 4604 4605 4606 4607 4608 4609 4610 4611 4612 4613 4614 4615 4616 4617 4618 4619 4620 4621 4622 4623 4624 4625 4626 4627 4628 4629 4630 4631 4632 4633 4634 4635 4636 4637 4638 4639 4640 4641 4642 4643 4644 4645 4646 4647 4648 4649 4650 4651 4652 4653 4654 4655 4656 4657 4658 4659 4660 4661 4662 4663 4664 4665 4666 4667 4668 4669 4670 4671 4672 4673 4674 4675 4676 4677 4678 4679 4680 4681 4682 4683 4684 4685 4686 4687 4688 4689 4690 4691 4692 4693 4694 4695 4696 4697 4698 4699 4700 4701 4702 4703 4704 4705 4706 4707 4708 4709 4710 4711 4712 4713 4714 4715 4716 4717 4718 4719 4720 4721 4722 4723 4724 4725 4726 4727 4728 4729 4730 4731 4732 4733 4734 4735 4736 4737 4738 4739 4740 4741 4742 4743 4744 4745 4746 4747 4748 4749 4750 4751 4752 4753 4754 4755 4756 4757 4758 4759 4760 4761 4762 4763 4764 4765 4766 4767 4768 4769 4770 4771 4772 4773 4774 4775 4776 4777 4778 4779 4780 4781 4782 4783 4784 4785 4786 4787 4788 4789 4790 4791 4792 4793 4794 4795 4796 4797 4798 4799 4800 4801 4802 4803 4804 4805 4806 4807 4808 4809 4810 4811 4812 4813 4814 4815 4816 4817 4818 4819 4820 4821 4822 4823 4824 4825 4826 4827 4828 4829 4830 4831 4832 4833 4834 4835 4836 4837 4838 4839 4840 4841 4842 4843 4844 4845 4846 4847 4848 4849 4850 4851 4852 4853 4854 4855 4856 4857 4858 4859 4860 4861 4862 4863 4864 4865 4866 4867 4868 4869 4870 4871 4872 4873 4874 4875 4876 4877 4878 4879 4880 4881 4882 4883 4884 4885 4886 4887 4888 4889 4890 4891 4892 4893 4894 4895 4896 4897 4898 4899 4900 4901 4902 4903 4904 4905 4906 4907 4908 4909 4910 4911 4912 4913 4914 4915 4916 4917 4918 4919 4920 4921 4922 4923 4924 4925 4926 4927 4928 4929 4930 4931 4932 4933 4934 4935 4936 4937 4938 4939 4940 4941 4942 4943 4944 4945 4946 4947 4948 4949 4950 4951 4952 4953 4954 4955 4956 4957 4958 4959 4960 4961 4962 4963 4964 4965 4966 4967 4968 4969 4970 4971 4972 4973 4974 4975 4976 4977 4978 4979 4980 4981 4982 4983 4984 4985 4986 4987 4988 4989 4990 4991 4992 4993 4994 4995 4996 4997 4998 4999 5000 5001 5002 5003 5004 5005 5006 5007 5008 5009 5010 5011 5012 5013 5014 5015 5016 5017 5018 5019 5020 5021 5022 5023 5024 5025 5026 5027 5028 5029 5030 5031 5032 5033 5034 5035 5036 5037 5038 5039 5040 5041 5042 5043 5044 5045 5046 5047 5048 5049 5050 5051 5052 5053 5054 5055 5056 5057 5058 5059 5060 5061 5062 5063 5064 5065 5066 5067 5068 5069 5070 5071 5072 5073 5074 5075 5076 5077 5078 5079 5080 5081 5082 5083 5084 5085 5086 5087 5088 5089 5090 5091 5092 5093 5094 5095 5096 5097 5098 5099 5100 5101 5102 5103 5104 5105 5106 5107 5108 5109 5110 5111 5112 5113 5114 5115 5116 5117 5118 5119 5120 5121 5122 5123 5124 5125 5126 5127 5128 5129 5130 5131 5132 5133 5134 5135 5136 5137 5138 5139 5140 5141 5142 5143 5144 5145 5146 5147 5148 5149 5150 5151 5152 5153 5154 5155 5156 5157 5158 5159 5160 5161 5162 5163 5164 5165 5166 5167 5168 5169 5170 5171 5172 5173 5174 5175 5176 5177 5178 5179 5180 5181 5182 5183 5184 5185 5186 5187 5188 5189 5190 5191 5192 5193 5194 5195 5196 5197 5198 5199 5200 5201 5202 5203 5204 5205 5206 5207 5208 5209 5210 5211 5212 5213 5214 5215 5216 5217 5218 5219 5220 5221 5222 5223 5224 5225 5226 5227 5228 5229 5230 5231 5232 5233 5234 5235 5236 5237 5238 5239 5240 5241 5242 5243 5244 5245 5246 5247 5248 5249 5250 5251 5252 5253 5254 5255 5256 5257 5258 5259 5260 5261 5262 5263 5264 5265 5266 5267 5268 5269 5270 5271 5272 5273 5274 5275 5276 5277 5278 5279 5280 5281 5282 5283 5284 5285 5286 5287 5288 5289 5290 5291 5292 5293 5294 5295 5296 5297 5298 5299 5300 5301 5302 5303 5304 5305 5306 5307 5308 5309 5310 5311 5312 5313 5314 5315 5316 5317 5318 5319 5320 5321 5322 5323 5324 5325 5326 5327 5328 5329 5330 5331 5332 5333 5334 5335 5336 5337 5338 5339 5340 5341 5342 5343 5344 5345 5346 5347 5348 5349 5350 5351 5352 5353 5354 5355 5356 5357 5358 5359 5360 5361 5362 5363 5364 5365 5366 5367 5368 5369 5370 5371 5372 5373 5374 5375 5376 5377 5378 5379 5380 5381 5382 5383 5384 5385 5386 5387 5388 5389 5390 5391 5392 5393 5394 5395 5396 5397 5398 5399 5400 5401 5402 5403 5404 5405 5406 5407 5408 5409 5410 5411 5412 5413 5414 5415 5416 5417 5418 5419 5420 5421 5422 5423 5424 5425 5426 5427 5428 5429 5430 5431 5432 5433 5434 5435 5436 5437 5438 5439 5440 5441 5442 5443 5444 5445 5446 5447 5448 5449 5450 5451 5452 5453 5454 5455 5456 5457 5458 5459 5460 5461 5462 5463 5464 5465 5466 5467 5468 5469 5470 5471 5472 5473 5474 5475 5476 5477 5478 5479 5480 5481 5482 5483 5484 5485 5486 5487 5488 5489 5490 5491 5492 5493 5494 5495 5496 5497 5498 5499 5500 5501 5502 5503 5504 5505 5506 5507 5508 5509 5510 5511 5512 5513 5514 5515 5516 5517 5518 5519 5520 5521 5522 5523 5524 5525 5526 5527 5528 5529 5530 5531 5532 5533 5534 5535 5536 5537 5538 5539 5540 5541 5542 5543 5544 5545 5546 5547 5548 5549 5550 5551 5552 5553 5554 5555 5556 5557 5558 5559 5560 5561 5562 5563 5564 5565 5566 5567 5568 5569 5570 5571 5572 5573 5574 5575 5576 5577 5578 5579 5580 5581 5582 5583 5584 5585 5586 5587 5588 5589 5590 5591 5592 5593 5594 5595 5596 5597 5598 5599 5600 5601 5602 5603 5604 5605 5606 5607 5608 5609 5610 5611 5612 5613 5614 5615 5616 5617 5618 5619 5620 5621 5622 5623 5624 5625 5626 5627 5628 5629 5630 5631 5632 5633 5634 5635 5636 5637 5638 5639 5640 5641 5642 5643 5644 5645 5646 5647 5648 5649 5650 5651 5652 5653 5654 5655 5656 5657 5658 5659 5660 5661 5662 5663 5664 5665 5666 5667 5668 5669 5670 5671 5672 5673 5674 5675 5676 5677 5678 5679 5680 5681 5682 5683 5684 5685 5686 5687 5688 5689 5690 5691 5692 5693 5694 5695 5696 5697 5698 5699 5700 5701 5702 5703 5704 5705 5706 5707 5708 5709 5710 5711 5712 5713 5714 5715 5716 5717 5718 5719 5720 5721 5722 5723 5724 5725 5726 5727 5728 5729 5730 5731 5732 5733 5734 5735 5736 5737 5738 5739 5740 5741 5742 5743 5744 5745 5746 5747 5748 5749 5750 5751 5752 5753 5754 5755 5756 5757 5758 5759 5760 5761 5762 5763 5764 5765 5766 5767 5768 5769 5770 5771 5772 5773 5774 5775 5776 5777 5778 5779 5780 5781 5782 5783 5784 5785 5786 5787 5788 5789 5790 5791 5792 5793 5794 5795 5796 5797 5798 5799 5800 5801 5802 5803 5804 5805 5806 5807 5808 5809 5810 5811 5812 5813 5814 5815 5816 5817 5818 5819 5820 5821 5822 5823 5824 5825 5826 5827 5828 5829 5830 5831 5832 5833 5834 5835 5836 5837 5838 5839 5840 5841 5842 5843 5844 5845 5846 5847 5848 5849 5850 5851 5852 5853 5854 5855 5856 5857 5858 5859 5860 5861 5862 5863 5864 5865 5866 5867 5868 5869 5870 5871 5872 5873 5874 5875 5876 5877 5878 5879 5880 5881 5882 5883 5884 5885 5886 5887 5888 5889 5890 5891 5892 5893 5894 5895 5896 5897 5898 5899 5900 5901 5902 5903 5904 5905 5906 5907 5908 5909 5910 5911 5912 5913 5914 5915 5916 5917 5918 5919 5920 5921 5922 5923 5924 5925 5926 5927 5928 5929 5930 5931 5932 5933 5934 5935 5936 5937 5938 5939 5940 5941 5942 5943 5944 5945 5946 5947 5948 5949 5950 5951 5952 5953 5954 5955 5956 5957 5958 5959 5960 5961 5962 5963 5964 5965 5966 5967 5968 5969 5970 5971 5972 5973 5974 5975 5976 5977 5978 5979 5980 5981 5982 5983 5984 5985 5986 5987 5988 5989 5990 5991 5992 5993 5994 5995 5996 5997 5998 5999 6000 6001 6002 6003 6004 6005 6006 6007 6008 6009 6010 6011 6012 6013 6014 6015 6016 6017 6018 6019 6020 6021 6022 6023 6024 6025 6026 6027 6028 6029 6030 6031 6032 6033 6034 6035 6036 6037 6038 6039 6040 6041 6042 6043 6044 6045 6046 6047 6048 6049 6050 6051 6052 6053 6054 6055 6056 6057 6058 6059 6060 6061 6062 6063 6064 6065 6066 6067 6068 6069 6070 6071 6072 6073 6074 6075 6076 6077 6078 6079 6080 6081 6082 6083 6084 6085 6086 6087 6088 6089 6090 6091 6092 6093 6094 6095 6096 6097 6098 6099 6100 6101 6102 6103 6104 6105 6106 6107 6108 6109 6110 6111 6112 6113 6114 6115 6116 6117 6118 6119 6120 6121 6122 6123 6124 6125 6126 6127 6128 6129 6130 6131 6132 6133 6134 6135 6136 6137 6138 6139 6140 6141 6142 6143 6144 6145 6146 6147 6148 6149 6150 6151 6152 6153 6154 6155 6156 6157 6158 6159 6160 6161 6162 6163 6164 6165 6166 6167 6168 6169 6170 6171 6172 6173 6174 6175 6176 6177 6178 6179 6180 6181 6182 6183 6184 6185 6186 6187 6188 6189 6190 6191 6192 6193 6194 6195 6196 6197 6198 6199 6200 6201 6202 6203 6204 6205 6206 6207 6208 6209 6210 6211 6212 6213 6214 6215 6216 6217 6218 6219 6220 6221 6222 6223 6224 6225 6226 6227 6228 6229 6230 6231 6232 6233 6234 6235 6236 6237 6238 6239 6240 6241 6242 6243 6244 6245 6246 6247 6248 6249 6250 6251 6252 6253 6254 6255 6256 6257 6258 6259 6260 6261 6262 6263 6264 6265 6266 6267 6268 6269 6270 6271 6272 6273 6274 6275 6276 6277 6278 6279 6280 6281 6282 6283 6284 6285 6286 6287 6288 6289 6290 6291 6292 6293 6294 6295 6296 6297 6298 6299 6300 6301 6302 6303 6304 6305 6306 6307 6308 6309 6310 6311 6312 6313 6314 6315 6316 6317 6318 6319 6320 6321 6322 6323 6324 6325 6326 6327 6328 6329 6330 6331 6332 6333 6334 6335 6336 6337 6338 6339 6340 6341 6342 6343 6344 6345 6346 6347 6348 6349 6350 6351 6352 6353 6354 6355 6356 6357 6358 6359 6360 6361 6362 6363 6364 6365 6366 6367 6368 6369 6370 6371 6372 6373 6374 6375 6376 6377 6378 6379 6380 6381 6382 6383 6384 6385 6386 6387 6388 6389 6390 6391 6392 6393 6394 6395 6396 6397 6398 6399 6400 6401 6402 6403 6404 6405 6406 6407 6408 6409 6410 6411 6412 6413 6414 6415 6416 6417 6418 6419 6420 6421 6422 6423 6424 6425 6426 6427 6428 6429 6430 6431 6432 6433 6434 6435 6436 6437 6438 6439 6440 6441 6442 6443 6444 6445 6446 6447 6448 6449 6450 6451 6452 6453 6454 6455 6456 6457 6458 6459 6460 6461 6462 6463 6464 6465 6466 6467 6468 6469 6470 6471 6472 6473 6474 6475 6476 6477 6478 6479 6480 6481 6482 6483 6484 6485 6486 6487 6488 6489 6490 6491 6492 6493 6494 6495 6496 6497 6498 6499 6500 6501 6502 6503 6504 6505 6506 6507 6508 6509 6510 6511 6512 6513 6514 6515 6516 6517 6518 6519 6520 6521 6522 6523 6524 6525 6526 6527 6528 6529 6530 6531 6532 6533 6534 6535 6536 6537 6538 6539 6540 6541 6542 6543 6544 6545 6546 6547 6548 6549 6550 6551 6552 6553 6554 6555 6556 6557 6558 6559 6560 6561 6562 6563 6564 6565 6566 6567 6568 6569 6570 6571 6572 6573 6574 6575 6576 6577 6578 6579 6580 6581 6582 6583 6584 6585 6586 6587 6588 6589 6590 6591 6592 6593 6594 6595 6596 6597 6598 6599 6600 6601 6602 6603 6604 6605 6606 6607 6608 6609 6610 6611 6612 6613 6614 6615 6616 6617 6618 6619 6620 6621 6622 6623 6624 6625 6626 6627 6628 6629 6630 6631 6632 6633 6634 6635 6636 6637 6638 6639 6640 6641 6642 6643 6644 6645 6646 6647 6648 6649 6650 6651 6652 6653 6654 6655 6656 6657 6658 6659 6660 6661 6662 6663 6664 6665 6666 6667 6668 6669 6670 6671 6672 6673 6674 6675 6676 6677 6678 6679 6680 6681 6682 6683 6684 6685 6686 6687 6688 6689 6690 6691 6692 6693 6694 6695 6696 6697 6698 6699 6700 6701 6702 6703 6704 6705 6706 6707 6708 6709 6710 6711 6712 6713 6714 6715 6716 6717 6718 6719 6720 6721 6722 6723 6724 6725 6726 6727 6728 6729 6730 6731 6732 6733 6734 6735 6736 6737 6738 6739 6740 6741 6742 6743 6744 6745 6746 6747 6748 6749 6750 6751 6752 6753 6754 6755 6756 6757 6758 6759 6760 6761 6762 6763 6764 6765 6766 6767 6768 6769 6770 6771 6772 6773 6774 6775 6776 6777 6778 6779 6780 6781 6782 6783 6784 6785 6786 6787 6788 6789 6790 6791 6792 6793 6794 6795 6796 6797 6798 6799 6800 6801 6802 6803 6804 6805 6806 6807 6808 6809 6810 6811 6812 6813 6814 6815 6816 6817 6818 6819 6820 6821 6822 6823 6824 6825 6826 6827 6828 6829 6830 6831 6832 6833 6834 6835 6836 6837 6838 6839 6840 6841 6842 6843 6844 6845 6846 6847 6848 6849 6850 6851 6852 6853 6854 6855 6856 6857 6858 6859 6860 6861 6862 6863 6864 6865 6866 6867 6868 6869 6870 6871 6872 6873 6874 6875 6876 6877 6878 6879 6880 6881 6882 6883 6884 6885 6886 6887 6888 6889 6890 6891 6892 6893 6894 6895 6896 6897 6898 6899 6900 6901 6902 6903 6904 6905 6906 6907 6908 6909 6910 6911 6912 6913 6914 6915 6916 6917 6918 6919 6920 6921 6922 6923 6924 6925 6926 6927 6928 6929 6930 6931 6932 6933 6934 6935 6936 6937 6938 6939 6940 6941 6942 6943 6944 6945 6946 6947 6948 6949 6950 6951 6952 6953 6954 6955 6956 6957 6958 6959 6960 6961 6962 6963 6964 6965 6966 6967 6968 6969 6970 6971 6972 6973 6974 6975 6976 6977 6978 6979 6980 6981 6982 6983 6984 6985 6986 6987 6988 6989 6990 6991 6992 6993 6994 6995 6996 6997 6998 6999 7000 7001 7002 7003 7004 7005 7006 7007 7008 7009 7010 7011 7012 7013 7014 7015 7016 7017 7018 7019 7020 7021 7022 7023 7024 7025 7026 7027 7028 7029 7030 7031 7032 7033 7034 7035 7036 7037 7038 7039 7040 7041 7042 7043 7044 7045 7046 7047 7048 7049 7050 7051 7052 7053 7054 7055 7056 7057 7058 7059 7060 7061 7062 7063 7064 7065 7066 7067 7068 7069 7070 7071 7072 7073 7074 7075 7076 7077 7078 7079 7080 7081 7082 7083 7084 7085 7086 7087 7088 7089 7090 7091 7092 7093 7094 7095 7096 7097 7098 7099 7100 7101 7102 7103 7104 7105 7106 7107 7108 7109 7110 7111 7112 7113 7114 7115 7116 7117 7118 7119 7120 7121 7122 7123 7124 7125 7126 7127 7128 7129 7130 7131 7132 7133 7134 7135 7136 7137 7138 7139 7140 7141 7142 7143 7144 7145 7146 7147 7148 7149 7150 7151 7152 7153 7154 7155 7156 7157 7158 7159 7160 7161 7162 7163 7164 7165 7166 7167 7168 7169 7170 7171 7172 7173 7174 7175 7176 7177 7178 7179 7180 7181 7182 7183 7184 7185 7186 7187 7188 7189 7190 7191 7192 7193 7194 7195 7196 7197 7198 7199 7200 7201 7202 7203 7204 7205 7206 7207 7208 7209 7210 7211 7212 7213 7214 7215 7216 7217 7218 7219 7220 7221 7222 7223 7224 7225 7226 7227 7228 7229 7230 7231 7232 7233 7234 7235 7236 7237 7238 7239 7240 7241 7242 7243 7244 7245 7246 7247 7248 7249 7250 7251 7252 7253 7254 7255 7256 7257 7258 7259 7260 7261 7262 7263 7264 7265 7266 7267 7268 7269 7270 7271 7272 7273 7274 7275 7276 7277 7278 7279 7280 7281 7282 7283 7284 7285 7286 7287 7288 7289 7290 7291 7292 7293 7294 7295 7296 7297 7298 7299 7300 7301 7302 7303 7304 7305 7306 7307 7308 7309 7310 7311 7312 7313 7314 7315 7316 7317 7318 7319 7320 7321 7322 7323 7324 7325 7326 7327 7328 7329 7330 7331 7332 7333 7334 7335 7336 7337 7338 7339 7340 7341 7342 7343 7344 7345 7346 7347 7348 7349 7350 7351 7352 7353 7354 7355 7356 7357 7358 7359 7360 7361 7362 7363 7364 7365 7366 7367 7368 7369 7370 7371 7372 7373 7374 7375 7376 7377 7378 7379 7380 7381 7382 7383 7384 7385 7386 7387 7388 7389 7390 7391 7392 7393 7394 7395 7396 7397 7398 7399 7400 7401 7402 7403 7404 7405 7406 7407 7408 7409 7410 7411 7412 7413 7414 7415 7416 7417 7418 7419 7420 7421 7422 7423 7424 7425 7426 7427 7428 7429 7430 7431 7432 7433 7434 7435 7436 7437 7438 7439 7440 7441 7442 7443 7444 7445 7446 7447 7448 7449 7450 7451 7452 7453 7454 7455 7456 7457 7458 7459 7460 7461 7462 7463 7464 7465 7466 7467 7468 7469 7470 7471 7472 7473 7474 7475 7476 7477 7478 7479 7480 7481 7482 7483 7484 7485 7486 7487 7488 7489 7490 7491 7492 7493 7494 7495 7496 7497 7498 7499 7500 7501 7502 7503 7504 7505 7506 7507 7508 7509 7510 7511 7512 7513 7514 7515 7516 7517 7518 7519 7520 7521 7522 7523 7524 7525 7526 7527 7528 7529 7530 7531 7532 7533 7534 7535 7536 7537 7538 7539 7540 7541 7542 7543 7544 7545 7546 7547 7548 7549 7550 7551 7552 7553 7554 7555 7556 7557 7558 7559 7560 7561 7562 7563 7564 7565 7566 7567 7568 7569 7570 7571 7572 7573 7574 7575 7576 7577 7578 7579 7580 7581 7582 7583 7584 7585 7586 7587 7588 7589 7590 7591 7592 7593 7594 7595 7596 7597 7598 7599 7600 7601 7602 7603 7604 7605 7606 7607 7608 7609 7610 7611 7612 7613 7614 7615 7616 7617 7618 7619 7620 7621 7622 7623 7624 7625 7626 7627 7628 7629 7630 7631 7632 7633 7634 7635 7636 7637 7638 7639 7640 7641 7642 7643 7644 7645 7646 7647 7648 7649 7650 7651 7652 7653 7654 7655 7656 7657 7658 7659 7660 7661 7662 7663 7664 7665 7666 7667 7668 7669 7670 7671 7672 7673 7674 7675 7676 7677 7678 7679 7680 7681 7682 7683 7684 7685 7686 7687 7688 7689 7690 7691 7692 7693 7694 7695 7696 7697 7698 7699 7700 7701 7702 7703 7704 7705 7706 7707 7708 7709 7710 7711 7712 7713 7714 7715 7716 7717 7718 7719 7720 7721 7722 7723 7724 7725 7726 7727 7728 7729 7730 7731 7732 7733 7734 7735 7736 7737 7738 7739 7740 7741 7742 7743 7744 7745 7746 7747 7748 7749 7750 7751 7752 7753 7754 7755 7756 7757 7758 7759 7760 7761 7762 7763 7764 7765 7766 7767 7768 7769 7770 7771 7772 7773 7774 7775 7776 7777 7778 7779 7780 7781 7782 7783 7784 7785 7786 7787 7788 7789 7790 7791 7792 7793 7794 7795 7796 7797 7798 7799 7800 7801 7802 7803 7804 7805 7806 7807 7808 7809 7810 7811 7812 7813 7814 7815 7816 7817 7818 7819 7820 7821 7822 7823 7824 7825 7826 7827 7828 7829 7830 7831 7832 7833 7834 7835 7836 7837 7838 7839 7840 7841 7842 7843 7844 7845 7846 7847 7848 7849 7850 7851 7852 7853 7854 7855 7856 7857 7858 7859 7860 7861 7862 7863 7864 7865 7866 7867 7868 7869 7870 7871 7872 7873 7874 7875 7876 7877 7878 7879 7880 7881 7882 7883 7884 7885 7886 7887 7888 7889 7890 7891 7892 7893 7894 7895 7896 7897 7898 7899 7900 7901 7902 7903 7904 7905 7906 7907 7908 7909 7910 7911 7912 7913 7914 7915 7916 7917 7918 7919 7920 7921 7922 7923 7924 7925 7926 7927 7928 7929 7930 7931 7932 7933 7934 7935 7936 7937 7938 7939 7940 7941 7942 7943 7944 7945 7946 7947 7948 7949 7950 7951 7952 7953 7954 7955 7956 7957 7958 7959 7960 7961 7962 7963 7964 7965 7966 7967 7968 7969 7970 7971 7972 7973 7974 7975 7976 7977 7978 7979 7980 7981 7982 7983 7984 7985 7986 7987 7988 7989 7990 7991 7992 7993 7994 7995 7996 7997 7998 7999 8000 8001 8002 8003 8004 8005 8006 8007 8008 8009 8010 8011 8012 8013 8014 8015 8016 8017 8018 8019 8020 8021 8022 8023 8024 8025 8026 8027 8028 8029 8030 8031 8032 8033 8034 8035 8036 8037 8038 8039 8040 8041 8042 8043 8044 8045 8046 8047 8048 8049 8050 8051 8052 8053 8054 8055 8056 8057 8058 8059 8060 8061 8062 8063 8064 8065 8066 8067 8068 8069 8070 8071 8072 8073 8074 8075 8076 8077 8078 8079 8080 8081 8082 8083 8084 8085 8086 8087 8088 8089 8090 8091 8092 8093 8094 8095 8096 8097 8098 8099 8100 8101 8102 8103 8104 8105 8106 8107 8108 8109 8110 8111 8112 8113 8114 8115 8116 8117 8118 8119 8120 8121 8122 8123 8124 8125 8126 8127 8128 8129 8130 8131 8132 8133 8134 8135 8136 8137 8138 8139 8140 8141 8142 8143 8144 8145 8146 8147 8148 8149 8150 8151 8152 8153 8154 8155 8156 8157 8158 8159 8160 8161 8162 8163 8164 8165 8166 8167 8168 8169 8170 8171 8172 8173 8174 8175 8176 8177 8178 8179 8180 8181 8182 8183 8184 8185 8186 8187 8188 8189 8190 8191 8192 8193 8194 8195 8196 8197 8198 8199 8200 8201 8202 8203 8204 8205 8206 8207 8208 8209 8210 8211 8212 8213 8214 8215 8216 8217 8218 8219 8220 8221 8222 8223 8224 8225 8226 8227 8228 8229 8230 8231 8232 8233 8234 8235 8236 8237 8238 8239 8240 8241 8242 8243 8244 8245 8246 8247 8248 8249 8250 8251 8252 8253 8254 8255 8256 8257 8258 8259 8260 8261 8262 8263 8264 8265 8266 8267 8268 8269 8270 8271 8272 8273 8274 8275 8276 8277 8278 8279 8280 8281 8282 8283 8284 8285 8286 8287 8288 8289 8290 8291 8292 8293 8294 8295 8296 8297 8298 8299 8300 8301 8302 8303 8304 8305 8306 8307 8308 8309 8310 8311 8312 8313 8314 8315 8316 8317 8318 8319 8320 8321 8322 8323 8324 8325 8326 8327 8328 8329 8330 8331 8332 8333 8334 8335 8336 8337 8338 8339 8340 8341 8342 8343 8344 8345 8346 8347 8348 8349 8350 8351 8352 8353 8354 8355 8356 8357 8358 8359 8360 8361 8362 8363 8364 8365 8366 8367 8368 8369 8370 8371 8372 8373 8374 8375 8376 8377 8378 8379 8380 8381 8382 8383 8384 8385 8386 8387 8388 8389 8390 8391 8392 8393 8394 8395 8396 8397 8398 8399 8400 8401 8402 8403 8404 8405 8406 8407 8408 8409 8410 8411 8412 8413 8414 8415 8416 8417 8418 8419 8420 8421 8422 8423 8424 8425 8426 8427 8428 8429 8430 8431 8432 8433 8434 8435 8436 8437 8438 8439 8440 8441 8442 8443 8444 8445 8446 8447 8448 8449 8450 8451 8452 8453 8454 8455 8456 8457 8458 8459 8460 8461 8462 8463 8464 8465 8466 8467 8468 8469 8470 8471 8472 8473 8474 8475 8476 8477 8478 8479 8480 8481 8482 8483 8484 8485 8486 8487 8488 8489 8490 8491 8492 8493 8494 8495 8496 8497 8498 8499 8500 8501 8502 8503 8504 8505 8506 8507 8508 8509 8510 8511 8512 8513 8514 8515 8516 8517 8518 8519 8520 8521 8522 8523 8524 8525 8526 8527 8528 8529 8530 8531 8532 8533 8534 8535 8536 8537 8538 8539 8540 8541 8542 8543 8544 8545 8546 8547 8548 8549 8550 8551 8552 8553 8554 8555 8556 8557 8558 8559 8560 8561 8562 8563 8564 8565 8566 8567 8568 8569 8570 8571 8572 8573 8574 8575 8576 8577 8578 8579 8580 8581 8582 8583 8584 8585 8586 8587 8588 8589 8590 8591 8592 8593 8594 8595 8596 8597 8598 8599 8600 8601 8602 8603 8604 8605 8606 8607 8608 8609 8610 8611 8612 8613 8614 8615 8616 8617 8618 8619 8620 8621 8622 8623 8624 8625 8626 8627 8628 8629 8630 8631 8632 8633 8634 8635 8636 8637 8638 8639 8640 8641 8642 8643 8644 8645 8646 8647 8648 8649 8650 8651 8652 8653 8654 8655 8656 8657 8658 8659 8660 8661 8662 8663 8664 8665 8666 8667 8668 8669 8670 8671 8672 8673 8674 8675 8676 8677 8678 8679 8680 8681 8682 8683 8684 8685 8686 8687 8688 8689 8690 8691 8692 8693 8694 8695 8696 8697 8698 8699 8700 8701 8702 8703 8704 8705 8706 8707 8708 8709 8710 8711 8712 8713 8714 8715 8716 8717 8718 8719 8720 8721 8722 8723 8724 8725 8726 8727 8728 8729 8730 8731 8732 8733 8734 8735 8736 8737 8738 8739 8740 8741 8742 8743 8744 8745 8746 8747 8748 8749 8750 8751 8752 8753 8754 8755 8756 8757 8758 8759 8760 8761 8762 8763 8764 8765 8766 8767 8768 8769 8770 8771 8772 8773 8774 8775 8776 8777 8778 8779 8780 8781 8782 8783 8784 8785 8786 8787 8788 8789 8790 8791 8792 8793 8794 8795 8796 8797 8798 8799 8800 8801 8802 8803 8804 8805 8806 8807 8808 8809 8810 8811 8812 8813 8814 8815 8816 8817 8818 8819 8820 8821 8822 8823 8824 8825 8826 8827 8828 8829 8830 8831 8832 8833 8834 8835 8836 8837 8838 8839 8840 8841 8842 8843 8844 8845 8846 8847 8848 8849 8850 8851 8852 8853 8854 8855 8856 8857 8858 8859 8860 8861 8862 8863 8864 8865 8866 8867 8868 8869 8870 8871 8872 8873 8874 8875 8876 8877 8878 8879 8880 8881 8882 8883 8884 8885 8886 8887 8888 8889 8890 8891 8892 8893 8894 8895 8896 8897 8898 8899 8900 8901 8902 8903 8904 8905 8906 8907 8908 8909 8910 8911 8912 8913 8914 8915 8916 8917 8918 8919 8920 8921 8922 8923 8924 8925 8926 8927 8928 8929 8930 8931 8932 8933 8934 8935 8936 8937 8938 8939 8940 8941 8942 8943 8944 8945 8946 8947 8948 8949 8950 8951 8952 8953 8954 8955 8956 8957 8958 8959 8960 8961 8962 8963 8964 8965 8966 8967 8968 8969 8970 8971 8972 8973 8974 8975 8976 8977 8978 8979 8980 8981 8982 8983 8984 8985 8986 8987 8988 8989 8990 8991 8992 8993 8994 8995 8996 8997 8998 8999 9000 9001 9002 9003 9004 9005 9006 9007 9008 9009 9010 9011 9012 9013 9014 9015 9016 9017 9018 9019 9020 9021 9022 9023 9024 9025 9026 9027 9028 9029 9030 9031 9032 9033 9034 9035 9036 9037 9038 9039 9040 9041 9042 9043 9044 9045 9046 9047 9048 9049 9050 9051 9052 9053 9054 9055 9056 9057 9058 9059 9060 9061 9062 9063 9064 9065 9066 9067 9068 9069 9070 9071 9072 9073 9074 9075 9076 9077 9078 9079 9080 9081 9082 9083 9084 9085 9086 9087 9088 9089 9090 9091 9092 9093 9094 9095 9096 9097 9098 9099 9100 9101 9102 9103 9104 9105 9106 9107 9108 9109 9110 9111 9112 9113 9114 9115 9116 9117 9118 9119 9120 9121 9122 9123 9124 9125 9126 9127 9128 9129 9130 9131 9132 9133 9134 9135 9136 9137 9138 9139 9140 9141 9142 9143 9144 9145 9146 9147 9148 9149 9150 9151 9152 9153 9154 9155 9156 9157 9158 9159 9160 9161 9162 9163 9164 9165 9166 9167 9168 9169 9170 9171 9172 9173 9174 9175 9176 9177 9178 9179 9180 9181 9182 9183 9184 9185 9186 9187 9188 9189 9190 9191 9192 9193 9194 9195 9196 9197 9198 9199 9200 9201 9202 9203 9204 9205 9206 9207 9208 9209 9210 9211 9212 9213 9214 9215 9216 9217 9218 9219 9220 9221 9222 9223 9224 9225 9226 9227 9228 9229 9230 9231 9232 9233 9234 9235 9236 9237 9238 9239 9240 9241 9242 9243 9244 9245 9246 9247 9248 9249 9250 9251 9252 9253 9254 9255 9256 9257 9258 9259 9260 9261 9262 9263 9264 9265 9266 9267 9268 9269 9270 9271 9272 9273 9274 9275 9276 9277 9278 9279 9280 9281 9282 9283 9284 9285 9286 9287 9288 9289 9290 9291 9292 9293 9294 9295 9296 9297 9298 9299 9300 9301 9302 9303 9304 9305 9306 9307 9308 9309 9310 9311 9312 9313 9314 9315 9316 9317 9318 9319 9320 9321 9322 9323 9324 9325 9326 9327 9328 9329 9330 9331 9332 9333 9334 9335 9336 9337 9338 9339 9340 9341 9342 9343 9344 9345 9346 9347 9348 9349 9350 9351 9352 9353 9354 9355 9356 9357 9358 9359 9360 9361 9362 9363 9364 9365 9366 9367 9368 9369 9370 9371 9372 9373 9374 9375 9376 9377 9378 9379 9380 9381 9382 9383 9384 9385 9386 9387 9388 9389 9390 9391 9392 9393 9394 9395 9396 9397 9398 9399 9400 9401 9402 9403 9404 9405 9406 9407 9408 9409 9410 9411 9412 9413 9414 9415 9416 9417 9418 9419 9420 9421 9422 9423 9424 9425 9426 9427 9428 9429 9430 9431 9432 9433 9434 9435 9436 9437 9438 9439 9440 9441 9442 9443 9444 9445 9446 9447 9448 9449 9450 9451 9452 9453 9454 9455 9456 9457 9458 9459 9460 9461 9462 9463 9464 9465 9466 9467 9468 9469 9470 9471 9472 9473 9474 9475 9476 9477 9478 9479 9480 9481 9482 9483 9484 9485 9486 9487 9488 9489 9490 9491 9492 9493 9494 9495 9496 9497 9498 9499 9500 9501 9502 9503 9504 9505 9506 9507 9508 9509 9510 9511 9512 9513 9514 9515 9516 9517 9518 9519 9520 9521 9522 9523 9524 9525 9526 9527 9528 9529 9530 9531 9532 9533 9534 9535 9536 9537 9538 9539 9540 9541 9542 9543 9544 9545 9546 9547 9548 9549 9550 9551 9552 9553 9554 9555 9556 9557 9558 9559 9560 9561 9562 9563 9564 9565 9566 9567 9568 9569 9570 9571 9572 9573 9574 9575 9576 9577 9578 9579 9580 9581 9582 9583 9584 9585 9586 9587 9588 9589 9590 9591 9592 9593 9594 9595 9596 9597 9598 9599 9600 9601 9602 9603 9604 9605 9606 9607 9608 9609 9610 9611 9612 9613 9614 9615 9616 9617 9618 9619 9620 9621 9622 9623 9624 9625 9626 9627 9628 9629 9630 9631 9632 9633 9634 9635 9636 9637 9638 9639 9640 9641 9642 9643 9644 9645 9646 9647 9648 9649 9650 9651 9652 9653 9654 9655 9656 9657 9658 9659 9660 9661 9662 9663 9664 9665 9666 9667 9668 9669 9670 9671 9672 9673 9674 9675 9676 9677 9678 9679 9680 9681 9682 9683 9684 9685 9686 9687 9688 9689 9690 9691 9692 9693 9694 9695 9696 9697 9698 9699 9700 9701 9702 9703 9704 9705 9706 9707 9708 9709 9710 9711 9712 9713 9714 9715 9716 9717 9718 9719 9720 9721 9722 9723 9724 9725 9726 9727 9728 9729 9730 9731 9732 9733 9734 9735 9736 9737 9738 9739 9740 9741 9742 9743 9744 9745 9746 9747 9748 9749 9750 9751 9752 9753 9754 9755 9756 9757 9758 9759 9760 9761 9762 9763 9764 9765 9766 9767 9768 9769 9770 9771 9772 9773 9774 9775 9776 9777 9778 9779 9780 9781 9782 9783 9784 9785 9786 9787 9788 9789 9790 9791 9792 9793 9794 9795 9796 9797 9798 9799 9800 9801 9802 9803 9804 9805 9806 9807 9808 9809 9810 9811 9812 9813 9814 9815 9816 9817 9818 9819 9820 9821 9822 9823 9824 9825 9826 9827 9828 9829 9830 9831 9832 9833 9834 9835 9836 9837 9838 9839 9840 9841 9842 9843 9844 9845 9846 9847 9848 9849 9850 9851 9852 9853 9854 9855 9856 9857 9858 9859 9860 9861 9862 9863 9864 9865 9866 9867 9868 9869 9870 9871 9872 9873 9874 9875 9876 9877 9878 9879 9880 9881 9882 9883 9884 9885 9886 9887 9888 9889 9890 9891 9892 9893 9894 9895 9896 9897 9898 9899 9900 9901 9902 9903 9904 9905 9906 9907 9908 9909 9910 9911 9912 9913 9914 9915 9916 9917 9918 9919 9920 9921 9922 9923 9924 9925 9926 9927 9928 9929 9930 9931 9932 9933 9934 9935 9936 9937 9938 9939 9940 9941 9942 9943 9944 9945 9946 9947 9948 9949 9950 9951 9952 9953 9954 9955 9956 9957 9958 9959 9960 9961 9962 9963 9964 9965 9966 9967 9968 9969 9970 9971 9972 9973 9974 9975 9976 9977 9978 9979 9980 9981 9982 9983 9984 9985 9986 9987 9988 9989 9990 9991 9992 9993 9994 9995 9996 9997 9998 9999 10000 10001 10002 10003 10004 10005 10006 10007 10008 10009 10010 10011 10012 10013 10014 10015 10016 10017 10018 10019 10020 10021 10022 10023 10024 10025 10026 10027 10028 10029 10030 10031 10032 10033 10034 10035 10036 10037 10038 10039 10040 10041 10042 10043 10044 10045 10046 10047 10048 10049 10050 10051 10052 10053 10054 10055 10056 10057 10058 10059 10060 10061 10062 10063 10064 10065 10066 10067 10068 10069 10070 10071 10072 10073 10074 10075 10076 10077 10078 10079 10080 10081 10082 10083 10084 10085 10086 10087 10088 10089 10090 10091 10092 10093 10094 10095 10096 10097 10098 10099 10100 10101 10102 10103 10104 10105 10106 10107 10108 10109 10110 10111 10112 10113 10114 10115 10116 10117 10118 10119 10120 10121 10122 10123 10124 10125 10126 10127 10128 10129 10130 10131 10132 10133 10134 10135 10136 10137 10138 10139 10140 10141 10142 10143 10144 10145 10146 10147 10148 10149 10150 10151 10152 10153 10154 10155 10156 10157 10158 10159 10160 10161 10162 10163 10164 10165 10166 10167 10168 10169 10170 10171 10172 10173 10174 10175 10176 10177 10178 10179 10180 10181 10182 10183 10184 1...etc..."


D09:41 22/04/2021 - F12:35 - Chapitre 11 - p.167/259 FR 243/376 EN
-------------------------------------------------------------------------------------------------------22/04/2021 fin



-------------------------------------------------------------------------------------------------------23/04/2021 debut
D09:17 23/04/2021 - F - Chapitre 11 - p.167/259 FR 243/376 EN
D09:17 23/04/2021 - F12:59 - Chapitre 11 - p.169/259 FR 247/376 EN

09:30 23/04/2021
* Équivalent au test 2
Playground (CTRL+O+W) >
[ | temp | temp := String new. (1 to: 100000) do: [:i | temp := temp, i asString, ' ' ] ]	(CTRL+P) > "[ | temp |
													temp := String new.
													(1 to: 100000) do: [ :i | temp := temp , i asString , ' ' ] ]"
timeToRun											(CTRL+P) > Unmatched " in comment. ->

* Ci-dessous les codes ne fonctionne pas sous Playground et Transcript.

[| temp |
temp := String new.
(1 to: 100000) do: [:i | temp := temp, i asString, ' ' ] ] timeToRun


[| temp | temp := WriteStream on: String new.
(1 to: 100000) do: [:i | temp nextPutAll: i asString; space ]. temp contents ] 
timeToRun


10:28 23/04/2021
Recherche : 
-----------

do: [:i
[:i

Des blocs. Les crochets [] définissent un bloc, également appelé fermeture de bloc ou fermeture lexicale, 
qui est un objet de première classe représentant une fonction. 
Comme nous le verrons, les blocs peuvent prendre des arguments ( [: i | ...] ) et peuvent avoir des variables locales.


Hasard : Le second code fonctionne
--------

* Qu'est-ce qui n'est pas cohérent par rapport aux codes précédents ?
	1. Le début du code commence par l'ouverture d'un crochet,
	2. L'ouverture du crochet n'a pas d'espace après le "pipe de temp",
	3. Après "new." vient la suite du code,
	4. Après "]." vient la suite du code avec un crochet en fermeture,
	5. Le crochet après "contents" a un espace contrairement à celui du début,
	 
[| temp | temp := WriteStream on: String new. (1 to: 100000) do: [:i | temp nextPutAll: i asString; space ]. temp contents ]timeToRun "0:00:00:00.048"

* Crochets espacés oui et non
[| temp | temp := WriteStream on: String new. (1 to: 100000) do: [:i | temp nextPutAll: i asString; space ]. temp contents]timeToRun "0:00:00:00.048"

* Crochets espacés oui et non
[ | temp | temp := WriteStream on: String new. (1 to: 100000) do: [:i | temp nextPutAll: i asString; space ]. temp contents ]timeToRun "0:00:00:00.048"

* Crochets espacés
[ | temp | temp := WriteStream on: String new. (1 to: 100000) do: [ :i | temp nextPutAll: i asString; space ]. temp contents ]timeToRun "0:00:00:00.048"

* Crochets sans espace
[| temp | temp := WriteStream on: String new. (1 to: 100000) do: [:i | temp nextPutAll: i asString; space]. temp contents]timeToRun "0:00:00:00.048"



----------------------------------------------------------------Suite TEST DEBUT
11 test
Playground (CTRL+O+W) >
[| temp | temp := String new. (1 to: 100000) do: [:i | temp := temp, i asString, ' ']]timeToRun 	(CTRL+P) > Pharo ne répond plus.
 
12 test
[| temp | temp := String new. (1 to: 100000) do: [:i | temp nextPutAll: i asString; '']] timeToRun	(CTRL+P) > Pharo ne répond plus.

13 test
[| temp | temp := String new. (1 to: 100000) do: [:i | temp := temp, i asString, ' ']] timeToRun	(CTRL+P) > Pharo ne répond plus.

14 test
[| temp | temp := String new. (1 to: 10) do: [:i | temp := temp, i asString, ' ']] timeToRun		(CTRL+P) > "0:00:00:00"

* Ajout d'un zéro (1 to: 100).
15 test
[| temp | temp := String new. (1 to: 100) do: [:i | temp := temp, i asString, ' ']] timeToRun		(CTRL+P) > "0:00:00:00"

16 test
[| temp | temp := String new. (1 to: 1000) do: [:i | temp := temp, i asString, ' ']] timeToRun		(CTRL+P) > "0:00:00:00.005"

17 test
[| temp | temp := String new. (1 to: 10000) do: [:i | temp := temp, i asString, ' ']] timeToRun		(CTRL+P) > "0:00:00:00.53"

18 test
[| temp | temp := String new. (1 to: 100000) do: [:i | temp := temp, i asString, ' ']] timeToRun	(CTRL+P) > 11:19 -> Pharo ne répond plus -> 11:26 (5 mns) 

* Je n'ai pas pu copier le résultat, alors j'ai dû retirer et remettre un zéro afin d'avoir de nouveau une réponse.
19 test
[| temp | temp := String new. (1 to: 100000) do: [:i | temp := temp, i asString, ' ']] timeToRun	(CTRL+P) > "0:00:05:11.761"


----------------------------------------------------------------Suite TEST FIN


Code : 
------

* p. 244 EN - Streams - Les codes des lignes 2 et 3 ci-dessous fonctionnent, mais pas le 1er.

* D'après ce que je comprends, le premier code peut être lu, mais difficilement, car il copie le récepteur "en boucle" 
  et il est préférable d'utiliser un flux plutôt que la concaténation de chaînes.

* Étant donné que les objets son soi-disant vivant et le décryptage du document inquiétant cela auraient été bien qu'il y est une fenêtre
"vivante" pour apprécier visuellement le parcours du code.
Prenez-en de la graine avec le programme Scratch, car les éléments, les blocs, le code sont parcourus étapes par étapes.
Le code est plus vivant sous Scratch que sous Pharo.

1.
[| temp | temp := String new. (1 to: 100000) do: [:i | temp := temp, i asString, '']] timeToRun

2.
String streamContents: [:tempStream | (1 to: 100000) do: [:i | tempStream nextPutAll: i asString; space]]

3.
[| temp | temp := WriteStream on: String new. (1 to: 100000) do: [:i | temp nextPutAll: i asString; space]. temp contents] timeToRun


Tableau : Mise à jour 10:49 23/04/2021
---------

12:21 23/04/2021
* Création du package : PBE-Stream
* Pour FirstnameLastname mettre LObjetVivantcoule

* La question se pose : 
	- Après avoir copier/coller les codes jusqu'à "goForward", comment afficher les boutons dans le navigateur ?
	- Comment tester le code ?
	- Étant donné que les objets sont vivants est-ce que je dois m'attendre à ce que Pharo le fasse tout seul ?

* Un exercice qui est encore mal ficellé. 
Peut-on dire qu'il s'agit d'un exercice parce que je n'ai pas l'impression que le lecteur est convié à le faire ?

* "Jusqu'à présent, le code est assez simple."
Il est tellement simple qu'il est impossible de le tester, de s'approprier le contenu.
Cette "simplicité" dépend du point de vue d'une personne.

12:58 23/04/2021
* Très franchement, je n'aurais jamais pensé à créer une classe "History", en passant par le protocole "initialization", puis rattacher sept méthodes avec un code assez simple à la classe "History".
* Ce livret a une pédagogie cool, sans prise de tête, c'est formidable de simplicité.
* C'est tellement simple que je vais arrêter ce livret et aller me cuisiner de "simple" crackers à la tomate.


Code : 
------
09:12 24/04/2021
p.247 code "history new"

History new
goTo: #page1;
goTo: #page2;
goTo: #page3;
goBackward;
goBackward;
goTo: #page4;
contents
>>> #(#page1 #page4 nil nil)


Playground (CTRL+O+W) >
History new		(CTRL+P) > "a History"
goTo: #page1;		(CTRL+P) > Variable or expression expected ->
goTo: #page2;
goTo: #page3;
goBackward;
goBackward;
goTo: #page4;
contents		(CTRL+P) > "nil"

Playground (CTRL+O+W) >
History new goTo: #page1; goTo: #page2; goTo: #page3; goBackward; goBackward; goTo: #page4; contents 	(CTRL+P) > "#(#page1 #page4 nil nil)"

Super, MDR ! 

prochain ... 11.4 Utilisation des flux pour l'accès aux fichiers

D09:17 23/04/2021 - F12:59 - Chapitre 11 - p.169/259 FR 247/376 EN
-------------------------------------------------------------------------------------------------------23/04/2021 fin



-------------------------------------------------------------------------------------------------------24/04/2021 debut
D07:53 24/04/2021 - F - Chapitre 11 - p.169/259 FR 247/376 EN
D07:53 24/04/2021 - F10:22 - Chapitre 11 - p.169/259 FR 247/376 EN

- 10 mns
- 5 mns

Recherche : 
-----------
"web browser" -> p.132 Windows groups - p.278 The Seaside welcome page

La recherche ne donne rien de concret pour permettre l'utilisation des boutons dans le navigateur.

* "Et l'histoire fonctionne comme annoncé:"
*Ça, c'est toi qui le dis, de mon côté je n'ai qu'une pâle "histoire" accompagnée de codes et de figures.

* "Il est également possible de diffuser des fichiers sur votre disque dur."
 - p. 239 EN déjà fait. Le retour chariot n'a pas fonctionné dans le fichier texte. 

StandardFileStream fileNamed: 'test.txt' do: [:str | str nextPutAll: '123'; cr; nextPutAll: 'abcd' ].	(CTRL+P) > "'abcd'"

	flux sur un fichier = flux sur une collection
		créations		
			    |
			protocole
		   /--------|--------\
		lire	  écrire    position


TABLEAU : FILESTREAM
--------

ProtoObject
  Object
    Stream
      PositionableStream
	WriteStream
	 ReadWriteStream
	  FileStream (barré ?)
	    StrandardFileStream (barré ?)
	      MultiByteFileStream (barré ?)
	

11.4 Utilisation des flux pour l'accès aux fichiers
(pa)DeprecatedFileStream-Base
(c)ReadWriteStream
(c)FileStream -> Hier. - Class side - Methods
 	\|/
	 |
Messages de création d'instances
	 |
  	 |----> (m)fileNamed: : Ouvre un fichier avec le nom donné pour la lecture et l'écriture. 
	 |  |			   Si le fichier existe déjà, son contenu antérieur peut être modifié ou remplacé, 
	 |  |			   mais le fichier ne sera pas tronqué à la fermeture. Si le nom ne comporte aucune
	 |  |			   partie de répertoire, le fichier sera créé dans le répertoire par défaut.  
	 |  |<-- (Methods) (pr)instance creation, (pr)deprecated, (pr)overriden - (Vars) Rien
	 |
  	 |----> (m)forceNewFileNamed: : créez un nouveau fichier avec le nom donné et répondez à un flux ouvert 
	 |  |			   pour l'écriture sur ce fichier. Si le fichier existe déjà, 
	 |  |			   supprimez-le sans demander avant de créer le nouveau fichier.
	 |  |<-- (Methods) (pr)instance creation, (pr)deprecated, (pr)overriden - (Vars) Rien
	 |
  	 |----> (m)NewFileNamed: : créez un nouveau fichier avec le nom donné et répondez à un flux ouvert en écriture sur ce fichier.
	 |  |			   Si le fichier existe déjà, demander à l'utilisateur ce qu'il doit faire.			   
	 |  |<-- (Methods) (pr)instance creation, (pr)deprecated, (pr)overriden - (Vars) Rien
	 |
  	 |----> (m)oldFileNamed: : ouvre un fichier existant avec le nom donné pour la lecteur et l'écriture.
	 |  |			   Si le fichier existe déjà, son contenu antérieur peut être mmodifié ou remplacé, 
	 |  |			   mais le fichier ne sera pas tronqué à la fermeture.
	 |  |			   Si le nom n'a pas de partie de répertoire, le fichier sera créé dans le répertoire par défaut.			   
	 |  |<-- (Methods) (pr)instance creation, (pr)deprecated, (pr)overriden - (Vars) Rien
	 |
  	 |----> (m)readOnlyFileNamed: : ouvre un fichier existant avec le nom donné pour la lecteur.
	 |  |<-- (Methods) (pr)instance creation, (pr)deprecated, (pr)overriden - (Vars) Rien
	 |
  	 |----> (m)fullName : accéder au nom du chemin d'accès complet. 
	 |  |<-- (Methods) (pr)instance creation, (pr)deprecated - (Vars) Rien


(c)FileStream -> Hier. - Inst. side - Methods (création de fichier)
 	\|/
	 |
  	 |----> (m)close : chaque fois que vous ouvrez un flux sur un fichier, vous devez ensuite le fermer. 
	 |  |<-- (Methods) (pr)open/close, (pr)deprecated, (pr)abstract, (pr)overriden, (pr)overrides - (Vars) Rien
	 |
  	 |----> (m)localName : répond au dernier composant du nom du fichier. 
	 |  |<-- (Methods) (pr)accessing, (pr)deprecated, (pr)overriden, (pr)overrides - (Vars) Rien
	 |
  	 |----> (m)fullName : * Il faut repasser côté classe. C'est ce qui s'appelle avoir le cul entre deux chaises.



À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------
"Vous devez vous rappeler que chaque fois que vous ouvrez un flux sur un fichier, 
vous avez pour le fermer aussi. Cela se fait via le message =close défini dans FileStream."
p. 248 EN " you have to close it too."


Notes :
------

* Décalage : Manque de concordance, de correspondance.
11.4 Using streams for file access - Creating file streams
- Le code "History new" est placé au milieu de nulle part, c'est quoi cette histoire ?
- Alors que j'ai le nez dans la méthode "fileNamed:" de la classe "FileStream".	

* Le livret indique une description de "FileNamed:" qui n'est pas disponible dans la méthode contrairement à celle de "forceNewFileNamed:".	

* Le petit plus cela aurait été de mettre les messages de création d'instances par ordre alphabétique. 
(remarques faites plusieurs fois précédemment)
Pourtant le programme Pharo et le volet "méthode" est simple et vivant.


Code : 
------

| stream |
stream := FileStream forceNewFileNamed: 'test.txt'.
stream
nextPutAll: 'This text is written in a file named ';
print: stream localName.
stream close.
stream := FileStream readOnlyFileNamed: 'test.txt'.
stream contents.

Playground (CTRL+O+W) >
| stream |										(CTRL+P) > "nil"
stream := FileStream forceNewFileNamed: 'test.txt'.					(CTRL+P) > "MultiByteFileStream: 'D:\Liberkeys\MyApps\Pharo\test.txt'"
stream nextPutAll: 'This text is written in a file named '; print: stream localName. 	(CTRL+P) > "MultiByteFileStream: 'D:\Liberkeys\MyApps\Pharo\test.txt'"
stream close.				 						(CTRL+P) > "MultiByteFileStream: 'D:\Liberkeys\MyApps\Pharo\test.txt'"
stream := FileStream readOnlyFileNamed: 'test.txt'.					(CTRL+P) > "MultiByteFileStream: 'D:\Liberkeys\MyApps\Pharo\test.txt'"
stream contents.									(CTRL+P) >  "'This text is written in a file named ''test.txt'''"

stream close.

* Ajout de "stream close.", car le fichier est utilisé par le programme Pharo et impossible de le supprimer.


D07:53 24/04/2021 - F10:22 - Chapitre 11 - p.169/259 FR 247/376 EN
-------------------------------------------------------------------------------------------------------24/04/2021 fin



-------------------------------------------------------------------------------------------------------25/04/2021 debut
D11:51 25/04/2021 - F - Chapitre 11 - p.169/259 FR 247/376 EN
D11:51 25/04/2021 - F16:44 - Chapitre 11 - p.172/259 FR 251/376 EN

- 36 mns

* Comme je l'ai indiqué précédemment "ou est-il enregistré ce fichier texte ?" suite au court (p. 239 EN - 11.3 Streaming over collections).
Du coup, l'exercice 

Rappel :
--------
10.7 Collection - 10.8 Présentation (p. 145 FR - 213 EN)
"Les classes de collection forment un groupe vaguement défini de sous-classes générales de Collection et Stream.
Beaucoup d'entre eux (comme Bitmap, FileStream et CompiledMethod) sont des classes à usage spécial 
conçu pour être utilisé dans d'autres parties du système ou dans des applications, 
et ne sont donc pas classés comme Collection par l'organisation du système. 
Aux fins de ce chapitre, nous utilisons le terme Hiérarchie des collections pour désigner Collection 
et ses sous-classes qui se trouvent également dans les packages intitulés Collections-*. 
Nous utilisons le terme hiérarchie de flux pour signifier Stream et ses sous-classes qui se trouvent 
également dans les packages Collections-Streams.

* J'aime bien le "vaguement défini de sous-classes", ce qui implique que tu t'infliges quelque chose de vaguement défini en globalité et qui te prend la tête.
C'est cool Pharo.


* Je ne comprends pas la réponse ""MultiByteFileStream: 'D:\Liberkeys\MyApps\Pharo\test.txt'" étant donné que le code
indique le nom du fichier "'test.txt'" à créer, la méthode de création "forceNewFileNamed:", 
la classe employée "FileStream" et enfin la variable "Stream" ?
Donc, qu'est-ce qu'elle vient faire là cette classe "MultiByteFileStream", 
mais n'étant pas sur que cela soit une classe étant donné les deux points "MultiByteFileStream:" ?

C'est le vrai méli-mélo.


Code : 
------

Playground (CTRL+O+W) >
| stream |
stream := FileStream forceNewFileNamed: 'test.txt'.	(CTRL+P) > "MultiByteFileStream: 'D:\Liberkeys\MyApps\Pharo\test.txt'"
stream
nextPutAll: 'This text is written in a file named ';
print: stream localName.
stream close.
stream := FileStream readOnlyFileNamed: 'test.txt'.
stream contents.


Hiérarchie classe :  FileStream
--------------------
(c)ProtoObject
(c)  Object
(c)   Stream
(c)    PositionableStream
(c)	WriteStream
(c)	 ReadWriteStream
(c)	   FileStream
(c)	     StandardFileStream
(c)	      MultiByteFileStream


Décomposition du code : Recherche de "MultiByteFileStream:"
-----------------------

stream := FileStream forceNewFileNamed: 'test.txt'.	(CTRL+P) > "MultiByteFileStream: 'D:\Liberkeys\MyApps\Pharo\test.txt'"


Fichier texte ->	'text.txt'
		 	|
Class side - Vars ->	(m)forceNewFileNamed: : créez un nouveau fichier avec le nom donné et répondez à un flux ouvert 
	 	 	|  			pour l'écriture sur ce fichier. Si le fichier existe déjà, 
	 	 	|			supprimez-le sans demander avant de créer le nouveau fichier."
			| -> code : forceNewFileNamed: fileName
			| 		"Create a new file with the given name, and answer a stream opened for writing on that file. If the file already exists, delete it without asking before creating the new file."
			|
			|		SessionManager default currentSession isReadOnlyAccessMode ifTrue: [ ((CannotDeleteFileException fileName: fileName)
			|		messageText: 'Could not delete the old version of file ' , fileName) signal.
			|		^ NullStream new ].
			|
			|		^self concreteStream forceNewFileNamed: fileName
			|				\|/
			|------------------------------- |
			|			MultiByteFileStream:
			|				\|/
			|				NON
			|
Hier. - Class side -	(c)FileStream
Vars			| -> code : FileStream class
			|		instanceVariableNames: ''
			|				\|/
			|------------------------------- |
			|			MultiByteFileStream:
			|				\|/
			|				NON
Hier. - Inst. side -	(c)FileStream
Vars			| -> code : ReadWriteStream subclass: #FileStream
			|		instanceVariableNames: ''
			|		classVariableNames: 'Stderr Stdin StdioFiles Stdout TheStdioHandles'
			|		package: 'DeprecatedFileStream-Base'
			|				\|/
			|------------------------------- |
			|			MultiByteFileStream:
			|				\|/
			|				NON
			|	
Variable 		stream : Playground -> stream -> CTRL+M -> Implementors of stream (19)
			|				\|/
			|------------------------------- |
			|			MultiByteFileStream:
			|				\|/
			|				NON


MULTIBYTESFILESTREAM :
---------------------

Hier. - Class side -	(c)MultiByteFileStream
Vars			| -> code : MultiByteFileStream class
			|		instanceVariableNames: ''
			|				\|/
			|------------------------------- |
			|			(m)forceNewFileNamed:, (c)FileStream, stream
			|				\|/
			|				NON
			|
Hier. - Class side -	(c)MultiByteFileStream : (m)forceNewFileNamed: (?)
Vars			|				\|/
			|------------------------------- |
			|			(m)forceNewFileNamed:
			|				\|/
			|				NON
			|
Flat - Inst. side -	(c)MultiByteFileStream
Vars			| -> code : StandardFileStream subclass: #MultiByteFileStream
			|		instanceVariableNames: 'converter lineEndConvention wantsLineEndConversion'
			|		classVariableNames: 'Cr CrLf Lf LineEndDefault LineEndStrings LookAheadCount'
			|		package: 'DeprecatedFileStream-Base'
			|				\|/
			|------------------------------- |
			|			(m)forceNewFileNamed:, (c)FileStream, stream
			|				\|/
			|				NON
			|
Flat - Inst. side -	(c)MultiByteFileStream : (m)forceNewFileNamed: (?)
Vars			|				\|/
			|------------------------------- |
			|			(m)forceNewFileNamed:
			|				\|/
			|				NON
			|

Constat : 
---------
Pour résumer les schémas ci-dessus, je m'aperçois qu'une simple création d'un fichier texte utilise trois éléments visuels.
Mais c'est une surprise de taille, puisque le résultat est surprenant et me conduit à penser que ce programme peut tout sans que je sache ce qu'il fait.
Je ne sais pas du tout ce qui est interrogé, peut-être un code, des méthodes, une classe, des packages, des variables et j'en passe.

Il passe par où, il fait quoi, je ne sais pas.

	* "L'avantage de ceci est que vous voyez la méthode que vous écrivez car elle sera exécutée, 
		avec des paramètres réels dans le contexte d'exécution réel."

	* "Les variables globales sont accessibles partout. Chaque classe est nommée par une variable globale."

	* "La pratique recommandée est de limiter strictement l'utilisation de variables globales."

Tel un chapeau d'un magicien, il en ressort un résultat à la grande surprise générale.
À mon avis, Pharo n'est pas le symbole d'un phare, mais plutôt d'une "vague" qu'on souhaiterait maîtriser, 
mais qu'en fin de compte on est totalement berné, bercé. (Bercer : Tromper (qqn) par des apparences séduisantes, nourrir d’espérances vaines.)


Code : 
------

Version courte : 
----------------
StandardFileStream fileNamed: 'test.txt' do: [:str | str nextPutAll: 'This text is written in a file named'].

Version longue :
----------------
| stream |
stream := FileStream forceNewFileNamed: 'test.txt'.
stream
nextPutAll: 'This text is written in a file named ';
print: stream localName.
stream close.
stream := FileStream readOnlyFileNamed: 'test.txt'.
stream contents.
>>> 'This text is written in a file named ''test.txt'''
stream close.

"Les méthodes de création de flux qui prennent un bloc comme argument créent d'abord un flux sur un fichier, 
puis exécutent le bloc avec le flux comme argument, et enfin ferment le flux. 
Ces méthodes retournent ce qui est renvoyé par le bloc, c'est-à-dire la valeur de la dernière expression du bloc. 
Ceci est utilisé dans l'exemple précédent pour obtenir le contenu du fichier et le mettre dans la variable chaîne."


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------
Lorsque votre flux est en mode binaire, vous ne pouvez écrire que des nombres de 0 à 255 (1 octet). 
Si vous voulez utiliser nextPutAll: pour écrire plus d'un nombre à la fois, vous devez passer un ByteArray comme argument.


* La programmation est simple, mais ce sont les humains qui la compliquent.


Code : 
------

Playground (CTRL+O+W) >
FileStream forceNewFileNamed: 'test.bin' do: [ :stream | stream binary; nextPutAll: #(145 250 139 98) asByteArray ].	(CTRL+P) > "#[145 250 139 98]"
(0145=‘, 0250=ú, 0139=‹, 098=b)

'145' asArray collect: [ :ea | ea asciiValue ]		(CTRL+P) > "#(49 52 53)" - 49=1, 52=4, 53=5
'250' asArray collect: [ :ea | ea asciiValue ]		(CTRL+P) > 
'139' asArray collect: [ :ea | ea asciiValue ]		(CTRL+P) > 
'98' asArray collect: [ :ea | ea asciiValue ]		(CTRL+P) >


 * Est-ce que les caractères contenus dans "test.bin" ont un sens ? (‘ú‹b)-(145 250 139 98)


'bonjour' asArray collect: [ :ea | ea asciiValue ] "#(98 111 110 106 111 117 114)" 
FileStream forceNewFileNamed: 'test.bin' do: [ :stream | stream binary; nextPutAll: #(98 111 110 106 111 117 114) asByteArray ].


Code copier/coller du livret vers Playground : 
----------------------------------------------
FileStream
readOnlyFileNamed: 'test.bin'
do: [ :stream |
stream binary.
stream size.
>>> 4
stream next.
>>> 145
stream upToEnd.
>>> #[250 139 98 ]
].

Code modifié dans Playground : 
------------------------------

FileStream readOnlyFileNamed: 'test.bin' do: [ :stream | stream binary. stream size. stream next. stream upToEnd.  ].


1.
FileStream readOnlyFileNamed: 'test.bin' do: [ :stream | stream binary. stream size. stream next. stream upToEnd.  ].   "#[250 139 98]"
								       |-> (CTRL+P) > ---------------------------------/|\
2.
FileStream readOnlyFileNamed: 'test.bin' do: [ :stream | stream binary. stream size. stream next. stream upToEnd.  ].   "#[250 139 98]"
								       		    |-> (CTRL+P) > --------------------/|\
3.
FileStream readOnlyFileNamed: 'test.bin' do: [ :stream | stream binary. stream size. stream next. stream upToEnd.  ].   "#[250 139 98]"
								       		    		 |-> (CTRL+P) > -------/|\
4.
FileStream readOnlyFileNamed: 'test.bin' do: [ :stream | stream binary. stream size. stream next. stream upToEnd.  ].		  "#[250 139 98]"
								       		    		 		 |-> (CTRL+P) > -/|\
5.
FileStream readOnlyFileNamed: 'test.bin' do: [ :stream | stream binary. stream size. stream next. stream upToEnd.  ].		     "#[250 139 98]"
								       		    		 		    |-> (CTRL+P) > -/|\
6. Rapprochement du dernier crochet vers le point.
FileStream readOnlyFileNamed: 'test.bin' do: [ :stream | stream binary. stream size. stream next. stream upToEnd. ].	(CTRL+P) > "#[250 139 98]"

7. RDCVPoint.
FileStream readOnlyFileNamed: 'test.bin' do: [ :stream | stream binary. stream size. stream next. stream upToEnd.].	(CTRL+P) > "#[250 139 98]"

8. Rapprochement du premier crochet.
FileStream readOnlyFileNamed: 'test.bin' do: [:stream | stream binary. stream size. stream next. stream upToEnd.].	(CTRL+P) > "#[250 139 98]"

9. Rapprochement du pipe.
FileStream readOnlyFileNamed: 'test.bin' do: [:stream|stream binary. stream size. stream next. stream upToEnd.].	(CTRL+P) > "#[250 139 98]"

10. Rapprochement du test.
FileStream readOnlyFileNamed:'test.bin' do: [:stream|stream binary. stream size. stream next. stream upToEnd.].		(CTRL+P) > "#[250 139 98]"

11. Rapprochement du do.
FileStream readOnlyFileNamed:'test.bin'do: [:stream|stream binary. stream size. stream next. stream upToEnd.].		(CTRL+P) > "#[250 139 98]"

12. Rapprochement du :[.
FileStream readOnlyFileNamed:'test.bin'do:[:stream|stream binary. stream size. stream next. stream upToEnd.].		(CTRL+P) > "#[250 139 98]"

13. Rapprochement du premier point du bloc. -------------------\|/
FileStream readOnlyFileNamed:'test.bin'do:[:stream|stream binary.stream size. stream next. stream upToEnd.].		(CTRL+P) > "#[250 139 98]"

14. Rapprochement du second point du bloc.
FileStream readOnlyFileNamed:'test.bin'do:[:stream|stream binary.stream size.stream next. stream upToEnd.].		(CTRL+P) > "#[250 139 98]"

15. Rapprochement du troisième point du bloc.
FileStream readOnlyFileNamed:'test.bin'do:[:stream|stream binary.stream size.stream next.stream upToEnd.].		(CTRL+P) > "#[250 139 98]"


* Au final, je n'ai pas du tout les mêmes réponses intermédiaires "stream size. >>> 4 stream next.>>> 145".
 - Ce sera mis sur le compte d'une nouvelle version de Pharo.


Code copier/coller du livret vers Playground : 
----------------------------------------------
FileStream
forceNewFileNamed: 'test.pgm'
do: [ :stream |
stream
nextPutAll: 'P5'; cr;
nextPutAll: '4 4'; cr;
nextPutAll: '255'; cr;
binary;
nextPutAll: #(255 0 255 0) asByteArray;
nextPutAll: #(0 255 0 255) asByteArray;
nextPutAll: #(255 0 255 0) asByteArray;
nextPutAll: #(0 255 0 255) asByteArray ]


Code modifié dans Playground : 
------------------------------

FileStream forceNewFileNamed: 'test.pgm' do: [ :stream | stream nextPutAll: 'P5'; cr; nextPutAll: '4 4'; cr; nextPutAll: '255'; cr; binary; nextPutAll: #(255 0 255 0) asByteArray; nextPutAll: #(0 255 0 255) asByteArray; nextPutAll: #(255 0 255 0) asByteArray; nextPutAll: #(0 255 0 255) asByteArray ] (CTRL+P) > "#[0 255 0 255]"

* "Si vous voulez utiliser nextPutAll: pour écrire plus d'un nombre à la fois, vous devez passer un ByteArray comme argument."
	- Un "asByteArray" plus précisément, car ce n'est pas un "a ByteArray", ni un "an ByteArray" mais "asByteArray".

* Pourquoi forcer la création d'un fichier alors que la classe "NewFileNamed:", peut créer simplement un fichier ?
Si cela avait été plus simple, mais malheureusement "NewFileNamed:" n'aime pas le "do:".
Alors qu'il est arrivé qu'une classe ne possède pas la méthode, mais va la chercher dans une autre classe.
Donc, encore une fois les interactions ne sont pas claires.
En fin de compte, en plus de décoder l'anglais et les corrélations, il va falloir passer son temps à lire chaque description des méthodes afin de "connaître" sa tâche. 

FileStream NewFileNamed: 'test.jpg' do: [ :stream | stream nextPutAll: 'P5'; cr; nextPutAll: '4 4'; cr; nextPutAll: '255'; cr; binary; nextPutAll: #(255 0 255 0) asByteArray; nextPutAll: #(0 255 0 255) asByteArray; nextPutAll: #(255 0 255 0) asByteArray; nextPutAll: #(0 255 0 255) asByteArray ]
(CTRL+P) > Instance of FileStream class did not understand #NewFileNamed:do:


FileStream forceNewFileNamed: 'test.pgm' do: [ :stream | stream nextPutAll: 'P5'; cr; nextPutAll: '4 4'; cr; nextPutAll: '255'; cr; binary; nextPutAll: #(255 0 255 0) asByteArray; nextPutAll: #(0 255 0 255) asByteArray; nextPutAll: #(255 0 255 0) asByteArray; nextPutAll: #(0 255 0 255) asByteArray ] (CTRL+P) > "#[0 255 0 255]"

* Je suis curieux, et j'aimerais savoir comment vous avez eu une qualité d'image correspondant à la "Figure 11-24" ?
Parce que sous LibreOffice -> Dessin Draw ou d'autres extensions de fichiers, l'image est petite et la qualité très en dessous de la Figure 11-24.

Répertoire de D:\Liberkeys\MyApps\Pharo
25/04/2021  16:09                27 test.bmp
25/04/2021  16:14                27 test.cr2
25/04/2021  16:14                27 test.crw
25/04/2021  16:11                27 test.cur
25/04/2021  16:14                27 test.dng
25/04/2021  16:13                27 test.eps
25/04/2021  16:11                27 test.gif
25/04/2021  16:11                27 test.ico
25/04/2021  16:12                27 test.jpe
25/04/2021  16:12                27 test.jpeg
25/04/2021  16:08                27 test.jpg
25/04/2021  16:14                27 test.mnw
25/04/2021  16:12                27 test.pcx
25/04/2021  16:10                27 test.pgm
25/04/2021  16:12                27 test.png
25/04/2021  16:12                27 test.ppm
25/04/2021  16:12                27 test.psd
25/04/2021  16:13                27 test.tag
25/04/2021  16:13                27 test.tif
25/04/2021  16:13                27 test.tiff
25/04/2021  16:13                27 test.wmf 

* La description du code est "^super" expéditif.
 - P5 : Ca correspond à quoi ?

 - Comment agrandir l'image avec votre code si simple ?
 * Je pensais qu'en modifiant "P5" ou "#(0 255 0 255)" en "#(20 255 20 255)" cela agrandirait l'image, mais en fin de compte non. :-(

11.5 Résumé du chapitre
"Il existe des moyens simples de convertir entre les flux et les collections."

Faire des crackers à la tomate est plus simple.

En lisant le résumé du chapitre, je ne me rappelle même plus de ce que j'ai pu faire précédemment à part le dernier code.

Prochain chapter 12 morphic - morphique


D11:51 25/04/2021 - F16:44 - Chapitre 11 - p.172/259 FR 251/376 EN
-------------------------------------------------------------------------------------------------------25/04/2021 fin




-------------------------------------------------------------------------------------------------------26/04/2021 debut
D12:23 26/04/2021 - F - Chapitre 12 - p.172/259 FR 251/376 EN
D12:23 26/04/2021 - F15:55 - Chapitre 12 - p.174/259 FR 255/376 EN

Tous les objets vue à l'écran lors de l'exécution de Pharo sont des morphs.
	
	instances
		sous-clases -------------implémente un comportement avec peu de code -> ?
			classes (c)Morph						  
				protocole						 
					methode (m)asMorph

Incohérence : 
-------------
Encore une fois, le "listing" est avant la présentation, malgré qu'il y est indiqué "execute the following code in a Playground.".

Désordre : 
------------
"Listing 12-3 Creation of a String Morph"
'Morph' asMorph openInWorld"

To create a morph to represent a string object, execute the following code in a Playground.

Cohérence : 
---------
To create a morph to represent a string object, execute the following code in a Playground.

"Listing 12-3 Creation of a String Morph"
'Morph' asMorph openInWorld"


Code : 
------

Créer un "Morph" pour représenter un objet chaîne. Affiche le mot "Morph" dans "World" de Pharo.

Playground (CTRL+O+W) >	
		'Morph' asMorph openInWorld			(CTRL+P) > "a StringMorph(761557248)'Morph'"
		'Pharo c'est l'horreur' asMorph openInWorld	(CTRL+P) > End of statement list encountered ->
		'Pharocestlhorreur' asMorph openInWorld		(CTRL+P) > "a StringMorph(151378688)'Pharocestlhorreur'" 
		'Pharo_c_est_l_horreur' asMorph openInWorld 	(CTRL+P) > "a StringMorph(886831360)'Pharo_c_est_l_horreur'"
		"Pharo c'est l'horreur" asMorph openInWorld	(CTRL+P) > #asMorph is missing, and does not understand #openInWorld


* Après avoir créé "Morph", comment l'enlever avec simplicité ?

"Color tan asMorph renvoie un StringMorph étiqueté avec le résultat de Color tan printString".

Playground (CTRL+O+W) >	
		Color tan asMorph				(CTRL+P) > "a StringMorph(436407296)'Color tan'"


* La classe "Color" utilise la méthode "asMorph" située dans la classe "Morph".

Playground (CTRL+O+W) >
		Color >> asMorph 
		^ Morph new color: self 			(CTRL+P) > "a Morph(207339008)"


* Le mot "Color orange" (la forme de chaîne) s'affiche au lieu d'un carré orange ? MDR !

Playground (CTRL+O+W) >
		Color orange asMorph openInWorld		(CTRL+P) > "a StringMorph(240243968)'Color orange'"

* Rappel : 
----------
p.83 FR 118 EN - "nous voyons que les classes Morph et EllipseMorph implémentent toutes deux defaultColor.
En ouvrant un "Morph new openInWorld", nous obtenons un morph bleu alors qu'une ellipse sera jaune.

Playground (CTRL+O+W) >
			joe := Morph new color: Color blue.	(CTRL+P) > "a Morph(218660864)"
			joe openInWorld.			(CTRL+P) > "a Morph(218660864)" // Un carré bleu est créé
			bill := Morph new color: Color red.	(CTRL+P) > "a Morph(936579328)"
			bill openInWorld.			(CTRL+P) > "a Morph(936579328)" // Un carré rouge est créé


Incohérence : 
-------------
Encore une fois, le "listing" est avant la présentation. (Figure 12-5)

* Toujours aucun carré orange d'affiché. L'objet est vivant et il ne veut pas sortir du chapeau. MDR !

			Color orange asMorph openInWorld	(CTRL+P) > "a StringMorph(119199744)'Color orange'"


"Les morphes sont des objets, nous pouvons donc les manipuler comme n'importe quel autre objet"
Comment supprimer ces objets créés précédemment ? (je ne retrouve plus la commande)
(supprimer les carrés bleus, rouges et ellipse jaune)

Pharo> Windows> Collapse all windows> les carrés vont disparaît pour faire apparaître des onglets en bas de Pharo.
Exécuter un clic droit sur l'onglet (fenêtre) afin d'afficher un menu, sélectionner "Close" pour fermer une fenêtre 
ou "Close all > windows like this pour fermer toutes les fenêtres.


* À part afficher des chiffres, je ne comprends pas l'intérêt.
C'est normal étant donné la manière qu'il présente la progression de l'exercice qui est incompréhensible.

Playground (CTRL+O+W) >
			joe position:(joe position + (10@3))  	(CTRL+P) > "a Morph(176554240)"
			bill position: (joe position + (100@0)) (CTRL+P) > "a Morph(977534208)"



12.2 Manipulating morphs - 12.3 Composing morphs
-------------------------------------------------

* Explication et reprise de l'exercice dans son ensemble.

Création des carrés : 
les lignes de 1 à 4 permettent la création des carrés bleu et rouge.

Bouger les carrés : 
la ligne 5, déplacera le carré bleu attribué à Joe.
ligne 6, déplacera le carré rouge attribué à Bill.

* En répétant (CTRL+P) sur les lignes 5 et 6, cela pourrait devenir une course de carrés.

Agrandir les carrés :
la ligne 7, répond à la taille, (?)
la ligne 8, agrandir le carré bleu de "3",

Change de couleur :
la ligne 9, change la couleur du carré bleu en orange, et en changeant alpha: 0.5 en alpha: 0.1 celui-ci devient transparent.
(valeur maxi 0.9, valeur mini 0.0)

Déplacement en fonction de la position de l'autre carré : 
la ligne 10, fait passer le carré rouge à la droite du bleu,
ligne 11, création d'un rond jaune attribué à "balloon",
ligne 12, ajoute le "balloon" à Joe,
ligne 13, le "balloon" est positionné sur le carré de Joe, (carré dernièrement créé pour Joe)
ligne 14, depuis le carré orange, le rond jaune est centré,

Playground (CTRL+O+W) >
			1. joe := Morph new color: Color blue.		(CTRL+P) >
			2. joe openInWorld.				(CTRL+P) >
			3. bill := Morph new color: Color red.		(CTRL+P) >
			4. bill openInWorld.				(CTRL+P) >
			5. joe position:(joe position + (10@3))		(CTRL+P) > repete 1, repete 2, etc.
			6. bill position: (joe position + (100@0))	(CTRL+P) > repete 1, repete 2, etc.
			7. joe extent.
			8. 3 timesRepeat: [joe extent:(joe extent * 1.1)]
			9. joe color: (Color orange alpha: 0.5).
			10. bill position: (joe position + (100@0))

			11. balloon := BalloonMorph new color: Color yellow.
			12. joe addMorph: balloon.
			13. balloon position: joe position.
			14. balloon center: joe center.			 (CTRL+P) > "a BalloonMorph(398357504)"

-------------

Color orange asMorph openInWorld

joe := Morph new color: Color blue.
joe openInWorld.
bill := Morph new color: Color red.
bill openInWorld.
joe position:(joe position + (10@3))
joe extent.
bill position: (joe position + (100@0)) 
3 timesRepeat: [joe extent:(joe extent * 1.1)]
joe color: (Color orange alpha: 0.5).

balloon := BalloonMorph new color: Color yellow.
joe addMorph: balloon.
balloon position: joe position.

balloon center: joe center.


* Donc, les codes ci-dessus utilisent tout un tas de valeurs, variables, classes, classe miroir, méthodes, protocoles, etc.

self
a Morph 	(c) Morph
bounds 		(c) ---------->	self   		(c)
			|->	origin 		(c)
			|->	corner 		(c)

owner:    	(c) ----------> borderWidth 	(c)	//liste sommaire
			|->	borderColor 	(c)
			|->	backgroundMorph (c)
			|->	worldState	(c)
			|->	griddingOn	(c)
			|->	extension	(c) -> a MorphExtension (c) -> MorphExtension (c)

a WorldMorph 	(c) WorldMorph
submorphs 	(c)
an Array 	(c) Array
fullBounds 	(c)
color 		(c)
Color 		(c)
blue 		(c)
extension	(c)
nil


Classes : 
---------

ProtoObject
  Object
   Morph

ProtoObject
  Object	asMorph

ProtoObject
  Object
   Color



TABLEAU : MORPH / ASMORPH / COLOR
--------

Mise à jour : 13:16 27/04/2021
		13:30 28/04/2021
		11:30 29/04/2021
		11:15 30/04/2021



12.1 The history of Morphic
(pa)Morphic-Core-Kernel
(c)Object -> Inst. side
(c)Morph : Vous pouvez créer un morphing pour représenter n'importe quel objet, bien que la qualité d'une représentation dépend de l'objet !
 	\|/
  	 |----> ()self : self est appelé une "pseudo-variable" car nous ne pouvons pas l'assigner. 
	 |  |<-- (c)self, (v)self
	 |
  	 |----> (m)position : renvoie un point qui décrit l'emplacement du coin supérieur gauche du morph (ou du coin supérieur gauche de sa zone de délimitation). 
	 |  |<-- (Methods) (pr)geometry, (pr)overridden - (Vars) (pr)instance side, (pr)Morph, (pr)bounds 
	 |
  	 |----> (m)extent : aggrandir un morph - changer la taille. 
	 |  |<-- (Methods) (pr)instance side, (pr)geometry, (pr)overridden - (Vars) (pr)instance side, (pr)Morph, (pr)bounds 
	 |
  	 |----> (m)center: : permet de centrer.
	 |  |<-- (Methods) (pr)instance side, (pr)geometry - (Vars) (pr)instance side
	 |
  	 |----> (m)color: : changer la couleur d'un morph.
	 |  |<-- (Methods) (pr)instance side, (pr)accessing, (pr)overridden - (Vars) (pr)Morph, (pr)color, (pr)extension 
	 |
  	 |----> (m)addMorph: : ce message place un morph dans un autre.
	 |  |<-- (Methods) (pr)instance side, (pr)submorphs-add/remove, (pr)overridden - (Vars) (pr)instance side
	 |
  	 |----> (m)height : .
	 |  |<-- (Methods) (pr)instance side, (pr)geometry, (pr)overridden - (Vars) (pr)instance side, (pr)Morph, (pr)bounds
	 |
  	 |----> (m)width : .
	 |  |<-- (Methods) (pr)instance side, (pr)geometry - (Vars) (pr)instance side, (pr)Morph, (pr)bounds
	 |
  	 |----> (m)bounds : .
	 |  |<-- (Methods) (pr)instance side, (pr)geometry, (pr)overridden - (Vars) (pr)Morph, (pr)bounds


* Il y a le code "bounds", le protocole et la méthode sans compter "bound:".


12.1 The history of Morphic
asMorph : Implementors of asMorph (10)
(pa)Kernel-Objects
(c)ProtoObject -> Inst. side
(c)Object
 	\|/
  	 |----> (m)asMorph: : a une implémentation par défaut dans la classe Object qui crée simplement un StringMorph.
	 |  |<-- (Methods) (pr)instance side, (pr)extensions, (pr)overridden - (Vars) (pr)instance side
	 |
  	 |----> (m)asStringMorph: : 
	 |  |<-- (Methods) (pr)instance side, (pr)extensions, (pr)overridden - (Vars) (pr)instance side
	 |



12.1 The history of Morphic
(pa)Colors-Base
(c)Object -> Inst. side
(c)Color
 	\|/
  	 |----> (m)alpha: : 
	 |  |<-- (Methods) (pr)instance side, (pr)extensions, (pr)overridden - (Vars) (pr)instance side
	 |



12.4 Creating and drawing your own morphs
(pa)Graphics-Canvas 
(c)Object
(c)Canvas
 	\|/
  	 |----> (m):fillRectangle:color: : Les rectangles comprennent de nombreux messages qui créent d'autres rectangles de géométrie associée.
	 |  |<-- (Methods) (pr)instance side, (pr)drawing-rectangles, (pr)overridden - (Vars) (pr)instance side
	 |

* Je suppose que le code "(pr)instance side" correspond à "aCanvas fillRectangle: horizontalBar color: self color.".



12.4 Creating and drawing your own morphs
(pa)Kernel-BasicObjects
(c)Object
(c)Rectangle
 	\|/			Implementors of fillRectangle: (2)
  	 |----> (m):insetBy: : ce message avec un point comme argument pour créer d'abord un rectangle de hauteur réduite, 
	 |  |			puis un autre rectangle de largeur réduite.
	 |  |<-- (Methods) (pr)instance side, (pr)rectanble functions - (Vars) (pr)instance side
	 |
  	 |----> (m):areasOutside: : répond à un tableau de rectangles comprenant les parties de r1 en dehors de r2.
	 |  |<-- (Methods) (pr)instance side, (pr)rectanble functions - (Vars) (pr)instance side, (pr)Rectangle, (pr)corner, (pr)origin
	 |
  	 |----> (m):rounded : 
	 |  |<-- (Methods) (pr)instance side, (pr)truncation and round off - (Vars) (pr)instance side, (pr)Rectangle, (pr)corner, (pr)origin



12.4 Creating and drawing your own morphs
(pa)Athens-Balloon-Engine
(c)BalloonEngine
(c)AthensBalloonEngine 
 	\|/			Implementors of fillRectangle: (4)
  	 |----> (m):fillRectangle: : 
	 |  |<-- (Methods) (pr)instance side, (pr)drawing - (Vars) (pr)instance side, (pr)AthensBalloonEngine, (pr)currentFill
	 |

* "fillRectangle" interroge quel "Implementors" ? (fillRectangle: est rattaché à color: donc la méthode "fillRectangle:color:"
est annexé à la classe "Canvas" ou la copie miroir "aCanvas". (classe miroir)




D12:23 26/04/2021 - F15:55 - Chapitre 12 - p.174/259 FR 255/376 EN
-------------------------------------------------------------------------------------------------------26/04/2021 fin




-------------------------------------------------------------------------------------------------------27/04/2021 debut
D13:12 27/04/2021 - F - Chapitre 12 - p.174/259 FR 255/376 EN
D13:12 27/04/2021 - F13:25 - Chapitre 12 - p.175/259 FR 255/376 EN

Mise à jour Morph - addMorph, center - 

D13:12 27/04/2021 - F13:25 - Chapitre 12 - p.175/259 FR 255/376 EN
-------------------------------------------------------------------------------------------------------27/04/2021 fin




-------------------------------------------------------------------------------------------------------28/04/2021 debut
D13:25 28/04/2021 - F - Chapitre 12 - p.175/259 FR 255/376 EN
D13:25 28/04/2021 - F14:12 - Chapitre 12 - p.175/259 FR 255/376 EN

Mise à jour code - TABLEAU : MORPH / ASMORPH / COLOR

"En plus de le faire par programmation, vous pouvez également incorporer des morphes par manipulation directe."
* manipulation directe (?)


Création du package : PBE-Morphic
--------------------

SystemBrowser> Clic droit sur le volet package> New package > 
Fenêtre "Create a new package - Name of the new package : PBE-Morphic - OK

 * Copier le code ci-dessous sur celui qui vient d'être créé. 
	-> onglet New class

Morph subclass: #CrossMorph
instanceVariableNames: ''
classVariableNames: ''
package: 'PBE-Morphic'

(CTRL+S) -> Enregistrement

	-> l'onglet New class prend le nom de -> (c)CrossMorph


Mise à jour commentaire : 
-------------------------

* Ajouter un commentaire : p. 256 EN Listing 12-12 Defi ning CrossMorph
	-> onglet Comment

(CTRL+S) -> Enregistrement


Création de la méthode drawOn: : 
-------------------------------

Copier le code ci-dessous et sélectionner, remplacer le contenu.
	-> onglet Inst. side method

drawOn: aCanvas
| crossHeight crossWidth horizontalBar verticalBar |
crossHeight := self height / 3.0.
crossWidth := self width / 3.0.
horizontalBar := self bounds insetBy: 0 @ crossHeight.
verticalBar := self bounds insetBy: crossWidth @ 0.
aCanvas fillRectangle: horizontalBar color: self color.
aCanvas fillRectangle: verticalBar color: self color

(CTRL+S) -> Enregistrement

	-> onglet dranOn:

14:12 28/04/2021
package 		subclass	instanceVariableNames	classVariableNames	classe		protocole	methode
--------------------------------------------------------------------------------------------------------------------------------
PBE-Morphic Morph 	#CrossMorph	''			''			|-|CrossMorph	instance side	drawOn:
													drawing
													overridden
	
D13:25 28/04/2021 - F14:12 - Chapitre 12 - p.175/259 FR 255/376 EN
-------------------------------------------------------------------------------------------------------28/04/2021 fin




-------------------------------------------------------------------------------------------------------29/04/2021 debut
D10:53 29/04/2021 - F00:00 - Chapitre 12 - p.175/259 FR 255/376 EN
D10:53 29/04/2021 - F13:22 - Chapitre 12 - p.177/259 FR 258/376 EN

- 5 mns
- 10 mns
- 15 mns

12.4
"définir une Sous-classe de Morph et remplacer la méthode drawOn: pour changer son apparence."
	* Le framework morphique envoie le message drawOn: ? framework

	framework morphique -> message -> drawOn: -> morph -> réafficher morph -> écran -> canevas
					    |
					    > Sorte de Canvas


	message -> bounds -> morph -> boîte englobante : rectangle


TABLEAU : MORPH / ASMORPH / COLOR - 11:30 29/04/2021
---------

package 		subclass	instanceVariableNames	classVariableNames	classe		protocole	methode
--------------------------------------------------------------------------------------------------------------------------------
PBE-Morphic 	Morph 	#CrossMorph	''			''			|-|CrossMorph	instance side	drawOn:
													drawing
													overridden
-------------------------------------------------------------------------------------------------------------
Graphics-Canvas Object	#Canvas		''			''			(c)Canvas


Code : 
------

Pour tester votre nouveau morph, exécutez :  CrossMorph new openInWorld.

* Cette commande active la création d'une croix bleue. 
	- Lors du déplacement de la croix, celle-ci est sur fond noir plus visible qu'avec les carrés.

Playground (CTRL+O+W) >
			CrossMorph new openInWorld.	(CTRL+P) > "a CrossMorph(413487104)"


Création de la méthode containsPoint: : 
---------------------------------------

(pa)PBE-Morphic - (c)CrossMorph - (pr)instance side	(m)drawOn:
			   	  (pr)drawing		
			   	  (pr)overrides
				  (pr)instance side	(m)containsPoint:
				  (pr)geometry testing
				  (pr)overrides

Copier le code ci-dessous et sélectionner, remplacer le contenu.
	-> onglet Inst. side method

containsPoint: aPoint
| crossHeight crossWidth horizontalBar verticalBar |
crossHeight := self height / 3.0.
crossWidth := self width / 3.0.
horizontalBar := self bounds insetBy: 0 @ crossHeight.
verticalBar := self bounds insetBy: crossWidth @ 0.
^ (horizontalBar containsPoint: aPoint) or: [ verticalBar
containsPoint: aPoint ]

(CTRL+S) -> Enregistrement

	-> onglet containsPoint:


Code : 
------

Pour tester votre nouveau morph, exécutez :  CrossMorph new openInWorld.

* Cette commande active de nouveau la création d'une croix bleue. 
	- Cela ne ressemble en rien à la figure 12-14.
	
Playground (CTRL+O+W) >
			CrossMorph new openInWorld.	(CTRL+P) > "a CrossMorph(413487104)"
							(CTRL+P) >  "a CrossMorph(238398208)"

C'est une erreur cardinale:" - "qui exprime la quantité, par opposition à l'ordre".

"Le plus évident est que nous avons du code en double. 
C'est une erreur cardinale: si nous constatons que nous devons changer la façon dont horizontalBar ou verticalBar sont calculés,
nous oublierons probablement de changer l'une des deux occurrences. 
La solution est de factoriser ces calculs en deux nouvelles méthodes, que nous mettons dans le protocole privé:".

* A partir du code ci-dessous, trois méthodes sont créés : horizontalBar, verticalBar, aCanvas

drawOn: aCanvas
| crossHeight crossWidth horizontalBar verticalBar |
crossHeight := self height / 3.0.
crossWidth := self width / 3.0.
horizontalBar := self bounds insetBy: 0 @ crossHeight.
verticalBar := self bounds insetBy: crossWidth @ 0.
aCanvas fillRectangle: horizontalBar color: self color.
aCanvas fillRectangle: verticalBar color: self color


Listing 12-16 horizontalBar

CrossMorph >> horizontalBar
| crossHeight |
crossHeight := self height / 3.0.
^ self bounds insetBy: 0 @ crossHeight


Listing 12-17 verticalBar

CrossMorph >> verticalBar
| crossWidth |
crossWidth := self width / 3.0.
^ self bounds insetBy: crossWidth @ 0


Listing 12-18 Refactored CrossMorph >> drawOn:

CrossMorph >> drawOn: aCanvas
aCanvas fillRectangle: self horizontalBar color: self color.
aCanvas fillRectangle: self verticalBar color: self color
				

Playground (CTRL+O+W) >
CrossMorph new openInWorld; bounds: (0@0 corner: 200@200); color: (Color blue alpha: 0.4)	(CTRL+P) >  "a CrossMorph(979100416)"


* J'ai mis le code ci-dessous et Pharo s'est figé :

containsPoint: aPoint
^ (self horizontalBar containsPoint: aPoint) or: [ self
verticalBar containsPoint: aPoint ]


* Le parragraphe "12.4 Creating and drawing your own morphs", les explications sont très bien mais la finalité de l'exercice
est obscure.
Car, il y a un décalage entre les listing et l'exécution.
Puis une execution ligne par ligne qui ne fonctionne pas. ("Execute the following code in a playground, line by line:")
Donc au final, le lecteur doit décrypter le contenu pour connaitre le résultat final.

D10:53 29/04/2021 - F13:22 - Chapitre 12 - p.177/259 FR 258/376 EN
-------------------------------------------------------------------------------------------------------29/04/2021 fin




-------------------------------------------------------------------------------------------------------30/04/2021 debut
D10:57 30/04/2021 - F - Chapitre 12 - p.177/259 FR 258/376 EN
D10:57 30/04/2021 - F13:53 - Chapitre 12 - p.179/259 FR 261/376 EN

- 10 mns
- 13 mns
- 17 mns

Code :
------

Test 1
* Copier/coller des codes ci-dessous afin d'avoir une croix bleue avec un axe bleu simple.

Modifications dans la classe "(c)CrossMorph", des méthodes ci-dessous :
-------------------------------------

horizontalBar
| crossHeight |
crossHeight := self height / 3.0.
^ self bounds insetBy: 0 @ crossHeight

verticalBar
| crossWidth |
crossWidth := self width / 3.0.
^ self bounds insetBy: crossWidth @ 0

drawOn: aCanvas
aCanvas fillRectangle: self horizontalBar color: self color.
aCanvas fillRectangle: self verticalBar color: self color

containsPoint: aPoint
^ (self horizontalBar containsPoint: aPoint) or: [ self
verticalBar containsPoint: aPoint ]

Playground (CTRL+O+W) >
CrossMorph new openInWorld; bounds: (0@0 corner: 200@200); color: (Color blue alpha: 0.4)	(CTRL+P) > 

* La croix bleue est toujours en doublon dans l'axe.


Test 2
* Copier/coller des codes ci-dessous afin d'avoir une croix bleue avec un axe bleu simple.
* De nouveau modification de "drawOn: aCanvas"

* La methode "areasOutside:" permet de ne pas mettre en doublon la couleur bleue dans l'axe de la croix.


Ajouts dans la classe "(c)CrossMorph", des méthodes ci-dessous :
-------------------------------------

drawOn: aCanvas
| topAndBottom |
aCanvas fillRectangle: self horizontalBar color: self color.
topAndBottom := self verticalBar areasOutside: self horizontalBar.
topAndBottom do: [ :each | aCanvas fillRectangle: each color: self
color ]

horizontalBar
| crossHeight |
crossHeight := (self height / 3.0) rounded.
^ self bounds insetBy: 0 @ crossHeight

verticalBar
| crossWidth |
crossWidth := (self width / 3.0) rounded.
^ self bounds insetBy: crossWidth @ 0

Listing 12-22 Utilisez ce code pour afficher un bogue
* Je n'appelle pas ça un bogue, mais un code imparfait et une approche incohérente. (fillRectanble:color:)

Playground (CTRL+O+W) >
CrossMorph new openInWorld; bounds: (0@0 corner: 200@200); color: (Color blue alpha: 0.4)	(CTRL+P) > 

* La croix bleue n'a plus une couleur bleue en doublon dans l'axe.
* Aucun arrondi explicite.

Mise à jour - TABLEAU : MORPH / ASMORPH / COLOR - 11:15 30/04/2021


Notes :
-------
 
* "la taille du rectangle à remplir n'est pas un entier, fillRectangle: color: semble arrondir de manière incohérente, 
laissant une ligne de pixels vide."

"de manière incohérente" n'est que le reflet du code Pharo.

"Nous pouvons contourner ce problème en arrondissant explicitement lorsque nous calculons les tailles des barres."

Le lecteur -> futur programmeur va passer son temps à "contourner" des problèmes !


Mise à jour - TABLEAU : MORPH / ASMORPH / COLOR - 11:40 30/04/2021
* "rounding -> rouded" ?
	- Implementors of rounded (8)
		- (pa)Kernel - (c)Rectangle - truncation and round off - rounded 

* Il se peut que "rounded" interroge toute sorte de choses sans qu'on sache quoi exactement ? (Number, Integer, Point, Rectangle)

12:00 30/04/2021 - 12.5 Interaction and animation
Événements de souris

	Bouton souris actif -> Morphic -> morph -> sous le pointeur -> message -> handlesMouseDown:
			    	     |	        |
			   	    \/	       \/
		       		mouseDown: <-> true
		       		mouseUp:  <->  true

	Bouton souris inactif -> Morphic -> morph -> sous le pointeur -> message -> handlesMouseDown:
			    	      |	       /\
			   	      |	       \/
			|------<-------         |
glisser-déposer - mouseDown:  		   <- false
		  |-> argument			|
		      |-> a MouseEvent object ->|
						|
		  mouseUp: 		   <- false
		  |-> argument			|
		      |-> a MouseEvent object ->|


TABLEAU : MOUSE MORPH - 12.5 Interaction and animation
---------


(pa)Morphic-Core-Kernel
(c)Object -> Inst. side
(c)Morph : Vous pouvez créer un morphing pour représenter n'importe quel objet, bien que la qualité d'une représentation dépend de l'objet !
 	\|/
  	 |----> ()self : self est appelé une "pseudo-variable" car nous ne pouvons pas l'assigner. 
	 |  |<-- (c)self, (v)self
	 |
  	 |----> (m)position : renvoie un point qui décrit l'emplacement du coin supérieur gauche du morph (ou du coin supérieur gauche de sa zone de délimitation). 
	 |  |<-- (Methods) (pr)geometry, (pr)overridden - (Vars) (pr)instance side, (pr)Morph, (pr)bounds 
	 |
  	 |----> (m)extent : aggrandir un morph - changer la taille. 
	 |  |<-- (Methods) (pr)instance side, (pr)geometry, (pr)overridden - (Vars) (pr)instance side, (pr)Morph, (pr)bounds 
	 |
  	 |----> (m)center: : permet de centrer.
	 |  |<-- (Methods) (pr)instance side, (pr)geometry - (Vars) (pr)instance side
	 |
  	 |----> (m)color: : changer la couleur d'un morph.
	 |  |<-- (Methods) (pr)instance side, (pr)accessing, (pr)overridden - (Vars) (pr)Morph, (pr)color, (pr)extension 
	 |
  	 |----> (m)addMorph: : ce message place un morph dans un autre.
	 |  |<-- (Methods) (pr)instance side, (pr)submorphs-add/remove, (pr)overridden - (Vars) (pr)instance side
	 |
  	 |----> (m)height : .
	 |  |<-- (Methods) (pr)instance side, (pr)geometry, (pr)overridden - (Vars) (pr)instance side, (pr)Morph, (pr)bounds
	 |
  	 |----> (m)width : .
	 |  |<-- (Methods) (pr)instance side, (pr)geometry - (Vars) (pr)instance side, (pr)Morph, (pr)bounds
	 |
  	 |----> (m)bounds : .
	 |  |<-- (Methods) (pr)instance side, (pr)geometry, (pr)overridden - (Vars) (pr)Morph, (pr)bounds
	 |
  	 |----> (m)handleKeystroke: : gérer l'évènement du clavier. (Implementors (5) 
	 |  |<-- (Methods) (pr)instance side, (pr)event handling - (Vars) (pr)instance side
	 |
  	 |----> (m)handlesMouseOver: : gérer l'évènement du clavier. (Implementors (22)
	 |  |<-- (Methods) (pr)instance side, (pr)event handling, (pr)overridden - (Vars) (pr)instance side
	 |
(pa)Morphic-Core-Events
(c)UserInputEvent -> Inst. side
(c)MouseEvent
	 |
  	 |----> (m)handlesMouseDown: : Quand un bouton de la souris enfoncé, Morphic envoie chaque morph sous le pointeur 
	 |  |				de la souris le message handlesMouseDown:. Si un morph répond vrai, 
	 |  |				Morphic lui envoie immédiatement le message mouseDown:.
	 |  |<-- (Methods) (pr)instance side, (pr)event handling, (pr)overridden - (Vars) (pr)instance side
	 |
  	 |----> (m)mouseDown: : lorsque le bouton de la souris est enfoncé.
	 |  |<-- (Methods) (pr)instance side, (pr)event handling, (pr)overridden - (Vars) (pr)instance side
	 |
  	 |----> (m)mouseUp: : lorsque l'utilisateur relâche le bouton de la souris.
	 |  |<-- (Methods) (pr)instance side, (pr)event handling, (pr)overridden - (Vars) (pr)instance side


Code : 12.5 Interaction and animation
------


Création de la méthode handlesMouseDown: : Listing 12-26 Déclarant que CrossMorph réagira aux clics de souris
------------------------------------------

Depuis la classe "CrossMorph", 
Copier/coller le code ci-dessous en sélectionnant le contenu présent dans l'onglet "Inst. side method".
	-> onglet Inst. side method

handlesMouseDown: anEvent^ true	

(CTRL+S) -> Enregistrement

	-> onglet handlesMouseDown


Création de la méthode mouseDown: : Listing 12-27 Reacting to mouse clicks by changing the morph’s color
------------------------------------------

Depuis la classe "CrossMorph", 
Copier/coller le code ci-dessous en sélectionnant le contenu présent dans l'onglet "Inst. side method".
	-> onglet Inst. side method

mouseDown: anEvent
anEvent redButtonPressed
ifTrue: [ self color: Color red ]. "click"
anEvent yellowButtonPressed
ifTrue: [ self color: Color yellow ]. "action-click"
self changed

(CTRL+S) -> Enregistrement

	-> onglet mouseDown


Note : 
------

"Notez également qu'une fois que le morphing gère les événements de la souris, vous ne pouvez plus l'attraper avec la souris et le déplacer. 
Au lieu de cela, vous devez utiliser le halo: un méta-clic sur la morph pour faire apparaître le halo et saisir soit la poignée de déplacement brune 
(voir figure  12-28) ou la poignée de ramassage noire (voir figure  12-29) en haut de la morph."

* Notez = Rien de cela.
* Reste à définir ce qui n'est plus possible d'attraper ?

Lorsque j'utilise le clic gauche de la souris sur la croix bleue, celle-ci devient rouge tandis que le droit affiche du jaune, aucun bouton visible.
De plus, les croix ne peuvent plus être déplacées.

Concernant les carrés, la souris peut saisir, mais aucun changement de couleur ou apparitions de boutons.


* anEvent est rattaché à plusieurs autres instances de classes,
	- anEvent = Event = *Event -> renvoie vers (c)MouseEvent	(* d'autres instances de classes)


Mise à jour : 12:06 01/05/2021
methode			argument		classe		sous-classe
(m)mouseDown:		anEvent	-> Event ->	(c)MouseEvent	#MorphicEvent
(m)redButtonPressed	<----------------------------|
(m)yellowButtonPressed	<----------------------------|



* Playground : recherche avec un seul mot.
Playground > 	anEvent ->  	Do it and go (CTRL+G) -> an UndefinedObjetc (nil) 
		#anEvent ->  	Implementors (CTRL+M) -> (?)
		#anEvent -> 	Senders (7) (CTRL+N) -> EventManagerTest
		Event -> 	Print it (CTRL+P) -> choose a class to browse...

* Playground : plusieurs mots sont listés, mais deux sont utilisés pour une recherche.
Playground >	CrossMorph 
		anEvent -> 	Print it (CTRL+M) -> choose a class to browse...
		Event -> 	Print it (CTRL+M) -> (c)MouseEvent
		MouseEvent

* Conclusion : le résultat est différent dans Playground, lorsqu'il y a un seul mot ou une liste de mots.
	
D10:57 30/04/2021 - F13:53 - Chapitre 12 - p.179/259 FR 261/376 EN
-------------------------------------------------------------------------------------------------------30/04/2021 fin




-------------------------------------------------------------------------------------------------------01/05/2021 debut
D12:01 01/05/2021 - F - Chapitre 12 - p.179/259 FR 261/376 EN
D12:01 01/05/2021 - F14:38 - Chapitre 12 - p.179/259 FR 262/376 EN

- 10 mns

TABELAU : MOUSEEVENT

(pa)Morphic-Core-Events
(c)UserInputEvent -> Inst. side
(c)MouseEvent
	 |
  	 |----> (m)handlesMouseDown: : Quand un bouton de la souris enfoncé, Morphic envoie chaque morph sous le pointeur 
	 |  |				de la souris le message handlesMouseDown:. Si un morph répond vrai, 
	 |  |				Morphic lui envoie immédiatement le message mouseDown:.
	 |  |<-- (Methods) (pr)instance side, (pr)event handling, (pr)overridden - (Vars) (pr)instance side
	 |
  	 |----> (m)mouseDown: : lorsque le bouton de la souris est enfoncé.
	 |  |<-- (Methods) (pr)instance side, (pr)event handling, (pr)overridden - (Vars) (pr)instance side
	 |
  	 |----> (m)mouseUp: : lorsque l'utilisateur relâche le bouton de la souris.
	 |  |<-- (Methods) (pr)instance side, (pr)event handling, (pr)overridden - (Vars) (pr)instance side
	 |
  	 |----> (m)redButtonPressed : answer true if the red mouse button is being pressed. This is the first mouse button.
	 |  |<-- (Methods) (pr)instance side, (pr)button state- (Vars) (pr)instance side, (pr)UserInputEvent, (pr)buttons
	 |
  	 |----> (m)yellowButtonPressed : answer true if the yellow mouse button is being pressed. This is the second mouse button or option+click on the Mac.
	 |  |<-- (Methods) (pr)instance side, (pr)button state - (Vars) (pr)instance side, (pr)UserInputEvent, (pr)buttons
	 |
  	 |----> (m)mouseLeave: : Handle a mouseLeave event, meaning the mouse just left my bounds with no button pressed. 
	 |  |			The default response is to let my eventHandler, if any, handle it.
	 |  |<-- (Methods) (pr)instance side, (pr)event handling, (pr)overridden - (Vars) (pr)instance side
	 |
  	 |----> (m)mouseEnter: : handle a mouseEnter event, meaning the mouse just entered my bounds with no button pressed. 
	 |  |			The default response is to let my eventHandler, if any, handle it.
 	 |  |<-- (Methods) (pr)instance side, (pr)event handling, (pr)overridden - (Vars) (pr)instance side



" Parcourez cette classe pour voir quelles autres méthodes elle fournit pour interroger l'événement de souris."

Note : 
------
Un coup, il faut décoder le code vers la droite et l'autre fois c'est vers la gauche.
C'est comme avoir le cul entre deux chaises !  (entre deux vagues) 


Événements clavier

 										focus -> morphing spécifique
 										  /|\
gestion d'évènement clavier -> (m)handleKeystroke --> appuie touche -> message ->  |


Problème : 
----------
Depuis Playground lorsque la liste suivante est présente : 
CrossMorph
anEvent
Event
MouseEvent
handleKeystroke:
handlesMouseOver:

swf - 720i
147.Pharobyexample5_Chap. 11_Keyboard_events.swf
Il est possible de lancer la recherche "implementors - CTRL+M" avec "handleKeystroke:", 
mais pas avec "handlesMouseOver:".
Il faut ajouter "#" à "handlesMouseOver:" pour que la fenêtre "Implementors - CTRL+M" s'ouvre. (?)

Lorsque la fenêtre "Implementors" a été ouverte avec "#handlesMouseOver:",
alors c'est après cette étape qu'il est possible d'ouvrir "handlesMouseOver:" sans "#".
* Parfois, le programme Pharo a des comportements bizarres.


Code :
------

Classe : CrossMorph

Création de la méthode "handlesMouseOver:" 
					- Listing 12-30 gérer les événements avec la souris
 
handlesMouseOver: anEvent ^ true

					- Listing 12-31 Obtenir la mise au point du clavier lorsque la souris entre dans le morphing
mouseEnter: anEvent
anEvent hand newKeyboardFocus: self

					- Listing 12-32 Remise du focus lorsque le pointeur s'éloigne
mouseLeave: anEvent
anEvent hand newKeyboardFocus: nil

* Comment veux-tu que je sache qu'il faut mettre "hand, new, : self, :nil" ?

"Pour découvrir les valeurs de clé, vous pouvez ouvrir une fenêtre Transcript et ajouter 
Transcript show: anEvent keyValue à la méthode handleKeystroke:."
"To discover the key values, you can open a Transcript window and add 
Transcript show: anEvent keyValue to the handleKeystroke: method."

* Il manque des informations, ça ne fonctionne pas. 

Transcript (CTRL+O+T) >
		 Transcript show: anEvent keyValue to the handleKeystroke: 	(CTRL+P) > Variable or expression expected -> 
		Transcript show: anEvent keyValue 				(CTRL+P) > Unknown variable: anEvent please correct, or cancel:
												UndefinedObject>>DoIt (anEvent is Undeclared)

14:38 01/05/2021
* C'est tellement simple et cool qu'à force j'ai de moins en moins envie de chercher et de comprendre. 

D12:01 01/05/2021 - F14:38 - Chapitre 12 - p.179/259 FR 262/376 EN
-------------------------------------------------------------------------------------------------------01/05/2021 fin




-------------------------------------------------------------------------------------------------------02/05/2021 debut
D12:40 02/05/2021 - F - Chapitre 12 - p.179/259 FR 262/376 EN
D12:40 02/05/2021 - F13:35 - Chapitre 12 - p.180/259 FR 263/376 EN

argument -> anEvent -> handleKeystroke: -> instance -> Keyboard-Event -> sous-classe -> MorphicEvent.

* "Parcourez ce cours pour en savoir plus sur les événements de clavier."
Non merci.


Code : 
-----

* "déplacer le morphing à l'aide des touches fléchées. 
Notez que lorsque la souris n'est plus sur le morph, le message handleKeystroke: n'est pas envoyé, 
donc le morph cesse de répondre aux commandes du clavier."

handleKeystroke: anEvent
| keyValue |
keyValue := anEvent keyValue.
keyValue = 30 "up arrow"
ifTrue: [self position: self position - (0 @ 1)].
keyValue = 31 "down arrow"
ifTrue: [self position: self position + (0 @ 1)].
keyValue = 29 "right arrow"
ifTrue: [self position: self position + (1 @ 0)].
keyValue = 28 "left arrow"
ifTrue: [self position: self position - (1 @ 0)]


Animations morphiques

"Morphic fournit un système d'animation simple avec deux méthodes principales"
C'est tellement simple qu'il y a deux méthodes principales et cela sous-entend d'autres méthodes.

* Je ne sais pas comment activer l'animation morphic ?
(Quelle galère, entre le code et les explications c'est l'horreur, car tout est décalé !)


* Je ne la trouve pas ta clé à molette "Figure 12-36".
Explications succinctes, je dois me démerder pour chercher, quelle galère cette simplicité super cool.

Recherche :  poignée de débogage - debug handle button - debug handle
----------
"You can even inspect tools by meta-clicking to bring up their morphic halo and selecting the debug handle."

Rien n'apparait dans le halo Morphic.

C'est tellement la galère que je laisse tomber pour aujourd'hui.
Quand bien même qu'il s'agirait d'une version différente du programme Pharo, 
les exercices doivent être finalisés et fonctionnels sur toutes les versions de Pharo. 


13:34 02/05/2021 prochain
12.6 Interacteurs - Interactors

D12:40 02/05/2021 - F13:35 - Chapitre 12 - p.180/259 FR 263/376 EN
-------------------------------------------------------------------------------------------------------02/05/2021 fin




-------------------------------------------------------------------------------------------------------03/05/2021 debut
D12:24 03/05/2021 - F - Chapitre 12 - p.180/259 FR 263/376 EN
D12:24 03/05/2021 - F13:51 - Chapitre 12 - p.180/259 FR 263/376 EN

- 16 mns

CrossMorph -> Inspector on a CrossMorph class (CrossMorph)
	Class Hierarchy
		CrossMorph class
		Morph class
		Object class
		ProtoObject class
		Class
		ClassDescription
		Behavior
		Object
		ProtoObject
		

Note : 
------
* Depuis "Morphic animations" et "Add the following code to the handleKeystroke: method:", le "listing 12-37" ce situe dans "12.6 Interactors".
À supposer que ce soit bien celui-ci.

Donc, du coup de UIManager je repars sur la méthode "handleKeystroke:" avec le "Listing 12-37".
Si ça, ce n'est pas fait pour faire tourner le lecteur en bourrique alors je ne sais pas ce que sait.

Code : 
------

Ajout dans "handleKeystroke: :


keyValue = $+ asciiValue
ifTrue: [ self startStepping ].
keyValue = $- asciiValue
ifTrue: [ self stopStepping ].

* [ifTrue:ifTrue:] Messages sent but not implemented x ?
* Instance of BlockClosure did not understand #keyValue


Ça marche "Po", problème réglé, je passe à la suite.


13:03 03/05/2021 - 12.6 Interactors - UIManager

Code : 
------

* Pourquoi le code n'est-il pas foutu de prendre un "'" à "What''s" ?

Playground (CTRL+O+W) >
UIManager default request: 'What''s your name?' initialAnswer: 'no name'(CTRL+P) > "nil"
UIManager default request: 'What's your name?' initialAnswer: 'no name'	(CTRL+P) > Unmatched ' in string literral. ->


* Je me pose la question à savoir ce qui me pousse à annoter les packages, protocoles et méthodes ci-dessous ?
Est-ce que c'est pour moi ou simplement pour vous ?
Parce que j'ai de moins en moins d'intérêt à m'éterniser avec ce livret ainsi que ce code.

(pa)UIMangager-Base - (c)UIManager
			(pr)instance side, (pr)ui requests (m)request:
	
(pa)System-Support - (/)AuthorNameRequest
			(pr) instance side, (pr)accessing, (pr)AuthorNameRequest, (pr)initialAnswer, (m)initialAnswer:
(pa)Polymorph-Widgets - ||ListDialogWindow
			(pr)instance side, (pr)open/close, (pr)instance side, (pr)ListDialogWindow, (pr)searchMorph,  (m)initialAnswer:

Code : 
------

Test de certaines des méthodes d'interaction : 

Playground (CTRL+O+W) >
UIManager default abort: 'What''s your name?' initialAnswer: 'no name' 	(CTRL+P) > Instance of MorphicUIManager did not understand #abort:initialAnswer
UIManager default abort: 'What''s your name?'				(CTRL+P) > Error -  What's your name? (OK) - true
UIManager default abort: 'What''s your name?' title:boum		(CTRL+P) > String Morph - What's your name? (OK) - true
UIManager default activate: 'What''s your name?'			(CTRL+P) > Instance of MorphicUIManager did not understand #activate
UIManager default activate: 'What''s your name?' initialAnswer: 'no name' 	(CTRL+P) > Instance of MorphicUIManager did not understand #activate:initialAnswer
UIManager default alert: 'What''s your name?' title: 'no name' configure: aBlock (CTRL+P) > #value: was sent to nil
UIManager default edit: 'What''s your name?'				(CTRL+P) > "a SystemWindow(55907840) named: String Morph"
UIManager default inform: 'What''s your name?'				(CTRL+P) > "a MorphicUIManager"
UIManager default logError: 'What''s your name?'			(CTRL+P) > Instance of ByteString did not understand #messageText
UIManager default question: 'What''s your name?'			(CTRL+P) > What's your name? Yes No Cancel


Code : Mise à jour 17:02 03/05/2021
------

* Le "Listing 12-41" correspond à la "Figure 12-40".

UIManager default
chooseFrom: #('circle' 'oval' 'square' 'rectangle' 'triangle')
lines: #(2 4) message: 'Choose a shape'


Playground (CTRL+O+W) >
	UIManager default chooseFrom: #('circle' 'oval' 'square' 'rectangle' 'triangle') lines: #(2 4) message: 'Choose a shape'


Comparaison des codes : 17:06 03/05/2021
-----------------------
UIManager default request: 'What''s your name?' initialAnswer: 'no name'

UIManager default chooseFrom: #('circle' 'oval' 'square' 'rectangle' 'triangle') lines: #(2 4) message: 'Choose a shape'


D12:24 03/05/2021 - F13:51 - Chapitre 12 - p.180/259 FR 263/376 EN
-------------------------------------------------------------------------------------------------------03/05/2021 fin




-------------------------------------------------------------------------------------------------------03/05/2021 debut
D16:57 03/05/2021 - F - Chapitre 12 - p.180/259 FR 263/376 EN
D16:57 03/05/2021 - F17:59 - Chapitre 12 - p.184/259 FR 268/376 EN

12.7 Glisser-déposer

* Mise à jour "16.6 Interactors".

Code :
------

- Listing 12-42 - Depuis le package "PBE-Morphic" ajout de la classe "ReceiverMorph" :

Morph subclass: #ReceiverMorph
instanceVariableNames: ''
classVariableNames: ''
package: 'PBE-Morphic'


- Listing 12-43 - 

ReceiverMorph >> initialize
super initialize.
color := Color red.
bounds := 0 @ 0 extent: 200 @ 200

- Listing 12-44

ReceiverMorph >> wantsDroppedMorph: aMorph event: anEvent
^ aMorph color = Color blue


repelsMorph: event: -> 
- Listing 12-45

ReceiverMorph >> repelsMorph: aMorph event: anEvent
^ (self wantsDroppedMorph: aMorph event: anEvent) not


Créez des instances de ReceiverMorph et EllipseMorph dans une aire de jeux: -> 
- Listing 12-46

- Figure 12-47
* Un carré rouge a été créé ainsi qu'un rond jaune.
Le carré rouge nouvellement créé peut-être positionné sur les autres figures (carré orange, petit carré rouge, petite croix rouge, grande croix rouge).
Tandis que le cercle jaune ne peut pas être placé sur le grand carré rouge, mais sur les autres oui.

Playground (CTRL+O+W) >
	ReceiverMorph new openInWorld; bounds: (100@100 corner: 200@200). EllipseMorph new openInWorld. (CTRL+P) >  "an EllipseMorph(86626560)"


- Listing 12-48 - Depuis le package "PBE-Morphic" ajout de la classe "DroppedMorph" : 

Morph subclass: #DroppedMorph
instanceVariableNames: ''
classVariableNames: ''
package: 'PBE-Morphic'

- Listing 12-49

DroppedMorph >> initialize
super initialize.
color := Color blue.
self position: 250 @ 100

- Listing 12-50

DroppedMorph >> rejectDropMorphEvent: anEvent
| h |
h := anEvent hand.
WorldState addDeferredUIMessage: [ h grabMorph: self ].
anEvent wasHandled: true



- Listing 12-51

* Création d'un grand carré rouge et de deux petits carrés vert et bleu.
Le carré bleu est déplacé sur le grand carré rouge et fait partie de lui sans pouvoir le déplacer. (carré bleu)
Le carré vert est collé à la souris lorsque celui-ci est au-dessus du grand et moyen carré rouge.

Playground (CTRL+O+W) >
	ReceiverMorph new openInWorld.
morph := (DroppedMorph new color: Color blue) openInWorld.
morph position: (morph position + (70@0)).
(DroppedMorph new color: Color green) openInWorld.	(CTRL+P) > "a DroppedMorph(769219328)"

Playground (CTRL+O+W) >
ReceiverMorph new openInWorld. morph := (DroppedMorph new color: Color blue) openInWorld. morph position: (morph position + (70@0)). (DroppedMorph new color: Color green) openInWorld. (CTRL+P) > "a DroppedMorph(769219328)"


Notes : 
-----
J'ai lancé "Windows ->  Collapse all Windows" et cliqué sur chaque fenêtre en bas de Pharo.
C'est alors que la petite croix rouge et la grande se sont mises à clignoter. (il était temps)
Concernant les petits boutons, aucun n'est apparu et toujours impossible d'avoir des boutons dans les Morphs.

* Est-ce qu'il est possible de refaire ou retenir le code précédent pour la création des carrés ? Non.

17:39 03/05/2021
12.8 A complete example

"Définissez le dé comme une sous-classe de BorderedMorph au lieu de Morph, car nous utiliserons la bordure."
* Ha bon ! quel dommage. Moi, je n'aurais utilisé aucun des deux. :-)


* Donc concrètement, je sors du package "PBE-Morphic" et je me positionne sur la classe 
"BorderedMorph" du package "Morphic-Core-Kernel" ? Non, regarde le nom du package dans le code. :-)

Code : 
-----


- Listing 12-54 Définition de la morphologie du dé

BorderedMorph subclass: #DieMorph
instanceVariableNames: 'faces dieValue isStopped'
classVariableNames: ''
package: 'PBE-Morphic'


* "Le dé dans Morphic", comment faire pour qu'il apparaisse ? (Figure 12-53)

Playground (CTRL+O+W) >
	DieMorph new openInWorld. 	(CTRL+P) > "a DieMorph(988667648)"	//carré bleu :-(


- Listing 12-55 Création d'un nouveau dé avec le nombre de faces que nous aimons

* "DieMorph class" indique qu'il faut créer la méthode côté "classe", sinon ça fait une erreur côté instance. 

DieMorph class >> faces: aNumber
^ self new faces: aNumber


- Listing 12-56 Initialisation des instances de  DieMorph

* Remettre "côté instance".

DieMorph >> initialize
super initialize.
self extent: 50 @ 50.
self
useGradientFill;
borderWidth: 2;
useRoundedCorners.
self setBorderStyle: #complexRaised.
self fillStyle direction: self extent.
self color: Color green.
dieValue := 1.
faces := 6.
isStopped := false

D16:57 03/05/2021 - F17:59 - Chapitre 12 - p.184/259 FR 268/376 EN
-------------------------------------------------------------------------------------------------------03/05/2021 fin




-------------------------------------------------------------------------------------------------------04/05/2021 debut
D11:37 04/05/2021 - F - Chapitre 12 - p.184/259 FR 268/376 EN
D11:37 04/05/2021 - F13:57 - Chapitre 12 - p.186/259 FR 271/376 EN

- 18 mns


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------
"La méthode initialize est définie côté instance de la manière habituelle; 
rappelez-vous que new envoie automatiquement initialize à l'instance nouvellement créée."


- Listing 12-57 Réglage du nombre de faces du dé

DieMorph >> faces: aNumber
"Set the number of faces"
((aNumber isInteger and: [ aNumber > 0 ]) and: [ aNumber <= 9 ])
ifTrue: [ faces := aNumber ]


* Est-ce que ça va s'arrêter l'amoncellement de code ? Parce que la simplicité et le cool ont été épuisés.
Non, la suite ci-dessous. :-(

C'est interminable, je peux m'estimer heureux de pouvoir faire un copier/coller.


- Listing 12-58 Neuf méthodes pour placer des points sur les faces du dé

DieMorph >> face1
^ {(0.5 @ 0.5)}

DieMorph >> face2
^{0.25@0.25 . 0.75@0.75}

DieMorph >> face3
^{0.25@0.25 . 0.75@0.75 . 0.5@0.5}

DieMorph >> face4
^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75}

DieMorph >> face5
^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.5@0.5}

DieMorph >> face6
^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 .
0.75@0.5}

DieMorph >> face7
^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 .
0.75@0.5 . 0.5@0.5}

DieMorph >> face8
^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 .
0.75@0.5 . 0.5@0.5 . 0.5@0.25}


* Où est-elle l'interaction avec l'objet vivant ? Lorsque je modifie un code, simultanément le visuelle du dé se modifie aussi.

* Déjà, amuse-toi à te rappeler des classes, des méthodes, des parenthèses, les crochets, les valeurs, les symboles, les chaînes, etc.
C'est interminable pour un malheureux dé.

"Before defining drawOn:, we need a few methods to place the dots on the
displayed face:"


- Listing 12-59 Dessin de la morphologie du dé
* La surprise aurait été de taille en l'absence d'erreurs, c'est à l'image des autres dysfonctionnements.
* Messages Pharo : 
	- Sends "questionnable" message x?
	- (drawDotOn:at:) Super and Self Messages sent but not implemented x ?
	- (drawDotOn:at:) Messages sent but not implemented x ?
 
DieMorph >> drawOn: aCanvas
super drawOn: aCanvas.
(self perform: ('face', dieValue asString) asSymbol)
do: [:aPoint | self drawDotOn: aCanvas at: aPoint]


- Listing 12-60 Dessiner un seul point sur un visage

DieMorph >> drawDotOn: aCanvas at: aPoint
aCanvas
fillOval: (Rectangle
center: self position + (self extent * aPoint)
extent: self extent / 6)
color: Color black


- Listing 12-61 Créer un dé 6
* À ce stade, deux carrés rouge encadré de jaune et barrés puis un carré vert avec un point noir sont apparus.

Playground >
(DieMorph faces: 6) openInWorld. (CTRL+P) > carré vert


- Listing ???????
* Numéro de Listing ?
* Qu'est-ce que j'en fais du code ci-dessous ?

DieMorph >> face9
^{0.25@0.25 . 0.75@0.25 . 0.75@0.75 . 0.25@0.75 . 0.25@0.5 .
0.75@0.5 . 0.5@0.5 . 0.5@0.25 . 0.5@0.75}


- Listing ???????
* Numéro de Listing ?
* Messages Pharo : 
	- (dieValue:) Super and Self Messages sent but not implemented x ?
	- (dieValue:) Messages sent but not implemented x ?

DieMorph >> step
isStopped ifFalse: [self dieValue: (1 to: faces) atRandom]

"Maintenant, le dé roule ! - Now the die is rolling!"

* Comment rouler le dé ?

Playground >
(DieMorph faces: 6) openInWorld. (CTRL+P) > affiche un carré vert -> instance of DieMorph did not understand #dieValue:
									(dieValue: (1 to: faces) atRandom)

* MDR ! 

* Un coup c'est cinq fenêtres qui apparaissent, la fois suivante c'est six.
-> Windows -> Collapse all windows
	a DieMorph(988667648)
	1 - DieMorph - DoItin: - #iFalse: was sent to nil (^ isStopped ifFalse: [ self dieValue: (1 to: faces) atRandom ])
	a DieMorph(66737920)
	2 - DieMorph - step - Instance of DieMorph did not understand #dieValue: (dieValue: (1 to: faces) atRandom)
	a DieMorph(206641408)
	3 - DieMorph - step - Instance of DieMorph did not understand #dieValue: (dieValue: (1 to: faces) atRandom)
	a DieMorph(1036042240)
	4 - DieMorph - step - Instance of DieMorph did not understand #dieValue: (^ isStopped ifFalse: [ self dieValue: (1 to: faces) atRandom ])
	a DieMorph(255729920)
	5 - DieMorph - step - Instance of DieMorph did not understand #dieValue: (dieValue: (1 to: faces) atRandom)
	a DieMorph(106125312)
	6 -  - DieMorph - step - Instance of DieMorph did not understand #dieValue: (dieValue: (1 to: faces) atRandom)
	
	7 - DieMorph - DoItin: - #iFalse: was sent to nil (^ isStopped ifFalse: [ self dieValue: (1 to: faces) atRandom ])


12:52 04/05/2021 - NPharo_negatifs_positifs.txt - 148.Pharobyexample5_Chap. 11_Figure 12-62.swf - 13:09 04/05/2021
Profil : swf - 176x144 - Taille de la vidéo : 720i


* À ce stade, le dé n'affiche qu'une face, accompagné de plusieurs fenêtres d'erreur.
C'est à l'image des autres exercices affichant des erreurs.

* Déjà, amuse-toi à te rappeler des classes, des méthodes, des parenthèses, les crochets, les valeurs, les symboles, les chaînes, etc.
C'est interminable pour un malheureux dé.
De plus, il faut prendre en compte la multitude de codes contenus dans les appels, 
c'est-à-dire que je copie et colle "douze fois" des listings contenant du code qui vont appeler d'autres lignes de code qui ont été créé.

Par curiosité, j'aimerais bien voir l'ensemble du code qui est utilisé.

* Douze copier/coller du "Listing 12-48 au Listing inconnu (DieMorph >> step)".


- Listing 12-63 Réglage de la valeur actuelle du dé
* Messages Pharo : 
	- Guarding clauses x ?
	- Replace single branch conditional with guard clause x  ?
	- Uses "(a and: [b]) and: [c]" instead of"a and: [b and: [c]]" x ?

DieMorph >> dieValue: aNumber
((aNumber isInteger and: [ aNumber > 0 ]) and: [ aNumber <= faces ])
ifTrue: [ dieValue := aNumber. self changed ]


Original
((aNumber isInteger and: [ aNumber > 0 ]) and: [ aNumber <= faces ])

Modif
(aNumber isInteger and: [ aNumber > 0 ]) and: [ aNumber <= faces ]
* Message Pharo :
	[and:ifTrue:] Messages sent but not implemented x ?

* Formidable, ce sera tout pour aujourd'hui.

D11:37 04/05/2021 - F13:57 - Chapitre 12 - p.186/259 FR 271/376 EN
-------------------------------------------------------------------------------------------------------04/05/2021 fin




-------------------------------------------------------------------------------------------------------06/05/2021 debut
D12:22 06/05/2021 - F - Chapitre 12 - p.186/259 FR 271/376 EN
D12:22 06/05/2021 - F13:41 - Chapitre 12 - p.187/259 FR 272/376 EN

* La Figure 12-64 (Result of (DieMorph faces: 6) openInWorld; dieValue: 5.) montre plusieurs informations.
Un carré vert avec cinq points noirs au-dessus de celui-ci des icônes et en bas "a DieMorph(251396096).
Donc, j'en conclue que cette capture provient d'une fenêtre qui se situe en bas de Pharo après avoir cliqué 
sur "Windows -> Collapse all windows.

J'ai déjà cliqué dessus et des fenêtres indiquant des erreurs se sont ouvertes.

L'astuce consiste à faire un clic droit sur une fenêtre nommé "a DieMorph" et sélectionner "Maximize".
Alors, un carré vert apparaîtra affichant aléatoirement un numéro de 1 à 6.

Par contre, c'est quand même bizarre que toutes ces fenêtres soient noires et qu'il faille cliquer sur "maximize"
pour que le code s'active.
(C'est peut-être optionnel ?)

* C'est un comportement bizarre, après avoir "maximizé" les fenêtres "a DieMorph", 
la commande "(DieMorph faces: 6) openInWorld.", n'affiche plus un carré vert simple, mais directement
un carré affichant les nombres aléatoires.

Code : 
------

- Listing ? - activez la réception des événements souris

DieMorph >> mouseDown: anEvent
anEvent redButtonPressed
ifTrue: [isStopped := isStopped not]


- Listing 12-65 Animation du dé

DieMorph >> stepTime
^ 100


- Listing 12-66 Gestion des clics de souris pour démarrer et arrêter l'animation

* Message Pharo : 
	- Utility methods x ?

DieMorph >> handlesMouseDown: anEvent
^ true

-----------
* Toujours deux fenêtres en erreur.

"Windows -> Collapse all windows.

a DieMorph(988667648)
	1 - DieMorph - DoItin: - #iFalse: was sent to nil - (^ isStopped ifFalse: [ self dieValue: (1 to: faces) atRandom ])

a DieMorph(1036042240) // À évolué vers 4.1.
	4 - DieMorph - step - Instance of DieMorph did not understand #dieValue: (^ isStopped ifFalse: [ self dieValue: (1 to: faces) atRandom ])
a DieMorph(1036042240)	
	4.1 - DieMorph - DoItin: - #iFalse: was sent to nil - (^ isStopped ifFalse: [ self dieValue: (1 to: faces) atRandom ])

D12:22 06/05/2021 - F13:41 - Chapitre 12 - p.187/259 FR 272/376 EN
-------------------------------------------------------------------------------------------------------06/05/2021 fin




-------------------------------------------------------------------------------------------------------07/05/2021 debut
D11:53 07/05/2021 - F - Chapitre 12 - p.187/259 FR 272/376 EN
D11:53 07/05/2021 - F14:13 - Chapitre 12 - p.187/259 FR 272/376 EN

- 21 mns

* info récupéré depuis la fin du paragraphe 12.9 more about the canvas
"Pour utiliser un canevas avec une transparence alpha de 0,5 dans DieMorph, redéfinissez dra-wOn: comme ceci :"

- Listing 12-67 Dessin d'un dé translucide
Message Pharo : 
	- Sends "questionnable" message x ?

DieMorph >> drawOn: aCanvas
| theCanvas |
theCanvas := aCanvas asAlphaBlendingCanvas: 0.5.
super drawOn: theCanvas.
(self perform: ('face', dieValue asString) asSymbol)
do: [:aPoint | self drawDotOn: theCanvas at: aPoint]

* En somme, il est obligé d'utiliser le miroir "aCanvas" (Sender aCanvas (8) de la classe "Canvas", 
puis de créer une variable "theCanvas", pour envoyer la valeur 0.5 dans la méthode "asAlphaBlendingCanvas:" 
rattachée à la classe "Canvas", mais réceptionnée par son miroir "aCanvas" et envoyée dans la variable "theCanvas".

Ensuite, la variable "theCanvas" envoi son message à "drawOn:" qui n'est pas une méthode de Canvas,
mais de "Morph, CrossMorph, et DieMorph" et que la méthode "drawOn:" lors des recherches 
avec "Senders, Implementors, Method source containing selection", affiche "Canvas - drawn:" dans leurs listes.

Mais tout va bien puisque le code "Canvas - draw:" utilise "anObject drawOn:", 
malgré la méthode "draw:" rattaché à la classe "Canvas".

Enfin divers rattachement avec des symboles, chaines, valeurs, objet, etc.

Pour faire le point, "drawDotOn:" n'est qu'en vérité "drawDotOn:at:", rattaché à "draw, drawDotOn:at: et drawOn:".



Promenons-nous dans les bois : 
------------------------------

 - (c) = classe
 - (sc) = sous-classe
 - (cm) = classe miroir
 - (m) = méthode
 - (v) = variable
 - super = (#super (cyan muchDarker )) - PharoLightTheme class - Senders super (13)
 - self Senders self (342)
 - drawDotOn: -> Finder -> Selectors -> drawDotOn:at: (DieMorph)
			-> Source -> draw, drawDotOn:at:, drawOn:

--------- Code
DieMorph >> drawOn: aCanvas
| theCanvas |
theCanvas := aCanvas asAlphaBlendingCanvas: 0.5.
super drawOn: theCanvas.
(self perform: ('face', dieValue asString) asSymbol)
do: [:aPoint | self drawDotOn: theCanvas at: aPoint]
--------

-------- Promenade
(c)DieMorph -> (sc)DieMorph -> (m)drawOn: -> (cm)aCanvas - (c)Canvas -(sc)Canvas -> 
(v)theCanvas -> 
0.5 -> (m)asAlphaBlendingCanvas: -> (cm)aCanvas - (c)Canvas -(sc)Canvas -> (v)theCanvas ->
(v)theCanvas -> (m)drawOn: -> super ->
self -> (m)perform: - rattaché à (C)Object) ? -> face ? -> dieValue -> (m)asString Implementors(30) - rattaché à (C)Object) ou rattaché à (c)String ? - (sc)String  -> (m)asSymbol Implementors (3) -> (c)Symbol - (sc)Symbol ?
do: Implementors (53) -> (?)aPoint - (c)Point - (sc)Point -> self -> aPoint - (c)Point - (sc)Point -> (m)drawDotOn: -> (m)drawDotOn:at: -> (v)theCanvas
--------

* (c) = classe
* (sc) = sous-classe
* (cm) = classe miroir
* (m) = méthode
* (v) = variable

14:12 07/05/2021
* À mon avis, j'ai surement dû oublier des interactions par exemple avec les variables globales, partagées, etc.


- Listing 12-59 Dessin de la morphologie du dé
* Cela m'aurait étonné qu'il n'y est pas de boulette à l'image des autres dysfonctonnement.
Messages Pharo : 
	- Sends "questionnable" message x ?

DieMorph >> drawOn: aCanvas
super drawOn: aCanvas.
(self perform: ('face', dieValue asString) asSymbol)
do: [:aPoint | self drawDotOn: aCanvas at: aPoint]

Notes : 
------
"Si vous parcourez la hiérarchie d'héritage de la classe Canvas, 
vous verrez qu'elle a plusieurs variantes. 
La variante par défaut de Canvas est FormCanvas,"

"parcourez la hiérarchie d'héritage de la classe Canvas",
Autrement dit parcourez le volet classe et la hiérarchie d'héritage de Canvas. 


"La méthode drawOn: a une instance de Canvas comme seul argument; le canevas est la zone sur laquelle le
morph se dessine."
Le lien entre "drawOn:" et "Canvas" n'est visuellement pas établie.

	- Implementors drawOn: (88)
		 |	|-> Canvas : non
		 |--------> Morph : oui

	- Senders drawOn: (54)
	    |	|	|-> Canvas = draw: : non
	    |	|---------> Morph = drawKeyboardFocusOn: : non
	    |-------------> DieMorph = drawOn: oui

	- Methods containing a Text for "drawOn:" (case-insensitive) (134)

* On dirait une réparation sommaire qui porte à confusion : un chat n'est pas un chien.
Canvas >> draw:		(draw: diff. drawOn:)
	draw: anObject
	^anObject drawOn: self

* Ce machin bouffe trop d'énergie, c'est trop alambiqué. 

     (m)drawOn:	- (c)Canvas
		    | |   |-> Zone -> Morph
		    | |-> méthodes graphiques 
		    | |-> (m)asAlphaBlendingCanvas:
		variante
		   \|/
		- (c)FormCanvas
		- (c)BalloonCanvas


Question : 
----------
* Je ne comprends pas la question.

"Mais comment pouvez-vous obtenir une telle toile dans une drawOn: méthode, 
quand drawOn: recoit une instance de FormCanvas comme argument ? "

Étant donné que : 
"La méthode drawOn: a une instance de Canvas comme seul argument; 
le canevas est la zone sur laquelle le morph se dessine."

Donc, la variante de "FormCanvas" hérite de "Canvas".
"Si vous parcourez la hiérarchie d'héritage de la classe Canvas, 
vous verrez qu'elle a plusieurs variantes."

* Le Listing 12-67 fait partie du paragraphe 12.9 More about the canvas.


D11:53 07/05/2021 - F14:13 - Chapitre 12 - p.187/259 FR 272/376 EN
-------------------------------------------------------------------------------------------------------07/05/2021 fin




-------------------------------------------------------------------------------------------------------09/05/2021 debut
D11:44 09/05/2021 - F12:18 - Chapitre 12 - p.187/259 FR 272/376 EN

* J'aurais voulu savoir comment ont été créés les bords arrondis du dé.
- méthode "initialize".

* DieMorph >> draw: et drawOn: ont le même code ? 
- J'ai dû le modifier à un moment donné.
- (272 EN - recherche : draw: aCanvas (absent) - drawOn: aCanvas)
- Quand "drawOn:" est supprimé alors les chiffres sont absents contrairement à "draw:".

* Modifier le Morph : BalloonCanvas
1
drawOn: aCanvas
| theCanvas |
theCanvas := aCanvas asAlphaBlendingCanvas: 0.5.
super drawOn: theCanvas.
(self perform: ('face', dieValue asString) asSymbol)
do: [:aPoint | self drawDotOn: theCanvas at: aPoint]
2
drawOn: aCanvas
super drawOn: aCanvas.
(self perform: ('face', dieValue asString) asSymbol)
do: [:aPoint | self drawDotOn: aCanvas at: aPoint]
3 - Si un triangle a été défini au départ ce n'est pas ici que tu changeras de forme.
drawOn: aBalloonCanvas
super drawOn: aBalloonCanvas.
(self perform: ('face', dieValue asString) asSymbol)
do: [:aPoint | self drawDotOn: aBalloonCanvas at: aPoint]

12.10 Résumé du chapitre 
"• Vous pouvez manipuler un morph en méta-cliquant dessus et en utilisant les poignées qui apparaissent. 
(Les poignées ont des bulles d'aide qui expliquent ce qu'elles font.)"
* Aucune poignée et aucune bulle d'aide.

Fin du chapitre 12. Mouais ! 

D11:44 09/05/2021 - F12:18 - Chapitre 12 - p.187/259 FR 272/376 EN

------------------------

D12:18 09/05/2021 - F - Chapitre 13 - p.188/259 FR 275/376 EN
D12:18 09/05/2021 - F13:20 - Chapitre 13 - p.194/259 FR 284/376 EN

12:18 09/05/2021
Chapitre 13 - Bord de mer par exemple - Seaside by example

"Une fois maîtrisé, Seaside rend les applications Web presque aussi faciles à écrire que les applications de bureau."
* Reste à savoir combien de temps il faudra pour maîtriser ce Framework.
Déjà, qu'avec Pharo ce n'est pas gagné alors le pire reste à venir.

"Le bord de mer est vraiment intéressant pour développer des applications complexes et rapides."
* C'est ce que m'avait laissé entendre "la simple syntaxe" de Pharo tenant sur une carte postale.
Mais en vérité, c'est une grosse prise de tête.

"Seaside est inhabituel en ce qu'il est complètement orienté objet: il n'y a pas de modèles HTML, 
pas de flux de contrôle compliqués à travers les pages Web et pas de codage d'état dans les URL.  
Au lieu de cela, vous envoyez simplement des messages aux objets. 
Quelle belle idée !"
* Quel tsunami !

"Les frameworks de développement d'applications Web doivent donc faire face à une multitude de problèmes, 
le principal d'entre eux étant la gestion de ce flux de contrôle inversé."
* "une multitude de problèmes", le dénouement approche.
Étant donné que la syntaxe est simple, c'est tout de même étonnant d'avoir créé ce Framework.
Dans Pharo, il y a tout ce qu'il faut et la cerise sur le Phare c'est un super débogueur donc ces surprenants.

13:00 09/05/2021
13.2 Prise en main - pas d'internet donc pas de téléchargement.
Il aurait fallu y penser avant.

"Il s'agit de distributions Pharo complètes,"
C'est contradictoire ton histoire, il faut le télécharger, mais il s'agit d'un programme Pharo complet.

13:03 09/05/2021
Ma version : 
------------
Pharo 8.0.0
Build information: Pharo-8.0.0+build.1140.sha.5e328f2d7e8ed65fbddfb761624df5a19d0400f7 (32 Bit)
LICENSE	
Licensed under the MIT License with parts under the Apache License.


Code : 
------

- Figure 13-1 Démarrez l'image Seaside One-Click Experience.
Message Playground : 
	- Unknown variable : xxxx

ZnZincServerAdaptor startOn: 8080.
WAPharoServerAdapterSpecBrowser open.


- Listing 13-2 Démarrage et arrêt de Seaside à l'aide de l'adaptateur Zinc Server
Message Playground : 
	- Unknown variable : xxxx

ZnZincServerAdaptor startOn: 8080. "start on port 8080"
ZnZincServerAdaptor stop.

13.3 Composants Seaside
"Examinons de plus près le fonctionnement de Seaside en implémentant le composant Hello World."
"Let’s take a closer look at how Seaside works by implementing the Hello World component."
* Parce que Pharo ne sait pas implémenté un composant Hello World ? MDR ! 

D12:18 09/05/2021 - F13:20 - Chapitre 13 - p.194/259 FR 284/376 EN
-------------------------------------------------------------------------------------------------------09/05/2021 fin




-------------------------------------------------------------------------------------------------------10/05/2021 debut
D10:50 10/05/2021 - F - Chapitre 13 - p.194/259 FR 284/376 EN
D11:50 10/05/2021 - F00:00 - Chapitre 14 - p.214/259 FR 313/376 EN
D11:50 10/05/2021 - F13:45 - Chapitre 14 - p.215/259 FR 314/376 EN

- 16 mns 
- 10 mns

Code : 
------

Playground (CTRL+O+W) >
	WAComponent	 	(CTRL+P) > Unknown variable: WAComponent please correct, or cancel: 
	#WAComponent  		(CTRL+P) > "#WAComponent"

Playground (CTRL+O+W) >
	renderContentOn: 	(CTRL+M) > Implementors of renderContentOn: (1) - RBRefactroyTestDataApp

Playground (CTRL+O+W) >
	#WAHtmlCanvas 		(CTRL+P) > "#WAHtmlCanvas"

Playground (CTRL+O+W) >
	WAHelloWorld	 	(CTRL+P) > Unknown variable: WAComponent please correct, or cancel: 
	#WAHelloWorld 		(CTRL+P) > "#WAHelloWorld

WACounter
canBeRoot
IdentityDictionary
WASnapshot

"L'application de compteur n'est que légèrement plus complexe que l'application hello world."

Fin chapitre 13 - 11:49 10/05/2021
D10:50 10/05/2021 - F11:49 - Chapitre 13 - p.194/259 FR 284/376 EN

* C'est à l'image de ce que j'ai pu faire avec Pharo, mais étant donné que je n'ai pas téléchargé le programme Seaside.
Les tests et les créations ne m'ont pas permis de me prendre la tête donc c'est parfait.
Je ne me suis pas éternisé.
Lecture simple, rapide et efficace me permettant d'aller rapidement au chapitre 14.
Est-ce que j'ai retenu des choses intéressantes ? Pas plus que sous Pharo.
Ce qui est à retenir n'est plus à retenir. :-)

---------------------

D11:50 10/05/2021 - F - Chapitre 14 - p.214/259 FR 313/376 EN

Chapitre 14 - Réflexion

Dictionnaire : 
--------------
Réifiés : Effectuer la réification de. Donner un caractère statique, figé.

"Les méta-objets de Pharo sont des classes, des métaclasses, des dictionnaires de méthodes,"
* Ta liste est succincte par rapport à la mienne parce qu'il faut ajouter 
des classes abstraites, des classes statiques, des classes dynamiques, des superclasses, des sous-classes, 
des méthodes de classes, des méthodes d'instances, des méthodes abstraites, des instances de classe, 
des variables d'instance, des variables non déclarées, des variables partagées globales, 
des variables partagées de pool, des protocoles et n'oublions pas les packages. 

Et j'ai l'impression d'avoir oublié plusieurs choses sans compter que ça ne tiendrait pas sur le revers 
d'une carte postale. :-)

* À ce point là du livret, je ne sais toujours pas programmer.
Je me suis plus pris la tête avec tous ces concepts introspectifs qu'avec la programmation.

"Alors faites attention quand les gens disent que Java est un langage réflexif, c'est un langage introspectif et non réflexif."
Pourquoi l'allusion à Java ? Le but de ce livret est-il de savoir programmer en smalltalk Pharo ou pas ?

12:22 10/05/2021
* Ha d'accord ! - chapitre 14 -> réflexion.


Pharo -> langage -> méta-objets (système d'exécution)
		     |
		[classes, métaclasses, 
		[dictionnaires de méthodes, 
		[compilées, pile, processus, etc.]
		     |
		-----|-----
		|    |	  |
	Inspectés    |	Interrogés
		     |		|
		     |		Objets ordinaires - Réifiés (Donner un caractère statique, figé.)
		     |
		     |-----------
				|
			réfléchissant (Qui renvoie par réflexion)
			     |
			programmes -> (Renvoyer par réflexion dans une nouvelle direction ou dans la direction d’origine)
			 |   |	|---> Réfléchir l'exécution
			 |   |----> Réfléchir structure
			 |------> Réfléchir ?


	Réflexion -> -> -> -> -> -> -> -> -> -> -> -> -> introspection
	    |					 		|
	   \|/						        |examiner
"à leur propre exécution et structure" 			       \|/
					"Cette forme de réflexion est également appelée introspection"
				 |
				\|/
		"la capacité d'examiner les structures 
		de données qui définissent le langage"


		"Un programme qui manipule d'autres programmes ou lui même est un métaprogramme."

			? Intro-détection
							       /|\
							     examiner <--------------------------------<-
								|					|
							"La réflexion structurelle" - "les structures du système d'exécution"
								|					|
							    modifier  <--------------------------------<-
							       \|/

							"La réflexion comportementale" - "modifier l'interprétation de ces structures"
								|		   			|
							    modifier  <--------------------------------<-
		  					       \|/

	Modification -> -> -> -> -> -> -> -> -> -> -> -> intercession
	    |					 		|
	   \|/						        |
"modifier les métaobjets réifiés et de  refléter  	        |modifier
ces changements dans le système d'exécution"		       \|/
						"est également appelé intercession"
				"est pris en charge principalement par des langages de programmation dynamiques,"

		"la capacité de modifier les structures du langage"


"Alors faites attention quand les gens disent que Java est un langage réflexif, c'est un langage introspectif et non réflexif."
* Soit, j'ai mal compris ou alors Java est un langage réflexif introspectif. MDR ! (en inversant les rôles peut-être que ça marche)

14.1 Introspection

Playground (CTRL+O+W) >
							//Ouvre une fenêtre "Playground" avec un onglet intitulé "My Playground".
	w := GTPlayground openLabel: 'My Playground'.	(CTRL+P) > "a GLMSystemWindow(440752128) named: Playground"
							//Ouvre un inspecteur sur GLMSystemWindow (xxxxx) nommé : Playground
	w inspect					(CTRL+P) >

13:44 10/05/2021
"Immédiatement, vous verrez le Playground que nous avons créé changer et se redimensionner."
* Je me suis déjà amusé à faire ça. Franchement, je marche à reculons.

[27/08/2020 - D12:35 - F13:52 - Une première application chapitre 3 p.36/259 FR - 50/376 EN
[28/08/2020 - D08:02 - F12:33 - Une première application chapitre 3 p.43/259 FR - 59/376 EN
[29/08/2020 - D12:22 - F13:49 - Chapitre 3 - 3.8 Terminer le jeu p.46/259 FR - 65/376 EN
[30/08/2020 - D10:04 - F14:00 - Chapitre 3 - 3.8 Terminer le jeu p.48/259 FR - 66/376 EN
[13/10/2020 - D09:52 - F12:10 - Chapitre 6 - p.73/259 FR 105/376 EN




D10:50 10/05/2021 - F11:49 - Chapitre 13 - p.194/259 FR 284/376 EN
D11:50 10/05/2021 - F00:00 - Chapitre 14 - p.214/259 FR 313/376 EN
D11:50 10/05/2021 - F13:45 - Chapitre 14 - p.215/259 FR 314/376 EN
-------------------------------------------------------------------------------------------------------10/05/2021 fin




-------------------------------------------------------------------------------------------------------11/05/2021 debut
D10:44 11/05/2021 - F00:00 - Chapitre 14 - p.215/259 FR 314/376 EN
D10:44 11/05/2021 - F13:52 - Chapitre 14 - p.215/259 FR 315/376 EN

- 10 mns - 11:11 11/05/2021 - 11:21 11/05/2021
- 12 mns - 12:46 11/05/2021 - 12:58 11/05/2021

14.1 Introspection

Code : 
------

Playground (CTRL+O+W) >
w := GTPlayground openLabel: 'My Playground'.
w inspect

* L'inspecteur montre l'état interne du terrain de jeu avec la liste des variables d'instance ainsi que ces valeurs.
Aujourd'hui, je prends conscience de la liste des variables d'instance et leurs valeurs.
Et je me rends compte que c'est le bordel, comme le montre l'exemple ci-dessous ;
les variables d'instance sont des classes ainsi que leurs valeurs avec en complément des classes miroirs.
De plus, jusqu'à maintenant j'ai toujours pensé que le "#" était réservé à la recherche de méthode, alors que
ci-dessous "#Stream" est une classe considérée comme un "a ByteSymbol (#Stream)".

Le plus important est le fait que les variables d'instance sont des classes ainsi que leurs valeurs 
avec en complément des classes miroirs.


Playground (CTRL+O+W) > Stream (CTRL+I) > a Stream class (Stream)
					Raw
					Variable d'instance	Value de la variable d'instance
(CTRL+M) -> 11 classes ?		(c)self			Stream
Implementors of superclass (8) ?	(c)superclass		Object
Implementors of methodDict (3) ?	()methoDict		a MethodDictionary (30 items) xxxxx
Implementors of format (14) ?		E format		0
Implementors of format (17) ?		(c)layout		a FixdeLayout
Implementors of organization (8) ?	(c)organization		a ClassOrganization
Implementors of subclasses (6) ?	()subclasses		an Array (13 items) xxxxx
Implementors of name (346) ?		| name			#Stream
Implementors of classPool (5) ?		()classPool		a Dictionary (0 items)
Implementors of sharedPools (12) ?	()sharedPools		an OrderedCollection (0 items)
Implementors of environment (46) ?	()environment		a SystemDictinary (9098 items) (lots of globals)
Implementors of category (40) ?		| category		#Collections-Streams-Base

Code : 
------

* La parenthèse d'ouverture est collée au "R" tandis que l'autre est espacé de "0" ?
* Dans le livret, le code va à la ligne, ce qui implique la coupure du mot "ori-gin".
* Dès que la fenêtre "Inspector on a GLMSystemWindow est ouverte, inutile de sélectionner une ligne.
* Depuis l'onglet "Raw", dans l'espace du bas (ou case du bas) modifiez le code comme ci-dessous.


Code Original :
--------------- 

"a GLMSystemWindow(198625536) named: Playground"
self

Code Modifié  : (Il faut ajouter "bounds: xxxxxx", à la suite de self)
--------------- 

* Modification de la fermeture de la parenthèse.

"a GLMSystemWindow(198625536) named: Playground"
self bounds: (Rectangle origin: 10@10 corner: 300@300)

-> Do it (CTRL+D)
* Alors, la fenêtre "My Playground" va se redimensionner.


Accéder aux variables d'instance
--------------------------------

Playground (CTRL+O+W) > 
	GLMSystemWindow (CTRL+M) > (||)GLMSystemWindow - instanceVariableNames : 'toolbarBox hasInitialStep' - package : 'Glamour-Morphic-Widgets'

Questions : 
----------

1.
Pourquoi dans "SystemBrowser", volet classe "GLMSystemWindow", sont affiché que deux "Variables d'instance" (toolbarBox, hasInitialStep) ? 
Alors que dans l'"Inspector on a GLMSystemWindow(128193792)", onglet "Raw", ce sont trente "Variables d'instance" ? 
Il serait plus logique qu'il soit renseigné trente "Variables d'instance" dans le volet classe "GLMSystemWindow" au lieu de deux.

* Voilà encore une chose qui n'est pas cohérente.

2.
Ensuite, la valeur "a MultistateButtonMorph" (classe miroir), est envoyé quatre fois dans des "variables d'instance".
(closeBox, collapseBox, menuBox, expandBox) 

3.
"Dans Pharo, toutes les variables d'instance sont protégées."

Rappel :
-------- 		
p.86 FR 124 EN
"Les variables globales sont accessibles partout. Chaque classe est nommée par une variable globale."
p.86 124 EN
"La pratique recommandée est de limiter strictement l'utilisation de variables globales."

* Voilà encore une chose qui n'est pas cohérente.

* Les classes sont nommées par une variable globale et automatiquement partagée, 
mais toutes ces classes ou certaines d'entre elles (2/30 -> toolbarBox, hasInitialStep) sont probablement protégées.

Est-ce que ce sont les 2/30 ou les 28/30 qui sont protégés ? 
C'est contradictoire, incohérent puisque lors de leurs créations toutes les classes sont nommées par une variable globale.
Tout ça est opaque, obscur, nébuleux.


12:46 11/05/2021 - Variable d'instance
					Théorie		    Pratique
					 |			|
				accès impossible	   Inspecteur
					 |			|
				aucun accesseur		   * réflexion Pharo
					 |			|	
					Classe		      Classe
					 |			|
				Définition de classe	Définition de classe
				|	 |	 |	|	|	  |
		     indices numériques	Objet	nom    I.N.   Objet	 nom
					 |			|
					 |		 Méthodes définies
					 |		 |	|	|
					 |     instVarAt: index	| instVarNamed: aString	<- ( iVA: index - iVN: aString - utilisés pour obtenir la valeur de la variable)
					 |		 |	|	|
					 |		 |	|	|
					 |     instVarAt: put:	| instVarNamed: put: <- (iVA:put: - iVN:put: affecter de nouvelles valeurs à ces variables)
					 |			|
			Variables d'instance protégées <-------<|

Mise à jour 12:19 12/05/2021
* "instVarAt:" et "instVarat:put:" sont des méthodes primitives. 
(code : instVarAt:index - "primitif, répond à une variable fixe dans un objet. 
 <primitive: 173 error: ec>	<primitive: 173 erreur: ec>
 self primitiveFailed		auto primitif ? (auto primitif échoué)

* 173 = N = est un entier = is an integer 
* 173 ?

recherche : Failed
the number of tests failed - 185 EN
le nombre de tests ayant échoué - 126 FR


* Ce qui sous-entend que l'humain n'est pas capable d'examiner "réflexion - instropection" du code ? 
Ou bien d'utiliser la "réflexion de Pharo" pour accéder aux variables d'instance ?

* Voilà encore une chose qui n'est pas cohérente.

Finder > Source -> instVarAt: index -> 17 résultats
			|-> instVarAt: - Object -> "See Object documentation whatIsAPrimitive."

		-> instVarNamed: aString -> 6 résultats


Code : 
-----
--------------------------------- Obtenir une valeur
instVarAt: index
	"Primitive. Answer a fixed variable in an object. The numbering of the variables
	 corresponds to the named instance variables, followed by the indexed instance
	 variables. Fail if the index is not an Integer or is not the index of a fixed 
	 variable or indexed variable. Essential. See Object documentation whatIsAPrimitive."

	<primitive: 173 error: ec>
	self primitiveFailed
--------------------------------- Affecter des valeurs - Context
instVarAt: index put: value
	index = 3 
		ifTrue: [
			self stackp: value. 
			^ value].
	^ super instVarAt: index put: value
--------------------------------- Affecter des valeurs - Object
instVarAt: index put: anObject
	"Primitive. Store a value into a fixed variable in an object. The numbering of the
	 variables corresponds to the named instance variables, followed by the indexed
	 instance variables. Fail if the index is not an Integer or is not the index of a fixed
	 variable or indexed variable. Essential. See Object documentation whatIsAPrimitive."

	<primitive: 174 error: ec>
	 (index isInteger 
		and: [ index between: 1 and: self class instSize + self basicSize]) 
			ifFalse: [ ^ self errorSubscriptBounds: index ].
	self isReadOnlyObject 
		ifTrue: [ ^ self modificationForbiddenFor: #instVarAt:put: index: index value: anObject ]
---------------------------------


--------------------------------- Obtenir une valeur - Read - Lecture
instVarNamed: aString
	"Return the value of the instance variable in me with that name.  Slow, but very useful.
	We support here all slots (even non indexed) but raise a backward compatible exception"

	^ self class
		slotNamed: aString
		ifFound: [ :slot | slot read: self ]
		ifNone: [ InstanceVariableNotFound signalFor: aString asString ]

--------------------------------- Affecter des valeurs - Write - Ecriture
instVarNamed: aString put: aValue
	"Store into the value of the instance variable in me of that name. Slow, but very useful.
	We support here all slots (even non indexed) but raise a backward compatible exception"

	^ self class
		slotNamed: aString
		ifFound: [ :slot | slot write: aValue to: self ]
		ifNone: [ InstanceVariableNotFound signalFor: aString asString ]
---------------------------------

Interrogations : 
---------------

* primitiveFailed ?
* primitive: 173 / 174 ?
* index = 3 ?
* put: value ?
* #instVarAt:put: au lieu de instVarAt:put: ? Avec le "#" il répond à CTRL+P sous Playground. Après vérification c'est une méthode.

D10:44 11/05/2021 - F13:52 - Chapitre 14 - p.215/259 FR 315/376 EN
-------------------------------------------------------------------------------------------------------11/05/2021 fin




-------------------------------------------------------------------------------------------------------12/05/2021 debut
D11:16 12/05/2021 - F00:00 - Chapitre 14 - p.215/259 FR 315/376 EN
D11:16 12/05/2021 - F13:23 - Chapitre 14 - p.216/259 FR 316/376 EN

Code : 
------

* Comment est-il possible de savoir qu'il faut mettre "bounds" et "Rectangle xxxx" derrière la méthode "instVarNamed:put:" ?
La touche clavier "tabulation" affiche des suggestions lorsqu'il s'agit de majuscule contrairement aux minuscules et ''.

Réponses : 
---------
Le but étant de démontrer qu'il est possible d'écrire dans une "variable d'instance".
Donc, depuis l'inspecteur "GLMSystemWindow" la variable à modifier est "bounds".

1. Précédemment, la modification a eu lieu dans l'inspecteur et le volet "Raw", sa valeur :
self bounds: (Rectangle origin: 10@10 corner: 300@300)

- Do it -> (CTRL+D), la fenêtre change.


2. Maintenant, la modification a lieu depuis Playground avec la valeur : 
w instVarNamed: 'bounds' put: (Rectangle origin: 10@10 corner: 500@500).

- Do it -> (CTRL+D), la fenêtre ne change pas.
- Fenêtre "inspector" -> "Update" -> la valeur change, mais la fenêtre ne change pas.

* "w" valeur de liaison du premier espace de travail.


La modification sera visible après avoir cliqué sur "Update" situé en haut à droite depuis la fenêtre de l'inspecteur.
La fenêtre "Playground" ne se modifiera pas, malgré la nouvelle valeur écrite dans "bounds". (?)


Astuce : 
--------

1. Aucun réaction de la fenêtre "My Playground,

2. Playground (CTRL+O+W) > w instVarNamed: 'bounds' put: (Rectangle origin: 5@5 corner: 100@100). > Do it (CTRL+D),
 - Fenêtre "Inspector on a GLMSystemWindow" -> "Update" -> la valeur bounds change,
 - Fenêtre "Playground", la fenêtre ne bouge pas.

3. Playground (CTRL+O+W) > w instVarNamed: 'bounds' put: (Rectangle origin: 5@5 corner: 100@100). > Do it (CTRL+D),
 - Fenêtre "Inspector on a GLMSystemWindow" -> "Update" -> la valeur bounds change,
 - Fenêtre "Playground", à ce moment la fenêtre se redimenssionne.

4. Playground (CTRL+O+W) > w instVarNamed: 'bounds' put: (Rectangle origin: 5@5 corner: 100@100). > Do it (CTRL+D),
 - Fenêtre "Inspector on a GLMSystemWindow" -> la valeur bounds change ainsi que la fenête,
 - Fenêtre "Playground" >  Do it (CTRL+D),
 - Fenêtre "Inspector on a GLMSystemWindow" -> la valeur bounds change ainsi que la fenête, 

5. Playground (CTRL+O+W) > w instVarNamed: 'bounds' put: (Rectangle origin: 5@5 corner: 100@100). > Do it (CTRL+D),
 - Fenêtre "My Playground", la fenêtre change mais pas la valeur,
 - Fenêtre "Inspector on a GLMSystemWindow" -> la valeur bounds change.


* Les valeurs "bounds" et "fullbounds" changent.
	- self bounds: (Rectangle origin: 10@10 corner: 300@300)
	- w instVarNamed: 'bounds' put: (Rectangle origin: 5@5 corner: 100@100).

Note : 
------
Avec "Transcript" le comportement est tout autre.

Transcript (CTRL+O+T)>
w instVarNamed: 'bounds' put: (Rectangle origin: 5@5 corner: 100@100). > Do it (CTRL+D) > fenêtre > Unknown variable: w please correct, or cancel:
											réponse > UndefinedObject>>DoIt (w is Undeclared)

"Mise en garde importante : 
Bien que ces méthodes soient utiles pour la construction d'outils de développement, 
leur utilisation pour développer des applications conventionnelles est une mauvaise idée : 
ces méthodes réfléchissantes brisent la frontière d'encapsulation de vos objets 
et peuvent donc rendre votre code beaucoup plus difficile à comprendre et à maintenir."

* Des exemples ?


Mise à jour 12:19 12/05/2021
* "instVarAt:" et "instVarat:put:" sont des méthodes primitives.


Interrogation : 
---------------
Pharo utilise de "l'Anglais pidgin" donc pourquoi ne pas utiliser des méthodes primitives si au final ça fonctionne ?
(simple, rapide, efficace)

Rappel : 
--------
(Syntaxe dans une coquille de noix p.53 - see also Chapter : Syntax in a Nutshell p.75)
"Chapitre 4 La syntaxe en bref - Chapter 4 Syntax in a nutshell"

Anglais pidgin ?
[LINGUISTIQUE] Langue seconde crée à partir de plusieurs systèmes linguistiques, 
à la capactité d’expression limitée et utilisée simplement comme langue de relation.


Code : 
------

- Figure 14-3 Affichage de toutes les variables d'instance d'un GTPlayground.
- Figure 14-3 Displaying all instance variables of a GTPlayground.

Tandis que plus bas indique : 
-----------------------------

"Figure 14-3 Affichage de toutes les variables d'instance d'un GTPlayground."
"La figure 14-3 montre comment afficher les valeurs des variables d'instance d'une instance arbitraire (w) de la classe GTPlayground."

"Figure 14-3 Displaying all instance variables of a GTPlayground."
"Figure 14-3 shows how to display the values of the instance variables of an arbitrary instance (w) of class GTPlayground." 

13:15 12/05/2021
* Alors, il s'agit de quoi ? toutes les variables d'instance ou d'une instance arbitraire ? 
Tout le long du document c'est comme ça, avec des surprises, rajouts de mots, incompréhensions, etc.

"C'est tellement emmêlé qu'au fur et à mesure, je ne cherche même plus à savoir qui fait quoi dans ce méli-mélo.
le chemin est tortueux et parfois incompréhensible."



Playground (CTRL+O+W) >
w := GTPlayground someInstance.
w class allInstVarNames collect: [:each | each -> (w instVarNamed: each)] > Print it (CTRL+P) >

------------ DEBUT horizontal
 "an Array(#registry->a SubscriptionRegistry #suspendAll->false #suspendedAnnouncemets->an OrderedCollection() #logger->a GLMNullLogger #pane->a GLMPane(316730624 root) #title->'Playground' #titleIcon->Form(16x16x32) #transformation->nil #actions->an OrderedCollection(a GLMGenericAction a GLMGenericAction a GLMGenericAction) #condition->nil #implicitNotNil->nil #dynamicActionsBlock->nil #color->nil #customValidation->nil #shouldValidate->nil #acceptsSelection->nil #parentPrototype->nil #registeredAnnouncers->nil #updateActions->an OrderedCollection() #selectionActions->an OrderedCollection() #selectionDynamicActionsBlock->nil #implicitAllNil->nil #rawSelectionTransmissions->an IdentitySet(GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundPort 845092352 (name=#rawSelection value=nil)) destination=a GLMPresentationBoundPort 14345728 (name=#selection value=nil))) #statusPane->nil #sourceLink->nil #initializationBlock->nil #cachedDisplayedValue->nil #labelActionBlock->nil #portChangeActions->an OrderedCollection() #wantsSteps->true #stepTime->1500 #stepCondition->nil #wantsAutomaticRefresh->true #presentations->an OrderedCollection(a GTInspector(id=592901888 title=nil pane=a GLMPane(316730624 root))) #arrangement->a GLMTabbedArrangement)"
------------ FIN vertical

------------ DEBUT horizontal
 "an Array(
#registry->a SubscriptionRegistry 
#suspendAll->false 
#suspendedAnnouncemets->an OrderedCollection() 
#logger->a GLMNullLogger 
#pane->a GLMPane(316730624 root) 
#title->'Playground' 
#titleIcon->Form(16x16x32) 
#transformation->nil 
#actions->an OrderedCollection(a GLMGenericAction a GLMGenericAction a GLMGenericAction) 
#condition->nil 
#implicitNotNil->nil 
#dynamicActionsBlock->nil 
#color->nil 
#customValidation->nil 
#shouldValidate->nil 
#acceptsSelection->nil 
#parentPrototype->nil 
#registeredAnnouncers->nil 
#updateActions->an OrderedCollection() 
#selectionActions->an OrderedCollection() 
#selectionDynamicActionsBlock->nil 
#implicitAllNil->nil 
#rawSelectionTransmissions->an IdentitySet(GLMTransmission (origins=an OrderedCollection(a GLMPresentationBoundPort 845092352 (name=#rawSelection value=nil)) destination=a GLMPresentationBoundPort 14345728 (name=#selection value=nil))) 
#statusPane->nil 
#sourceLink->nil 
#initializationBlock->nil 
#cachedDisplayedValue->nil 
#labelActionBlock->nil 
#portChangeActions->an OrderedCollection() 
#wantsSteps->true 
#stepTime->1500 
#stepCondition->nil 
#wantsAutomaticRefresh->true 
#presentations->an OrderedCollection(a GTInspector(id=592901888 title=nil pane=a GLMPane(316730624 root))) 
#arrangement->a GLMTabbedArrangement)"
------------ FIN vertical



Questions / Interrogations : 
-----------------------------

1.
* Le code ci-dessus affichera toutes les variables sans savoir lesquelles sont privées, des partagées, des pools, etc..
(variables d'instance protégées, variables non déclarées, variables partagées globales, variables partagées de pool, variables fixes, etc.)

2.
* Bizarre, ce n'est plus "Playground", mais "GTPlayground".
Les précédent code contenant "GTPlayground" (blanc), ne prend pas en charge "Playground" (orange).

12:53 12/05/2021
3.
"Tout code Pharo après la déclaration de la primitive est exécuté uniquement si la primitive échoue. 
Cela permet également au débogueur de démarrer sur des méthodes primitives. 
Dans ce cas spécifique, il n'y a aucun moyen d'implémenter cette méthode, donc toute la méthode échoue."

* C'est bizarre cette manière de fonctionner.
Si ça démarre sur une primitive qui échoue, quel est l'intérêt au débogueur de démarrer ? Il démarre sur les autres méthodes primitives.
Pourquoi démarrer sur les autres méthodes primitives et son intérêt ?
Qui plus est lorsque l'implémentation échoue ?

Donc après trois échecs, il est temps d'arrêter ! 
Il y a quelque chose qui m'échappe là.

4.
"Si cette primitive échoue, par exemple si la VM ne gère pas le type de l'argument, le code Pharo est exécuté. 
Bien qu'il soit possible de modifier le code des méthodes primitives, sachez que cela peut être risqué 
pour la stabilité de votre système Pharo."

* Encore une fois, c'est bizarre, "si la VM ne gère pas le type de l'argument, le code Pharo est exécuté".
Dans ce cas-là, il faudrait que la VM gère ce type d'argument ! 
Ou alors qu'elle ne l'exécute pas.
C'est bizarre cette histoire et il y a quelque chose qui m'échappe là.

De plus, il est question de code, mais pas d'objet vivant.

* Trop de complexité tue la complexité. :-)

D11:16 12/05/2021 - F13:23 - Chapitre 14 - p.216/259 FR 316/376 EN
------------------------------------------------------------------------------------------------------12/05/2021 fin




-------------------------------------------------------------------------------------------------------13/05/2021 debut
D18:17 13/05/2021 - F - Chapitre 14 - p.216/259 FR 316/376 EN
D18:17 13/05/2021 - F20:00 - Chapitre 14 - p.216/259 FR 317/376 EN

Code : 
------

Playground (CTRL+O+W) >
 GTPlayground allInstVarNames > Print it (CTRL+P) > "#(
#registry 
#suspendAll 
#suspendedAnnouncemets 
#logger 
#pane 
#title 
#titleIcon 
#transformation 
#actions 
#condition 
#implicitNotNil 
#dynamicActionsBlock 
#color 
#customValidation 
#shouldValidate 
#acceptsSelection 
#parentPrototype 
#registeredAnnouncers 
#updateActions 
#selectionActions 
#selectionDynamicActionsBlock 
#implicitAllNil 
#rawSelectionTransmissions 
#statusPane 
#sourceLink 
#initializationBlock 
#cachedDisplayedValue 
#labelActionBlock 
#portChangeActions 
#wantsSteps 
#stepTime 
#stepCondition 
#wantsAutomaticRefresh
#presentations 
#arrangement)"


Questions / Interrogations : 
----------------------------
"La méthode allInstVarNames renvoie tous les noms des variables d'instance d'une classe donnée."

* De quelle "classe donnée" s'agit-il ?
* Sauf qu’elle renvoie exactement les mêmes variables que la Figure 14-3 ?
* Donc, qu'est-ce que c'est ces variables ? (privées, partagées, pools, etc.)


Ci-dessous je ne demande pas quelque chose de compliqué : (private)

Playground (CTRL+O+W) >
 GTPlayground allInstVarNames private > Print it (CTRL+P) > Instance of Array did not understand #private
 GTPlayground private allInstVarNames > Print it (CTRL+P) > Instance of Array did not understand #private
 GTPlayground private InstVarNames
 GTPlayground InstVarNames private
 GTPlayground allArgumentVariables
 GTPlayground allClassNames

 GTPlayground allClassVarNames > Print it (CTRL+P) >  "#(
#DependentsFields 
#GTPlaygroundEnabledStatus 
#PreferredExtent 
#RememberPreferredExtent)"

 GTPlayground allClassVariableNames
 
 GTPlayground allClassVariables  "an OrderedCollection(
#GTPlaygroundEnabledStatus->true 
#RememberPreferredExtent->true 
#PreferredExtent->(742.0@288.0) 
#DependentsFields->a WeakIdentityKeyDictionary(a Finder->a DependentsArray(a CheckboxMorph(473675008)) a Finder->a DependentsArray(a CheckboxMorph(640103680)) ))"

 GTPlayground allClasses 
 GTPlayground allCount
 GTPlayground allCounters 

D18:17 13/05/2021 - F20:00 - Chapitre 14 - p.216/259 FR 317/376 EN
-------------------------------------------------------------------------------------------------------13/05/2021 fin




-------------------------------------------------------------------------------------------------------14/05/2021 debut
D07:41 14/05/2021 - F - Chapitre 14 - p.216/259 FR 317/376 EN
D07:41 14/05/2021 - F12:39 - Chapitre 14 - p.216/259 FR 317/376 EN

- 15 mns - 07:52 14/05/2021 - 08:07 14/05/2021
- 07 mns - 08:51 14/05/2021 - 08:58 14/05/2021
- 18 mns - 10:29 14/05/2021 - 10:47 14/05/2021


Playground (CTRL+O+W) >
		GTPlayground allCommands > Print it (CTRL+P) > Instance of Array did not understand
GTPlayground allDefinedVariables 	 > Print it (CTRL+P) > Instance of Array did not understand
GTPlayground allImplementedMessages 	 > Print it (CTRL+P) > Instance of Array did not understand
GTPlayground allMetaClasses		 > Print it (CTRL+P) > Instance of Array did not understand
GTPlayground allMethodSelectors 	 > Print it (CTRL+P) > Instance of Array did not understand

GTPlayground allMethods > Print it (CTRL+P) > "{GLMPresentation>>#open:on:entitled:. 
Object>>#addModelYellowButtonMenuItemsTo:forMorph:hand:. 
Object>>#errorNotIndexable. 
Object>>#enclosedSetElement. 
GLMPresentation>>#selectionAct:on:. 
Object>>#metacelloSemanticVersionComponentLessThan:. 
Object>>#stonPostReferenceResolution. 
Object>>#deprecated:on:in:. 
Object>>#isSymbol. 
Object>>#removeActionsForEvent:. 
GLMCompositePresentation>>#composite:. 
GLMCompositePresentation>>#isEmpty. 
Object>>#breakDependents. 
ProtoObject>>#gtInspectorPresentationsIn:inContext:. 
Object>>#isSystemWindow. 
GLMPresentation>>#morphicSelectionAct:entitled:. 
GLMPresentation>>#transformation. 
GLMPresentation>>#wantsSteps:. 
Object>>#spotterActDefault. 
Object>>#yourself. 
GLMPresentation>>#noSelection. 
GLMPresentation>>#watcherPane. 
Object>>#isFloat. ProtoObject>>#ifNil:. 
Object>>#inform:. 
Object>>#toFinalizeSend:to:with:. 
Object>>#asLiteralNode. 
Object>>#gtDebuggerEvaluatorIn:. 
Announcer>>#basicSubscribe:. 
Object>>#pointer. 
ProtoObject>>#allSelectorsToTestInMethodFinder. 
Object>>#complexContents. 
Object>>#changed:with:. ProtoObject>>#becomeForward:. Object>>#primitiveError:. ProtoObject>>#identityHash. Object>>#isKindOf:. GLMPresentation>>#selectionTransformation:. Object>>#actionSequenceForEvent:. GLMCompositePresentation>>#renderGlamorouslyOn:. GLMPresentation>>#acceptsSelection. Object>>#shouldBePrintedAsLiteral. GLMPresentation>>#act:iconName:entitled:. Object>>#withoutListWrapper. ProtoObject>>#asGlamorousArray. GLMPresentation>>#gtActionsIn:. Object>>#link:toSlotNamed:. Object>>#errorImproperStore. GLMPresentation>>#updateOn:fromAll:. Object>>#isNotNil. Object>>#basicSize. ProtoObject>>#cannotInterpret:. GLMPresentation>>#act:on:. GLMPresentation>>#dynamicActionsOnSelection. Object>>#ffiCallingConvention. GLMPresentation>>#addDefaultStatusbarTransmissionFrom:. Object>>#systemIconName. Object>>#phlowValue:. GLMPresentation>>#allSelectionActions. GLMPresentation>>#rawSelectionTransmissionFor:ifNone:. Object>>#deprecated:transformWith:. Object>>#perform:with:with:with:. Object>>#isTransferable. Object>>#trace:. GLMCompositePresentation>>#clear. GLMCompositePresentation>>#select:. ProtoObject>>#basicIdentityHash. Object>>#deprecated:on:in:transformWith:when:. GLMPresentation>>#usesImplicitAllNil. ProtoObject>>#gtDebuggerPresentationsIn:inContext:. Object>>#gtDisplayOn:. Object>>#logExecution. Object>>#asBeaconSignal. Object>>#longPrintOn:limitedTo:indent:. Object>>#removeActionsWithReceiver:. Object>>#populateCBMenu:. Object>>#retryWithGC:until:. GLMCompositePresentation>>#collect:. Object>>#explicitRequirement. GLMPresentation>>#selectionAct:entitled:categorized:. GTPlayground>>#playgroundActionPragma. Object>>#myDependents:. Object>>#perform:withArguments:. Object>>#perform:withEnoughArguments:. Announcer>>#subscribe:do:. ProtoObject>>#flag:. GLMPresentation>>#morphicPopulate:icon:on:entitled:with:. Object>>#ffiCall:options:. Object>>#actionForEvent:. Object>>#traceCrTab:. ProtoObject>>#mustBeBoolean. GLMPresentation>>#act:on:entitled:categorized:. Object>>#haltFromCount:. Object>>#isSpecAdapter. Object>>#isSpAnnouncingObject. Object>>#traceCr. GLMPresentation>>#populate:on:with:. GLMPresentation>>#wantsAutomaticRefresh. Object>>#link:toClassVariableNamed:. Object>>#fuelAccept:. Object>>#isExternalType. GLMPresentation>>#portChangeActions:. Object>>#finalize. ProtoObject>>#isNil. Object>>#createActionMap. Object>>#link:toSlot:. Object>>#asScriptResultStringInCalypso. Object>>#isMorph. GLMPresentation>>#titleIcon. Object>>#fullPrintString. GLMCompositePresentation>>#size. GLMPresentation>>#withAllPanes. GLMPresentation>>#gtInspectorPanePortsIn:. Object>>#closeTo:. GLMPresentation>>#windowIsClosing. Object>>#triggerEvent:. Object>>#printDirectlyToDisplay. Object>>#isCollection. Object>>#myDependents. Announcer>>#replace:with:. Object>>#asCalypsoBrowserItem. Object>>#assert:description:. Object>>#triggerEvent:withArguments:. GLMCompositePresentation>>#unregisterFromAllAnnouncements. GLMPresentation>>#titleAction:. GLMLoggedObject>>#logger:. GLMPresentation>>#sendOneOrMultiple. Object>>#value. Object>>#isRingResolved. GTPlayground>>#inspectorPresentation. Object>>#haltIf:. GLMPresentation>>#sourceContext:. GLMPresentation>>#titleIconValue. Object>>#gtInspectorHash. GLMCompositePresentation>>#add:. GLMPresentation>>#spawn:iconName:entitled:. Object>>#printSystemPath. GTPlayground>>#contextMenuPragma. Announcer>>#unsubscribe:. Object>>#deprecated:. Object>>#isThisEverCalled:. Object>>#pointsOnlyWeaklyTo:. GTPlayground>>#removeBinding:. Object>>#inspectOnce. GLMCompositePresentation>>#text. GLMPresentation>>#initialize:. GLMPresentation>>#morphicSelectionAct:icon:entitled:. Object>>#isSpLayout. GLMPresentation>>#actions:. GLMPresentation>>#act:icon:on:entitled:. GLMPresentation>>#act:iconName:on:entitled:. Object>>#taskbarLabel. Object>>#handleLGitReturnCode. Object>>#wantsVisualFeedback. Object>>#perform:with:. GLMPresentation>>#stepCondition. Object>>#error. GLMPresentation>>#updateOn:from:. GLMPresentation>>#parentPrototype:. Object>>#spotterProcessorsFor:pragma:. GLMPresentation>>#morphicAct:icon:entitled:. GLMCompositePresentation>>#pharoScript. GLMPresentation>>#usesExplicitNotNil. Object>>#gtConstructDebuggerInspectorIn:for:. Object>>#pinInMemory. Object>>#modelWakeUpIn:. Object>>#actionMap. GLMLoggedObject>>#logger. GLMPresentation>>#onChangeOfPort:act:. Object>>#actAsExecutor. Object>>#appendTo:. Object>>#link:toTemporaryNamed:inMethod:option:. Object>>#isEpEvent. Object>>#copySameFrom:. Object>>#hasLiteralSuchThat:. Object>>#explore. Object>>#isEpiceaInterestingJobOwner. Object>>#addModelItemsToWindowMenu:. GLMPresentation>>#send:. GLMPresentation>>#matches. Object>>#copyFrom:. GLMCompositePresentation>>#outerPortEvent:. Object>>#isClosure. GLMPresentation>>#validate:on:. Object>>#settingFixedDomainValueNodeFrom:. Announcer>>#gtInspectorAnnouncementsIn:context:. Object>>#link:toClassVariable:. GLMPresentation>>#taskbarIcon. Object>>#gtListFilter. Object>>#link:toTemporary:. Object>>#removeDependent:. Object>>#isNumber. Object>>#isText. Object>>#storeAt:inTempFrame:. Object>>#veryDeepInner:. Object>>#dragTransferTypeForMorph:. Object>>#isAnnouncingObject. ProtoObject>>#gtInspectorActionBrowse. GLMPresentation>>#portChangeActions. Object>>#isDictionary. Object>>#primitiveChangeClassTo:. GLMPresentation>>#registeredAnnouncers. GLMAnnouncer>>#isAnnouncementSuspended:. Object>>#metacelloStringLessThanSelf:. Object>>#gtIterator. GLMCompositePresentation>>#openWith:. GLMCompositePresentation>>#initializePresentation. GLMPresentation>>#selectionAct:entitled:. GLMCompositePresentation>>#dropDownList. GLMAnnouncer>>#suspendAll. GLMPresentation>>#registerAnnouncements. Object>>#inspectorClass. Object>>#perform:with:with:. GLMPresentation>>#selectionAct:entitled:enabledWhen:. Object>>#errorSubscriptBounds:. Object>>#brickValue:withEnoughArguments:. Object>>#perform:withArguments:inSuperclass:. ProtoObject>>#modificationForbiddenFor:index:value:. GLMCompositePresentation>>#open. Object>>#ffiCalloutIn:. GLMPresentation>>#useExplicitAllNil. Object>>#removeAction:forEvent:. GLMPresentation>>#customValidation. GTPlayground>>#compose. GLMPresentation>>#populate:on:entitled:with:. GLMPresentation>>#send:as:. GLMPresentation>>#title:. Object>>#stonOn:. Object>>#at:put:. GLMCompositePresentation>>#includes:. Object>>#traceCr:. Object>>#halt:. GLMPresentation>>#selectionPopulate:on:entitled:with:. GLMPresentation>>#selectionActions:. Object>>#storeOn:. Object>>#subclassResponsibility. GTPlayground>>#resetBindings. Object>>#fullDisplayString. GTPlayground>>#openOn:. Object>>#link:toMethodNamed:. Object>>#asSpotterCandidateLink. GTPlayground>>#codePresentation. Object>>#gtDebuggerSUnitPrint. Object>>#currentWorld. GLMPresentation>>#transformation:. GLMCompositePresentation>>#startOn:. Object>>#isRGObject. Object>>#isMessageSend. Object>>#releaseActionMap. GLMPresentation>>#dynamicActionsOnSelection:. Announcer>>#hasSubscriber:. GLMPresentation>>#act:entitled:categorized:. Object>>#asOrderedCollection. GTPlayground>>#codePresentationIn:. GLMPresentation>>#addStatusbar. Object>>#isRGUnresolvedValue. Object>>#displayString. GLMCompositePresentation>>#anySatisfy:. Object>>#split:do:. Object>>#finalizationRegistry. GLMPresentation>>#withAllPresentations. GTPlayground>>#pageActions. Announcer>>#numberOfSubscriptions. GLMPresentation>>#selection. Object>>#isString. Object>>#setPinned:. Object>>#isBlock. Object>>#caseOf:. Object>>#beReadOnlyObject. Object>>#dragTransferType. Object>>#'~='. ProtoObject>>#pointersToExcept:. ProtoObject>>#become:. GLMCompositePresentation>>#stackedVerticallyArrangement. Object>>#attemptToAssign:withIndex:. Object>>#setIsReadOnlyObject:. Object>>#dragPassengersFor:inMorph:. Object>>#adaptToFloat:andCompare:. Object>>#nominallyUnsent:. ProtoObject>>#'=='. Object>>#basicInspect. GLMPresentation>>#printOn:. GLMPresentation>>#sendOneOrMultipleAs:. Object>>#asPresenter. Object>>#asBrick. Object>>#mourn. Object>>#readSlot:. Object>>#adaptToInteger:andCompare:. Object>>#iconNamed:. ProtoObject>>#mustBeBooleanIn:. Object>>#isInterval. Object>>#markAsRingResolved. GLMPresentation>>#morphicSelectionAct:icon:on:entitled:. ProtoObject>>#asGlamorousMultiValue. GLMCompositePresentation>>#table. Object>>#when:send:to:withArguments:. Object>>#handles:. Object>>#stonProcessSubObjects:. Object>>#assert:. Object>>#confirm:. Object>>#longPrintStringLimitedTo:. Object>>#joinTo:. GLMPresentation>>#selectionAct:iconName:on:entitled:. GLMCompositePresentation>>#pharoMethod. Object>>#'>>>'. Object>>#traitConflict. Object>>#comeFullyUpOnReload:. GLMPresentation>>#color. Object>>#updateableActionMap. GLMPresentation>>#titleActionBlock. GLMPresentation>>#updateOn:from:when:. Object>>#isTreeNodeModel. Object>>#displayStringOn:. GLMPresentation>>#addAction:. GLMCompositePresentation>>#fastTree. GLMCompositePresentation>>#arrangement:. GLMPresentation>>#statusbarPane. GLMPresentation>>#shouldValidate:. Object>>#acceptDroppingMorph:event:inMorph:. Object>>#dragPassengerFor:inMorph:. Object>>#link:toClassVariableNamed:option:. GLMCompositePresentation>>#verticallyStackedArrangement. Object>>#haltIfNil. GLMCompositePresentation>>#fastTreeTable. Object>>#asMorph. ProtoObject>>#primitiveFailed:. ProtoObject>>#instVarsInclude:. Object>>#asDoubleLink. Object>>#asStringOrText. Object>>#defaultLabel. Object>>#update:. GLMCompositePresentation>>#pane. GLMCompositePresentation>>#arrangement. Object>>#someObject. ProtoObject>>#glamourValueWithArgs:. Object>>#veryDeepCopyWith:. GTPlayground>>#playgroundIcon. GLMPresentation>>#displayValue. Object>>#gtInspectorInterestingObject. GLMCompositePresentation>>#dynamic. Object>>#acceptSettings:. Object>>#hasActionsWithReceiver:. Object>>#longPrintString. GLMPresentation>>#hasStatusbar:. Object>>#shouldNotImplement. GTPlayground>>#label:. GLMPresentation>>#stepTime:. GLMPresentation>>#entity:. Object>>#deprecated:transformWith:when:. GLMPresentation>>#sourceContext. Object>>#asTextMorph. ProtoObject>>#becomeForward:copyHash:. Object>>#adoptForNewCalypsoQuery. GLMPresentation>>#selectionAct:entitled:condition:. Object>>#literalEqual:. Object>>#canDiscardEdits. GTPlayground>>#currentBindings. GLMPresentation>>#shouldValidate. GTPlayground>>#acceptContents:. Object>>#asSpotterProcessorLink. GLMPresentation>>#condition. Object>>#veryDeepCopy. Object>>#isArray. Object>>#instVarAt:. Object>>#fromSton:. GLMPresentation>>#selectionPopulate:entitled:with:. GLMCompositePresentation>>#pager. Object>>#displayStringLimitedTo:. Object>>#isStonReference. Object>>#adaptToFraction:andCompare:. Object>>#printStringLimitedTo:using:. GLMCompositePresentation>>#postCopy. Object>>#wantsDroppedMorph:event:inMorph:. Object>>#inspect. GLMPresentation>>#stepTime. GLMPresentation>>#selectionAct:on:entitled:. Object>>#triggerEvent:with:. Object>>#basicAt:. Object>>#error:. Object>>#hasBindingOf:. GLMCompositePresentation>>#last. GLMCompositePresentation>>#stackedArrangement. ProtoObject>>#modificationForbiddenFor:value:. ProtoObject>>#fuelPointsTo:. GLMAnnouncer>>#suspendAll:while:. GLMPresentation>>#entity. GLMCompositePresentation>>#pane:. Object>>#nbCall:. Object>>#phlowValue:value:. Announcer>>#subscriptions. Object>>#serializeToFileNamed:. Object>>#unplug. Object>>#inspectWithLabel:. Object>>#representsSimpleAnnotationUser:. ProtoObject>>#mustBeBooleanDeOptimizeIn:. ProtoObject>>#withArgs:executeMethod:. Object>>#actionsDo:. Object>>#bindingOf:. Object>>#'->'. GLMCompositePresentation>>#spec. Object>>#spotterRePropertiesFor:. GLMPresentation>>#allowNil. Object>>#isPrimitiveError. Object>>#species. Object>>#nbCall:module:. Object>>#perform:with:with:with:with:. GLMCompositePresentation>>#second. GLMCompositePresentation>>#openOn:with:. Object>>#gtDebuggerRawIn:. Object>>#hash. GLMPresentation>>#selectionTransmission. Object>>#transferFor:from:. Object>>#isRingObject. Object>>#intanceSpecificMetaLinksAvailable. GLMPresentation>>#useImplicitNotNil. Object>>#settingStoreOn:. Announcer>>#when:do:. GLMPresentation>>#titleValue. Object>>#asWidget. Object>>#ffiCall:library:. GLMPresentation>>#gtInspectorBrowserIn:. Object>>#gtInspectorEProportiesIn:. GLMCompositePresentation>>#pharoPlayground. Object>>#logCrTab:. Object>>#actionForEvent:ifAbsent:. Object>>#adaptToInteger:andSend:. Object>>#haltOnce. GLMCompositePresentation>>#custom:. Object>>#metacelloVersionComponentLessThan:. ProtoObject>>#primitiveFailed. Object>>#newCallbackWithSignature:block:. ProtoObject>>#doOnlyOnce:. Object>>#haltIfTest. GLMCompositePresentation>>#diff. GLMCompositePresentation>>#allSatisfy:. Object>>#storeString. GLMPresentation>>#updateToolbar. GLMPresentation>>#hasTransformation. Announcer>>#when:do:for:. Object>>#sizeInMemory. Object>>#externalProperties. Object>>#asSetElement. GLMCompositePresentation>>#do:. Object>>#removeActionsSatisfying:forEvent:. Object>>#deprecated:on:in:transformWith:. GLMCompositePresentation>>#matchingPresentations. Object>>#orDefaultForUnresolved. GLMPresentation>>#dynamicActions:. GLMPresentation>>#populate:iconName:on:entitled:with:. Object>>#changed:. GLMCompositePresentation>>#fastList. Object>>#isPoint. Object>>#isPinned. ProtoObject>>#nextInstance. Object>>#asMethodConstant. Object>>#link:toSlotNamed:option:. GLMLoggedObject>>#announce:. GLMPresentation>>#noTitleIcon. Object>>#treeNodeTail. Object>>#link:toAST:. GLMPresentation>>#selectionAct:icon:on:entitled:. Object>>#split:. GLMCompositePresentation>>#initialize. Object>>#when:evaluate:. Object>>#isMorphicEvent. Object>>#className. GLMCompositePresentation>>#defaultRenderer. Object>>#currentHand. GLMPresentation>>#wantsAutomaticRefresh:. ProtoObject>>#gtInspectorActions. GLMPresentation>>#rawSelection. ProtoObject>>#gtInspectorPresentationsFromPragmas:In:inContext:. GLMPresentation>>#selectionAct:icon:entitled:. ProtoObject>>#'~~'. Object>>#fuelReplacement. GLMCompositePresentation>>#list. GLMPresentation>>#usesImplicitNotNil. Object>>#isThisEverCalled. Object>>#unpinInMemory. Object>>#browse. GLMPresentation>>#status:. GLMPresentation>>#color:. GLMPresentation>>#morphicAct:entitled:. Object>>#errorNonIntegerIndex. Object>>#respondsTo:. GLMPresentation>>#act:entitled:. Object>>#copyTwoLevel. Object>>#perform:orSendTo:. Object>>#gtInspectorVariableValuePairs. Object>>#isVariableBinding. GLMPresentation>>#morphicAct:on:entitled:. Object>>#isFraction. Object>>#ffiCall:library:options:. Object>>#readFromString:. GLMPresentation>>#colorValue. ProtoObject>>#ifNotNil:. GLMPresentation>>#populate:iconName:entitled:with:. GLMPresentation>>#selectionSpawn:entitled:. GLMPresentation>>#dynamicActions. Object>>#metacelloSemanticStringLessThanSelf:. Object>>#asStringMorph. Object>>#isRemoteString. Object>>#asAlphaImageMorph. GLMCompositePresentation>>#tabulator. ProtoObject>>#gtInspectorMetaIn:. Object>>#stonShouldWriteNilInstVars. Object>>#update:with:. GLMPresentation>>#addRawSelectionTransmissionTo:. GLMCompositePresentation>>#actionList. Announcer>>#when:send:to:. Object>>#nbCall:module:options:. Object>>#isCharacter. Object>>#ffiCall:module:options:. Object>>#changed. Object>>#gtInspectorActionSpot. Object>>#okToChange. Object>>#removeActionsSatisfying:. Object>>#glmCritiqueSourceIn:. ProtoObject>>#ifNotNil:ifNil:. ProtoObject>>#mustBeBooleanCompileExpression:andCache:. Object>>#gtInspectorIcon. Object>>#metacelloSemanticIntegerLessThanSelf:. GLMPresentation>>#useExplicitNotNil. Object>>#halt. GLMCompositePresentation>>#openInExternalWindowOn:. GTPlayground>>#actOnBrowserClosing:. Object>>#asDraggableMorph. Object>>#isReadOnlyObject. GTPlayground>>#requestRefresh. Object>>#printAsConstantQueryItem. Object>>#join:. Object>>#asString. Object>>#isSpecLayout. Object>>#ffiCall:. Object>>#notify:at:. Object>>#brickValue:. Object>>#logExit. GLMPresentation>>#populate:icon:on:entitled:with:. GTPlayground>>#playgroundActionsIn:. Object>>#crTrace:. Object>>#calloutAPIClass. Object>>#fallbackMenuOn:. GLMAnnouncer>>#suspendedAnnouncemets. Object>>#crLog. Object>>#isForm. Object>>#isSelfEvaluating. Object>>#hasActionForEvent:. Object>>#ffiLibrary. GLMPresentation>>#selectionAct:iconName:entitled:. Object>>#isHeap. GLMPresentation>>#allActions. GLMPresentation>>#noTitle. Announcer>>#handleSubscriberClass:. GLMCompositePresentation>>#finder. Object>>#instVarAt:put:. Object>>#nbCall:options:. GLMPresentation>>#sendOneOrMultipleAs:updatedBy:. GLMPresentation>>#customValidation:. Object>>#shallowCopy. GLMPresentation>>#stepCondition:. Object>>#haltIfNotTest. GLMPresentation>>#titleIcon:. GLMPresentation>>#act:icon:entitled:. GLMPresentation>>#title. ProtoObject>>#rFwithArgs:executeMethod:. ProtoObject>>#rfIsEqual:. GLMCompositePresentation>>#at:. Object>>#dependents. Object>>#crTrace. Object>>#packToArity:. Object>>#asCollectionElement. Object>>#isValueHolder. Object>>#when:send:to:with:. GLMPresentation>>#noActions. Object>>#isColor. GLMCompositePresentation>>#tree. GLMPresentation>>#hasTitle. GLMPresentation>>#strongSelection. Object>>#writeSlotNamed:value:. Object>>#stonContainSubObjects. ProtoObject>>#metaLinkOptions. Object>>#fuelOut. ProtoObject>>#ifNil:ifNotNil:. Object>>#isTrait. GLMPresentation>>#rootPrototype. GLMPresentation>>#acceptsSelection:. GLMCompositePresentation>>#label. GLMPresentation>>#useImplicitAllNil. GLMPresentation>>#displayedValue. GLMPresentation>>#copy. Object>>#writeSlot:value:. Object>>#asValueHolder. GLMCompositePresentation>>#update. Object>>#basicAt:put:. GLMCompositePresentation>>#rubricText. GLMAnnouncer>>#announcer. GLMPresentation>>#strongSelection:. GTPlayground>>#currentBindingsSorted. Object>>#readSlotNamed:. GLMPresentation>>#statusbarPresentation. Object>>#spotterProcessorsFor:. Object>>#isRingFullyResolved. GLMCompositePresentation>>#openInExternalWindow. Object>>#as:. Object>>#iconOrThumbnailOfSize:. Object>>#externalCallFailed. GTPlayground>>#setBindings:. Object>>#notNil. Object>>#instVarNamed:. Object>>#systemIcon. Object>>#stepIn:. Object>>#pin. Object>>#trace. ProtoObject>>#nextObject. GLMPresentation>>#innerPortEvent:. ProtoObject>>#rearmOneShot. ProtoObject>>#tryPrimitive:withArgs:. ProtoObject>>#glamourValue:. Object>>#isClass. GLMPresentation>>#hasTitleIcon. ProtoObject>>#class. Announcer>>#gtInspectorSubscriptionsIn:. Object>>#currentEvent. Object>>#link:toNodes:. GLMPresentation>>#doValidate:on:. Object>>#logCr. Object>>#deepCopy. GLMPresentation>>#defaultValidate:on:. Object>>#hasDynamicItems. ProtoObject>>#pointersTo. GLMCompositePresentation>>#openOn:inExternalWindowWith:. GLMPresentation>>#allowAllNil. GLMPresentation>>#when:. GLMPresentation>>#parentPrototype. GLMCompositePresentation>>#fastTable. GLMCompositePresentation>>#accordionArrangement. Object>>#systemNavigation. GLMPresentation>>#act:on:entitled:. Object>>#gtDisplayString. Object>>#asActionSequence. GLMPresentation>>#wantsSteps. Object>>#beWritableObject. Object>>#log:. Object>>#spotterPreviewRawIn:. GLMPresentation>>#condition:. Object>>#unpin. Object>>#wrappedInValueHolderIfNeeded. Object>>#treeNodeHead. Object>>#handleProcessTerminationOfWaitingContext:. Object>>#release. Object>>#stepAt:in:. GTPlayground>>#step. Object>>#gtInspectorRawIn:. Object>>#isBehavior. Object>>#isRectangle. Object>>#inspector. Object>>#'~~>'. Object>>#enclosedElement. GLMPresentation>>#hasActions. Object>>#printString. Object>>#executor. ProtoObject>>#executeMethod:. Object>>#logEntry. Object>>#notify:. Object>>#instVarNamed:put:. Object>>#removeActionsWithReceiver:forEvent:. Object>>#matchesQueryBrowserFilter:. GTPlayground>>#codeIn:. ProtoObject>>#pointsTo:. Object>>#addDependent:. Object>>#in:. GTPlayground>>#contextMenuActions. Object>>#=. Object>>#phlowValue:withEnoughArguments:. Object>>#longPrintOn:. GLMPresentation>>#populate:icon:entitled:with:. Object>>#asLink. Object>>#inspectInExternalWindow. GLMPresentation>>#spawn:entitled:. Object>>#adaptToFloat:andSend:. Object>>#hasModelYellowButtonMenuItems. Object>>#setPinnedInMemory:. Object>>#isRingFullyUnresolved. Object>>#printStringLimitedTo:. GTPlayground>>#pageActionPragma. Announcer>>#weak. GLMPresentation>>#window. Object>>#isCompiledMethod. GLMCompositePresentation>>#withAllPanesAndPresentationsDo:. Announcer>>#subscriptionsForClass:. GLMPresentation>>#selectionTransformation. Object>>#wantsStepsIn:. GLMCompositePresentation>>#first. GLMCompositePresentation>>#smalltalkCode. GLMPresentation>>#spawn:icon:entitled:. Object>>#perform:. Object>>#isPinnedInMemory. Object>>#fuelAfterMaterialization. GLMCompositePresentation>>#tabbedArrangement. Object>>#readDataFrom:size:. GLMCompositePresentation>>#morph. Object>>#metacelloIntegerLessThanSelf:. Object>>#brickAlert. GTPlayground>>#defaultPlaygroundTitle. Object>>#putOn:. Object>>#isSpecContainer. Object>>#haltOnCount:. GLMPresentation>>#titleAction. Object>>#valueWithArguments:. GLMPresentation>>#actions. Object>>#gtFilter. Object>>#isClassOrTrait. Object>>#clone. GLMPresentation>>#whenKindOf:. Object>>#caseError. Object>>#crLog:. GLMPresentation>>#addSelectionAction:. Object>>#isColorForm. Object>>#ffiLibraryName. Object>>#notYetImplemented. ProtoObject>>#largeIdentityHash. Object>>#isMethodProperties. Object>>#isInteger. Object>>#isStream. Object>>#gtInspectorVariableNodesIn:. GTPlayground>>#acceptAction:. Object>>#ffiCall:module:. Object>>#storeDataOn:. GLMAnnouncer>>#suspendAllWhile:. Object>>#okToClose. Object>>#isContext. Object>>#isMemberOf:. GLMCompositePresentation>>#resetAnnouncer. Object>>#additionalInspectorClasses. Object>>#link:toTemporaryNamed:inMethod:. Object>>#newCallbackWithSignature:block:library:. GLMCompositePresentation>>#openInExternalWindowWith:. GTPlayground>>#pageActionsIn:. Object>>#isLiteral. Object>>#shouldBeImplemented. GLMCompositePresentation>>#presentations:. GLMAnnouncer>>#glmSubscriptions. Object>>#browseHierarchy. GTPlayground>>#playgroundActions. Object>>#caseOf:otherwise:. GLMPresentation>>#display:. Object>>#spotterPreviewIn:inContext:. Object>>#adaptToFraction:andSend:. Object>>#hasMultipleExecutors. Announcer>>#subscribe:send:to:. Object>>#logCr:. GLMCompositePresentation>>#presentations. GLMPresentation>>#selectionActions. GLMPresentation>>#with:. GLMPresentation>>#allActionsWithShortcuts. Object>>#calypsoEnvironmentType. Object>>#spotterActDefault:. GLMPresentation>>#hasStatusbar. GLMPresentation>>#selection:. Announcer>>#removeSubscription:. Object>>#setActionSequence:forEvent:. Object>>#veryDeepFixupWith:. Object>>#split:indicesDo:. Object>>#stepTimeIn:. Object>>#doesNotUnderstand:. GLMPresentation>>#morphicAct:on:icon:entitled:. ProtoObject>>#primitiveFail}"

GTPlayground allMorphs  > Print it (CTRL+P) > Instance of Array did not understand
GTPlayground allNodeMorphs 
GTPlayground allNonMetaClasses
GTPlayground allNonSubmorphMorphs 
GTPlayground allObjects
GTPlayground allObjectsOrNil
GTPlayground allOccurrences
GTPlayground allOwners
GTPlayground allPackageNames
GTPlayground allPackages
GTPlayground allPackagesNotRegistered
GTPlayground allPackagesWithSettings
GTPlayground allPathSegments
GTPlayground allPoolDictionaryNames
GTPlayground allPosixPermissions
GTPlayground allPragmas
GTPlayground allPragmasWithTag
GTPlayground allPresentationMethods
GTPlayground allPrimitiveMethods
GTPlayground allProcesses
GTPlayground allProtocol
GTPlayground allProtocols
GTPlayground allProtocolsNames
GTPlayground allReifications
GTPlayground allSharedPoolNames
GTPlayground allSubclasses > Print it (CTRL+P) > "an OrderedCollection()"
GTPlayground allSubclassesKey
GTPlayground allSuperclassesKey
GTPlayground allSymbols
GTPlayground allTempAccessInstructions
GTPlayground allTemporaryVariables
GTPlayground allTemps
GTPlayground allThemeClasses
GTPlayground allTraits > Print it (CTRL+P) > "#()"
GTPlayground allTypes
GTPlayground allTypicalFileExtensions
GTPlayground allVersionInfos
GTPlayground allVariables
GTPlayground allVersionInfos
GTPlayground allVersionNames
GTPlayground allVisibleSlots
GTPlayground allWatchpoints

GTPlayground someMethod.
w := GTPlayground someMethod.
w := GTPlayground sUnitPackageNames.

* En résumé, une liste alphabétique est proposée et la moitié si ce n'est plus n'affiche aucun résultat.


Code : synthèse
------

Playground (CTRL+O+W) >

1. Crée et affiche une fenêtre "My Playground" et ouvre l'inspecteur. 
w := GTPlayground openLabel: 'My Playground'.
w inspect

2 Affiche toutes les variables d'instance même si je ne suis pas convaincue.
w := GTPlayground someInstance.
w class allInstVarNames collect: [:each | each -> (w instVarNamed: each)]

3 Affiche aussi tous les noms des variables d'instance "d'une classe donnée(?)" avec un peu moins d'information.
GTPlayground allInstVarNames

4 Affiche toutes les variables d'instance rattachée à "morph".
Morph allSubInstances
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil and: [ own isWorldMorph ] ]


Code : test
------

* 8 secondes pour afficher le résultat.
Playground (CTRL+O+W) >
Morph allSubInstances
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil and: [ own isWorldMorph ] ]  > Print it (CTRL+P) > 
"an OrderedCollection(a StandardWindow(705858816) 
named: Finder a StandardWindow(509985536)
named: Finder a GLMSystemWindow(634280448) 
named: Playground a MenubarMorph(1027596800) a HandMorph(1029655808) a TaskbarMorph(449729024) an ImageMorph(277179392))"

* Modif : isWorldOrHandMorph
Playground (CTRL+O+W) >
Morph allSubInstances
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil and: [ own isWorldOrHandMorph ] ] > Print it (CTRL+P) > 
"an OrderedCollection(a StandardWindow(705858816) 
named: Finder a StandardWindow(509985536) 
named: Finder a GLMSystemWindow(634280448) 
named: Playground a MenubarMorph(1027596800) a HandMorph(1029655808) a TaskbarMorph(449729024) an ImageMorph(277179392))"

* Modif : isWorkingDirectory
Playground (CTRL+O+W) >
Morph allSubInstances
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil and: [ own isWorkingDirectory ] ] > Print it (CTRL+P) > Instance of Array did not understand


Questions / Interrogations :
--------------------------
Les codes ci-dessus montrent et démontrent leurs simplicités comme leurs complexités.
Par exemple le "3", ce sont deux mots tandis que le "4" c'est la répétition de crochets, parenthèses et mots. (each x2, own x4)

08:51 14/05/2021
Le code de la ligne "4" n'est pas cohérent puisqu’à l'ouverture des crochets sont mis "own" entre "pipes", ensuite "own" est de nouveau déclaré devant
deux méthodes et non après, et fermé entre crochets. 

Propositions :
-------------- 
Morph allSubInstances select: [ each: instVarNamed: 'owner', | |, own isNotNil+isWorldOrHandMorph ]
Morph allSubInstances select: [ each: instVarNamed: 'owner'. | |. own isNotNil+isWorldOrHandMorph ]
Morph allSubInstances select: [ each: instVarNamed: 'owner'; | |; own isNotNil+isWorldOrHandMorph ]


Code : 
------

Playground (CTRL+O+W) >

Morph allSubInstances
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil own isWorkingDirectory ] > Print it (CTRL+P) > Instance of True did not understand #own

Morph allSubInstances
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil [isWorkingDirectory]] > Print it (CTRL+P) > Variable or expression expected ->

Morph allSubInstances
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil and: isWorkingDirectory ] > Print it (CTRL+P) > #ifTrue: was sent to nil

Morph allSubInstances
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil isWorkingDirectory ] > Print it (CTRL+P) > Instance of True did not understand #isWorkingDirectory


09:27 14/05/2021
Interroger les classes et les interfaces

"Les outils de développement de Pharo (navigateur système, débogueur, inspecteur ...) utilisent tous les fonctionnalités réfléchissantes "
" autres messages qui pourraient être utiles pour créer des outils de développement"

"isKindOf: aClass renvoie true si le receveur est une instance de aClass ou de l'une de ses superclasses."

	(?)
	isKindOf: aClass -> renvoie -> true	- receveur -> instance: yes - superclasse: yes
	isKindOf: aClass -> renvoie -> true	- receveur -> instance: yes - superclasse: no
	isKindOf: aClass -> renvoie -> false	- receveur -> instance: no - superclasse: yes
	isKindOf: aClass -> renvoie -> false	- receveur -> instance: no - superclasse: no


Interrogations : 
---------------
1. C'est le jour et la nuit, passant d'un code à rallonge puis de quelques valeurs.

2. De plus, je ne comprends pas la finalité du fait de renvoyer "true" si le receveur est une instance de "aClass" ?

3. Dans "Playground", "aClass" s'active en blanc et "#aClass" en orange dont l'implémentation renvoie vers une liste de classes.
Donc, "aClass" est une classe miroir et rattaché à une liste de classes.
De même, dans l'exemple c'est "1.5 class" alors qu'il s'agit de "aClass" ou "Class" ?
[package: 'Kernel-Classes' -> ClassDescription -> subclass: #Class -> (c) Class]
[package: 'Kernel-Classes' -> ProtoObject -> subclass: #ProtoObject -> (c)ProtoObject -> (pr)instance side, (pr)class membership -> (m)class]

4. Cela sous-entend qu'il faut connaître les relations entre le receveur et une instance ou l'une de ses superclasses ? (enfer, galère)


Code : 
-----

Playground (CTRL+O+W) >
			1.5 class > Print it (CTRL+P) > "BoxedFloat64"
			1.5 Class > Print it (CTRL+P) > Instance of BoxedFloat64 did not understand #Class
			1.5 aClass > Print it (CTRL+P) > Instance of BoxedFloat64 did not understand #aClass
			1.5 aclass > Print it (CTRL+P) > Instance of BoxedFloat64 did not understand #aclass

* Tu peux passer en revue toute la liste alphabétique pour remplacer "Float", reste à savoir quoi mettre.
Playground (CTRL+O+W) >
			1.5 isKindOf: Float

10:15 14/05/2021 - 
Rappel : SYNTAXE
----------------
p. 53 FR 75 EN
Chapitre 4 - La syntaxe en bref - Syntax in a nutshell

---------------------------------------------------------------------------
Syntaxe 			Ce que cela représente
-------------------------------------------------------------------------------------------------------------------------------------------------------
Transcript			un nom de variable globale
GTPlayground			?
Assignment :			:= assigns an object to a variable. (Exemple : result := OrderedCollection new.)

self :				pseudo-variable - self est un mot clé qui fait référence à l'objet à l'intérieur duquel la méthode actuelle s'execute.
				Nous l'appelon "le récepteur" parce que cet objet a reçu le message qui a entrainé l'exécution de la méthode.
				self est appelé une "pseudo-variable" car nous ne pouvons pas l'assigner.

'Hello' :			la chaîne  'Bonjour' - the string 'Hello'

#Hello :			le symbole #Bonjour - the symbol #Hello

Transcript show: 'hello'; cr :	cascade de messages ( ; ) - message cascade (;)

cr : 				permet d'aller à la ligne (Transcript)

nil :				nil est l'objet non défini.
				C'est l'instance unique de la classe UndefinedObject. 
				Les variables d'instance, les variables de classe et les variables locales sont initialisées à zéro.

super :   			fait également référence au récepteur de la méthode courante, mais lorsque vous envoyez un message 
				à super, la recherche de méthode change pour qu'elle commence à partir de la superclasse de la classe 
				contenant la méthode qui utilise super. Pour plus de détails, voir le chapitre : (Le modèle d'objet Pharo p.75 FR - The Pharo Object Model p. 103 EN). 
----------------------------------------------------------------------------------------------------------------------

* Les arguments et les variables locales doivent toujours commencer par des lettres minuscules. 
Les noms commençant par des majuscules sont supposés être des variables globales. 
Les noms de classe, comme Character, par exemple, sont simplement des variables globales faisant référence à l'objet représentant cette classe. 


Question / Interrogation :
--------------------------
En recherchant des mots clés dans le livret, cela m'a affiché le tableau des syntaxes.
C'est alors que je me suis rendu compte de la relation improbable entre "Transcript" et "un nom de variable globale".
Donc, la question que je me pose est-ce que c'est la même relation avec "GTPlayground" ?

De mon point de vue, cela sous-entend l'exécution du code dans ces programmes (Transcript, Playground), 
accessible partout et donc, le principe de précaution est d'interdire l'utilisation de ces applications.

* Voilà encore une chose qui n'est pas cohérente.


Rappel : Ajout et mise à jour : 10:27 14/05/2021
-------- 		
p.86 FR 124 EN
"Les variables globales sont accessibles partout. Chaque classe est nommée par une variable globale."
p.86 124 EN
"La pratique recommandée est de limiter strictement l'utilisation de variables globales."

* Voilà encore une chose qui n'est pas cohérente.

* Les classes sont nommées par une variable globale et automatiquement partagée, 
mais toutes ces classes ou certaines d'entre elles (2/30 -> toolbarBox, hasInitialStep) sont probablement protégées.

Est-ce que ce sont les 2/30 ou les 28/30 qui sont protégés ? 
C'est contradictoire, incohérent puisque lors de leurs créations toutes les classes sont nommées par une variable globale.
Tout ça est opaque, obscur, nébuleux.

En recherchant des mots clés dans le livret, cela m'a affiché le tableau des syntaxes.
C'est alors que je me suis rendu compte de la relation improbable entre "Transcript" et "un nom de variable globale".
Donc, la question que je me pose est-ce que c'est la même relation avec "GTPlayground" ?

De mon point de vue, cela sous-entend l'exécution du code dans ces programmes (Transcript, Playground), 
accessible partout et donc, le principe de précaution est d'interdire l'utilisation de ces applications.

* Voilà encore une chose qui n'est pas cohérente.

- 18 mns - 10:29 14/05/2021 - 10:47 14/05/2021


Question / Interrogation : 
--------------------------
"Important : Bien que ces fonctionnalités soient particulièrement utiles pour l'implémentation d'outils de
développement, elles ne sont généralement pas adaptées aux applications classiques."

* Ouais, super. Le truc, c'est de balancer deux mots, mais ensuite l'implémentation elle se passe comment ? 
Avec l'objet vivant ? Dans un mini-projet ?


p. 217 FR 318 EN

Métriques de code
-----------------
"Les métriques de code mesurent des aspects tels que la profondeur de la hiérarchie d'héritage"

"Les métriques de code mesurent des aspects tels que, xxx, le nombre de sous-classes directes ou indirectes,"

Recherche :
-----------
sous-classes directes
sous-classes indirectes

p.98 FR
"les affectations de variables directes (c'est-à-dire, endroits qui modifient la variable sans utiliser de méthodes d'accesseur)"
p. 256 FR
"ClassDescription est une classe abstraite qui fournit les installations nécessaires à ses deux sous-classes directes,"
p. 98 FR
"la superclasse directe de ImageMorph est Morph."


* Magie, après les variables directes ce sont les sous-classes directes et indirectes. 
Est-ce que la finalité de ces sous-classes est de ne pas utiliser d'accesseurs ?

"Morph -  refactorisé".

Code : 
------

Playground (CTRL+O+W) >
	Morph allSuperclasses size. > Print it (CTRL+P) > "2"
	Class allSuperclasses size. > Print it (CTRL+P) > "4"
	aClass allSuperclasses size. > Print it (CTRL+P) > #aClass is missing, and does not understand #allSuperclasses
	allSuperclasses allSuperclasses size. > Print it (CTRL+P) > #allSuperclasses is missing, and does not understand #allSuperclasses
	Transcript allSuperclasses size. > Print it (CTRL+P) > Instance of ThreadSafeTranscript did not understand #allSuperclasses
	Transcript allclasses size. > Print it (CTRL+P) > Instance of ThreadSafeTranscript did not understand #allclasses
	Transcript allVariables size.
	Transcript allVariable size.
	Transcript allvariable size.
	Transcript allvariables size.
	GTPlayground allVariables size.
	GTPlayground allClassVariables size. > Print it (CTRL+P) > "4"
	Transcript allClassVariables size.
	GTPlayground allClassVarNames size. > Print it (CTRL+P) > "4"
	Transcript allClassVarNames size.

1 "profondeur d'héritage" de Morph
Morph allSuperclasses size.

2 "nombre de méthodes" de Morph
Morph allSelectors size.

3 "nombre de variables d'instance" de Morph
Morph allInstVarNames size.

4 "nombre de nouvelles méthodes" de Morph
Morph selectors size.

5 "nombre de nouvelles variables" de Morph
Morph instVarNames size.

6 "sous-classes directes" de Morph
Morph subclasses size.

7 "sous-classes totales" de Morph
Morph allSubclasses size.

8 "total de lignes de code" de Morph
Morph linesOfCode.

allSuperclasses, allSelectors, allInstVarNames, selectors, instVarNames, subclasses, allSubclasses

Question : 
----------
Si le code "Morph subclasses size." affiche les sous-classes directes quel est celui des indirectes ?

Playground (CTRL+O+W) >
ImageMorph allSubInstances
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil and: [ own isWorldMorph ]] > Print it (CTRL+P) > "an OrderedCollection(an ImageMorph(277179392))"

Morph allSuperclasses
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil and: [ own isWorldMorph ]] > Print it (CTRL+P) > InstanceVariableNotFound: owner not found in Object

Morph allSelectors
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil and: [ own isWorldMorph ]] > Print it (CTRL+P) > InstanceVariableNotFound: owner not found in #transferStateToRenderer:

Morph allinstVarNamed
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil and: [ own isWorldMorph ]] > Print it (CTRL+P) > InstanceVariableNotFound: owner not found in #bounds

Morph selectors
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil and: [ own isWorldMorph ]] > Print it (CTRL+P) > InstanceVariableNotFound: owner not found in #asMorph

Morph instVarNames
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil and: [ own isWorldMorph ]] > Print it (CTRL+P) > InstanceVariableNotFound: owner not found in #bounds

Morph subclasses
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil and: [ own isWorldMorph ]] > Print it (CTRL+P) > InstanceVariableNotFound: owner not found in BorderedMorph

Morph allSubclasses
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil and: [ own isWorldMorph ]] > Print it (CTRL+P) > InstanceVariableNotFound: owner not found in BorderedMorph

Morph linesOfCode
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil and: [ own isWorldMorph ]] > Print it (CTRL+P) > Instance of SmallInterger did not understand #select:


11:54 14/05/2021 - p. 218 FR 319 EN
"L'une des métriques les plus intéressantes dans le domaine des langages orientés objet est le nombre de méthodes 
qui étendent les méthodes héritées de la superclasse. 
Cela nous informe sur la relation entre la classe et ses sous-classes.
Dans les sections suivantes, nous verrons comment exploiter notre connaissance de la structure d'exécution pour
répondre à ces questions."

14.2 Code de navigation

* C'est reparti pour "Seaside" ?

"Dans Pharo, tout est un objet."
* Faux, tout est code.

"En particulier, les classes sont des objets"
* Et les "non-particuliers ?

Code : 
------

* Pharo bloqué  D12:03 14/05/2021 - F12:05 14/05/2021 
Playground (CTRL+O+W) >
Behavior allSubInstances
select: [ :each | | own | own := (each instVarNamed: 'owner'). own isNotNil and: [ own isWorldMorph ] ] > Print it (CTRL+P) > InstanceVariableNotFound: owner not found in ProtoObject


* Il interroge la méthode "owner" et "isWorldMorph" situé dans la classe "Morph" tandis que "isNotNil" est dans "Object".

* Pharo bloqué D12:13 14/05/2021 - F12:19 14/05/2021
* J'ai copié qu'une partie du début et la fin de la réponse car elle est longue.
Behavior allSubInstances
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own isBehavior ] ] > Print it (CTRL+P) > InstanceVariableNotFound: owner not found in ProtoObject
Début 
 "an OrderedCollection(Object Exception Abort Error ArgumentsCountMismatch 
ArithmeticError DomainError ZeroDivide FloatingPointException NaNException 
AssertionFailure CannotReturn BlockCannotReturn ContextCannotReturn FileException 
CannotDeleteFileException FileAlreadyExistsException FileDoesNotExistException 
FileWriteError IllegalFileName ReadOnlyFileException FileExistsException 
Fin
DAReversePackageNode DAAssemblyNode DAClassNode DAClassToDependencyNode 
DAInheritanceDependencyNode DAPoolDictionaryDependencyNode DATraitDependencyNode 
DACycleNode DAMethodDependencyNode DAExtensionDependencyNode DAMessageSendNode 
DAMessageSendDependencyNode DAMethodImp...etc..."

* Ce qui veut dire qu'il y a trois points clés à changer dans le code ci-dessus.
	1 allSubInstances	(le contenu - ex : allSuperclasses, allSelectors, allInstVarNames, selectors, instVarNames, subclasses, allSubclasses
	2 'superclass'		(la méthode
	3 isBehavior. 		(la seconde méthode

- Nombre de méthodes dans Behavior
Behavior allSelectors size. 734

- Nombre de méthodes - inst. side - Methods = 252

Questions / interrogations : 
----------------------------

* Ce qui implique de cibler des méthodes parmi les 252 inventoriées.

* Playground affiche 734 méthodes alors que j'en ai dénombré 252 ?


D07:41 14/05/2021 - F12:39 - Chapitre 14 - p.216/259 FR 317/376 EN
-------------------------------------------------------------------------------------------------------14/05/2021 fin




-------------------------------------------------------------------------------------------------------15/05/2021 debut
D08:51 15/05/2021 - F00:00 - Chapitre 14 - p.216/259 FR 317/376 EN
D08:51 15/05/2021 - F10:16 - Chapitre 14 - p.218/259 FR 319/376 EN

- 11 mns 09:40 15/05/2021 - 09:51 15/05/2021

Code : 
------

Original
Morph allSubInstances
select: [ :each || own |own := (each instVarNamed: 'owner').own isNotNil and: [ own isWorldMorph ]]


Modifs
* Fonctionne
Behavior allSubInstances
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own isBehavior ] ] > Print it (CTRL+P) >

* Ne fonctionne pas
Behavior allMethods
select: [ :each | | own | own := (each instVarNamed: 'methods'). own isNotNil and: [ own isAnonymous ] ] > Print it (CTRL+P) >

* Fonctionne
Behavior allInstances
select: [ :each | | own | own := (each instVarNamed: 'dependentClasses'). own isNotNil and: [ own isUsed ] ] > Print it (CTRL+P) > "#()"

* Ne fonctionne pas : donc, tu ne peux pas mettre tout, n'importe quoi. Il reste à déterminer ce qu'il faut mettre. 
Behavior allClassVarNames
select: [ :each | | own | own := (each instVarNamed: 'dependentClasses'). own isNotNil and: [ own isUsed ] ] > Print it (CTRL+P) > InstanceVariableNotFound: dependentClasses not found in #DependentsFields

* Fonctionne
Behavior allSubClasses
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own isBehavior ] ] > Print it (CTRL+P) >
Debut
 "an OrderedCollection(
ClassDescription 
Class Metaclass ProtoObject 
class Trait TraitedMetaclass Object 
class MessageCatcher 
class HDTestCoverage 
class IceProxyMCVersionInfo 
class MetaclassForTraits Exception 
class Path 
class Stream
Fin
class MCMczWriter 
class MCStWriter 
class MCVersionInfoWriter 
class MCMcmWriter 
class MCFileTreeAbstractStWriter 
class TonelWriter 
class IceLibgitTonelWriter 
class Base64MimeConverter ...etc..."


Questions / interrogations : 
--------------------------

* La liste n'est pas classée par ordre alphabétique alors, comment celle-ci est, classée ?
* "...etc..." indique une suite, donc même si la liste est longue d'autres "class" sont disponibles, comment avoir la suite ?

* Fonctionne
Behavior allSuperclasses
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own isBehavior ] ] > Print it (CTRL+P) > "an OrderedCollection(Object)"

Behavior allTraits
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own isBehavior ] ] > Print it (CTRL+P) > "#()"

* Ne fonctionne pas
Behavior allCallsOn
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own isBehavior ] ] >

* Fonctionne
SmallInteger allCallsOn

* Ne fonctionne pas
Behavior allInstVarNames
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own isBehavior ] ]

* Fonctionne
Behavior allInstancesOrNil
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own isBehavior ] ] > "#()"

* Ne fonctionne pas
Behavior allSelectors
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own isBehavior ] ]

* Ne fonctionne pas
Behavior allSelectorsAbove
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own isBehavior ] ]

* Fonctionne
Behavior allSharedPools
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own isBehavior ] ] > "an OrderedCollection()"

* Ne fonctionne pas
Behavior allSlots
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own isBehavior ] ]

* Fonctionne
Behavior allSuperclasses 
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own isBehavior ] ] >  "an OrderedCollection(Object)"

* Ne fonctionne pas
Behavior allUnsentMessages
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own isBehavior ] ] >

09:35 15/05/2021 - p. 218 FR 319 EN

Code :
------

"une instance aléatoire d'une classe donnée en lui envoyant le message"
Playground >
	Point someInstance > CTRL+P > "(-1@ -1)"

"rassembler toutes les instances avec allInstances, 
ou le nombre d'instances actives en mémoire avec instanceCount"

Playground >
	ByteString allInstances 	> CTRL+P >
	ByteString instanceCount	> CTRL+P >
	String allSubInstances size	> CTRL+P > "140071"
	String allSubInstances size.	> CTRL+P > "140299"

* Bizarre, le "." est absent après "size" ?

- 11 mns 09:40 15/05/2021 - 09:51 15/05/2021

	String allSubInstances	> CTRL+P >
Debut
 "an OrderedCollection('void' 'bool' 'byte' 'sbyte' 'ushort' 'short' 'ulong' 'long' 'ulonglong' 
'longlong' 'char' 'schar' 'float' 'double' '' 'Graphical User Interface' 'Tools' 'Network' 'System' 
'User' 'Pharo' '' '5e328f2d7e8ed65fbddfb761624df5a19d0400f7' '' '' '' '' '' '' '' '' '' '' '' '' '' 
'' '' '' '' '' '' '' '' '' '' '' '' '' '' '' '' ''
Fin
negative integers' 'zero' '' 'negative ' ', ' 'Negative numbers don''t have even roots.' 'MDC' 'CLX' 'XVI' '' 
'hundred' ' ' '-' 'sqrt undefined for number less than zero.' 'ln is only defined for x > 0' 
'log is only defined for x > 0' 'sqrt undefined for number less than zero.' 'ln is only defined for x > 0' 
'log is only defined for x > 0' 'sqrt undefined for number less than zero.' '...etc..."


Question / Interrogation : 
--------------------------
* Je me posais la question, à savoir "ce qu'il y avait en mémoire".
Est-ce que la commande ci-dessus a bien affiché le contenu de la mémoire ?

* Je ne comprends pas l'intérêt qu'il y est toutes ces instances en mémoires ?
Seulement celle lancée, devrait être en mémoire et encore n'est-ce pas un problème de sécurité ?

D08:51 15/05/2021 - F10:16 - Chapitre 14 - p.218/259 FR 319/376 EN
-------------------------------------------------------------------------------------------------------15/05/2021 fin




-------------------------------------------------------------------------------------------------------16/05/2021 debut
D09:44 16/05/2021 - F00:00 - Chapitre 14 - p.218/259 FR 319/376 EN
D09:44 16/05/2021 - F12:50 - Chapitre 14 - p.220/259 FR 321/376 EN

- 10 mns - 10:13 16/05/2021 - 10:23 16/05/2021
- 4 mns - 10:44 16/05/2021 - 10:48 16/05/2021
- 2 mns - 11:36 16/05/2021 - 11:38 16/05/2021

Playground >
	ByteString allInstances 	> CTRL+P >
	ByteString instanceCount	> CTRL+P >
	String allSubInstances size	> CTRL+P > "140071"
	String allSubInstances size.	> CTRL+P > "140299"

	ByteString allSubInstances size > CTRL+P > "58154"
	ByteString allSubInstances	> CTRL+P >
Debut
"an OrderedCollection('void' 'bool' 'byte' 'sbyte' 'ushort' 'short' 'ulong' 'long' 'ulonglong' 'longlong' 'char' 'schar' 'float' 'double' '' 'Graphical User Interface' 'Tools' 'Network' 'System' 'User' 'Pharo' '' '5e328f2d7e8ed65fbddfb761624df5a19d0400f7'

Fin
'MDC' 'CLX' 'XVI' '' ' hundred' ' ' '-' 'sqrt undefined for number less than zero.' 'ln is only defined for x > 0' 'log is only defined for x > 0' 'sqrt undefined for number less than zero.' 'ln is only defined for x > 0' 'log is only defined for x > 0' 'sqrt undefined for number less than zero.' '...etc..."

	String allInstances	 	> CTRL+P > "#()"
	String instanceCount		> CTRL+P > "0"


- 10 mns - 10:13 16/05/2021 - 10:23 16/05/2021
"whichSelectorsAccess: renvoie la liste de tous les sélecteurs de méthodes 
qui lisent ou écrivent la variable d'instance nommée par l'argument."

Playground >
	Point whichSelectorsAccess: 'a'		> CTRL+P > "#()"
	Point whichSelectorsAccess: 'b'		> CTRL+P > "#()"
* Lancé de "a" à "z".
	Point whichSelectorsAccess: 'x'		> CTRL+P > "#(#'\\' #asNonFractionalPoint #min: #translateBy: #asFloatPoint #adhereTo: #setR:degrees: #hash #rightRotated #< #roundDownTo: #/ #deepCopy #truncated #asIntegerPoint #normal #isFloatPoint #'>=' #sign #negated #distanceTo: #- #'//' #onLineFrom:to:within: #flipBy:centerAt: #octantOf: #> #normalized #= #ceiling #setX:setY: #dist: #scaleFrom:to: #reciprocal #x #+ #truncateTo: #closeTo: #theta #quadrantOf: #abs #floor #bitShiftPoint: #max: #dotProduct: #* #scaleBy: #rounded #transposed #isZero #roundTo: #printOn: #isIntegerPoint #roundUpTo: #bearingToPoint: #leftRotated #crossProduct: #nearestPointAlongLineFrom:to: #fromSton: #stonOn: #grid: #degrees #sortsBefore: #'<=')"
	Point whichSelectorsAccess: 'y'		> CTRL+P > "#(#'\\' #asNonFractionalPoint #min: #translateBy: #asFloatPoint #adhereTo: #setR:degrees: #hash #rightRotated #< #roundDownTo: #/ #deepCopy #truncated #asIntegerPoint #normal #isFloatPoint #'>=' #sign #negated #distanceTo: #- #'//' #onLineFrom:to:within: #flipBy:centerAt: #octantOf: #> #normalized #= #ceiling #setX:setY: #dist: #scaleFrom:to: #reciprocal #x #+ #truncateTo: #closeTo: #theta #quadrantOf: #abs #floor #bitShiftPoint: #max: #dotProduct: #* #scaleBy: #rounded #transposed #isZero #roundTo: #printOn: #isIntegerPoint #roundUpTo: #bearingToPoint: #leftRotated #crossProduct: #nearestPointAlongLineFrom:to: #fromSton: #stonOn: #grid: #degrees #sortsBefore: #'<=')"
	Point whichSelectorsAccess: 'z'		> CTRL+P > "#()"
* Lancé "A", "B", "X", "Y", "Z".


"whichSelectorsStoreInto: renvoie les sélecteurs de méthodes qui modifient la valeur d'une variable d'instance."

Playground >
	Point whichSelectorsStoreInto: 'x'	> CTRL+P > "#(#setR:degrees: #setX:setY: #bitShiftPoint: #fromSton:)"
	Point whichSelectorsStoreInto: 'y'	> CTRL+P > "#(#setR:degrees: #setX:setY: #bitShiftPoint: #fromSton:)"

"whichSelectorsReferTo: retourne les sélecteurs de méthodes qui envoient un message donné."

Playground >
	Point whichSelectorsReferTo: #+		> CTRL+P > "#(#+)"
							 > "#(#-)"
							 > "#(#*)"
	Point whichSelectorsReferTo: #normal	> CTRL+P > "#()"
	Point whichSelectorsReferTo: #= 	> CTRL+P > "#()"
	Point whichSelectorsReferTo: #rounded  	> CTRL+P > "#(#rounded #bearingToPoint:)"
	Point whichSelectorsReferTo: #transposed> CTRL+P > "#()"
	Point whichSelectorsReferTo: #isZero  	> CTRL+P > "#(#insideTriangle:with:with: #isZero)"

"whichClassIncludesSelector: retourne la superclasse qui implémente le message donné." 

Playground >
	Rectangle whichClassIncludesSelector: #inspect	> CTRL+P > "Object"
	Rectangle whichClassIncludesSelector: #isZero	> CTRL+P > "Rectangle"
	Rectangle whichClassIncludesSelector: #transposed 		> CTRL+P > "nil"
	Rectangle whichClassIncludesSelector: #asNonFractionalPoint 	> CTRL+P > "nil"
	Rectangle whichClassIncludesSelector: #hash	> CTRL+P > "Rectangle"	


"unreferencedInstanceVariables renvoie la liste des variables d'instance qui ne sont utilisées 
ni dans la classe de récepteur ni dans aucune de ses sous-classes." 

Playground >
	Rectangle unreferencedInstanceVariables		> CTRL+P > "#()"

- 4 mns - 10:44 16/05/2021 - 10:48 16/05/2021

* "unreferencedInstanceVariables" est une méthode de "Behavior", donc jouons avec les autres méthodes disponibles.

Playground >
	Rectangle typeOfClass			> CTRL+P > "#normal"
	Rectangle users 			> CTRL+P > "#()"
	Rectangle usingMethods  		> CTRL+P > 
	Debut "an OrderedCollection(AthensCanvasWrapper>>#isVisibleDebug: BalloonMorph class>>#getBestLocation:for:corner: BlockClosureTest>>#testRunSimulated CircleMorph>>#bounds: ClyClassReferencesQueryTest>>#testComparison ContextTest>>#setUp DamageRecorder>>#recordInvalidRect: DieMorph>>#drawDotOn:at:
	Fin TextComposer>>#composeLinesFrom:to:delta:into:priorLines:atY:textStyle:text:container:wantsColumnBreaks: TransformationMorph>>#computeBounds WorldState>>#drawWorld:submorphs:invalidAreasOn:)"

	Rectangle withAllSubclasses  		> CTRL+P > "an OrderedCollection(CharacterBlock Rectangle)"
	Rectangle withAllSuperAndSubclasses	> CTRL+P > "an OrderedCollection(Object ProtoObject CharacterBlock Rectangle)"

* Tu peux passer toute l'année à interroger toutes ces méthodes.

	Rectangle subclassDefinerClass  	> CTRL+P > "OpalCompiler"
	Rectangle superclass  					"Object"
	Rectangle startUp  					"Rectangle"
	Rectangle spaceUsed  					"9227"
	Rectangle sourceCodeTemplate  		> CTRL+P >	"'messageSelectorAndArgumentNames
								""comment stating purpose of instance-side message""
								""scope: class-variables  &  instance-variables""	
			
								| temporary variable names |
								statements'"
	
	Rectangle someInstance  		> CTRL+P > "(10.0@28.0) corner: (371.0@149.0)"
	Rectangle slots 					"{#origin => InstanceVariableSlot. #corner => InstanceVariableSlot}"
	Rectangle shutDown  					"Rectangle"
	Rectangle shouldNotBeRedefined  			"false"
	Rectangle sharedPoolNames  				"an OrderedCollection()"


* "Rectangle sharedPoolNames", la valeur retournée est intéressante "an OrderedCollection()", elle est partagée et c'est une grande collection, rien que ça.

	Rectangle selectors  			> CTRL+P > 
	Debut "#(#pointAtSideOrCorner: #withSideOrCorner:setToPoint:minExtent: #boundingBox #compressTo: #deltaToEnsureInOrCentered:extra: #adjustTo:along: #translateBy: #pointNearestTo: #translatedToBeWithin: #asPolygonTransformedBy: #corner 
	Fin #amountToTranslateWithin: #allAreasOutsideList:startingAt:do: #fuelAccept: #asLayoutFrame #intersect: #center #withLeft: #isRectangle #withBottom: #isWide #top #rotateBy:centerAt: #topCenter #asSpecLayoutFrame #centeredBeneath: #asSDLRect)"

	Rectangle removePropertiesIfEmpty  	> CTRL+P > "nil"
	Rectangle removeAllObsoleteSubclasses  	> "Rectangle"
	Rectangle realClass  			> "Rectangle"
	Rectangle protocols  			> CTRL+P > "#(#'*OSWindow-SDL2' #'*Athens-Core' #accessing #transforming #'truncation and round off' #'*Spec2-Layout' #private #'rectangle functions' #converting #'*Fuel-Core' #testing #printing #fmp #comparing #'*Spec-Core' #'*Morphic-Base' #'*Rubric' #'truncation and roundoff' #'self evaluating')"
	CircleMorph protocols  			> CTRL+P > "#(#geometry #'rotate scale and flex' #initialization #accessing #menus #'geometry etoy')"
	Rectangle properties    			"nil"
	Rectangle isVariable  				"false"
	Rectangle instVarNames  			"#(#origin #corner)"
	Rectangle allInstVarNames  			"#(#origin #corner)"
	
* Qu'est-ce que je cherche ? Pourquoi continuer à lancer des commandes ?

	Rectangle initialize  			> CTRL+P > "Rectangle"

	Rectangle basicIdentityHash  		"4315"
	Rectangle allSuperclasses  		"an OrderedCollection(Object ProtoObject)"
	Rectangle allSubclasses  		"an OrderedCollection(CharacterBlock)"

	Rectangle dependentClasses 		"{SmallInteger. Margin. Object. Rectangle class. Rectangle. Array}"
	Rectangle classVarNames  		"#()"
	Rectangle allClassVarNames  		"#(#DependentsFields)"

* "an OrderedCollection", pool partagé, c'est magnifique.

	Rectangle allSubInstances  		> CTRL+P >
	Debut "an OrderedCollection((10.0@28.0) corner: (371.0@149.0) (10.0@28.0) corner: (371.0@149.0) (0@0) corner: (73@18) (85.0@22.0) corner: (284.0@40.0) (85.0@22.0) corner: (284.0@40.0) (85.0@41.0) corner: (284.0@59.0) (85.0@41.0) corner: 
	Fin corner: (84@14) (199.0@43.0) corner: (223.0@61.0) (199.0@43.0) corner: (223.0@61.0) (223.0@42.0) corner: (247.0@62.0) (223.0@42.0) corner: (247.0@62.0) (247.0@42.0) corner: (271.0@62.0) (247.0@42.0) corner: (271.0@62.0) (271.0@42.0) corner: (295...etc..."

	Rectangle allSharedPools  		> CTRL+P > "an OrderedCollection()"

* Le retour du partage de Pools. Il ne reste plus qu'à savoir comment pirater le partage de ce programme et le tour est joué.

	Rectangle allSelectors  		> CTRL+P > 
	Debut "an IdentitySet(#expandBy: #addModelYellowButtonMenuItemsTo:forMorph:hand: #errorNotIndexable #enclosedSetElement #metacelloSemanticVersionComponentLessThan: #removeActionsForEvent: 
	Fin #setActionSequence:forEvent: #veryDeepFixupWith: #stepTimeIn: #split:indicesDo: #doesNotUnderstand: #primitiveFail #origin)"

	Rectangle allMethods  			> CTRL+P > 
	Debut "{Rectangle>>#expandBy:. Object>>#addModelYellowButtonMenuItemsTo:forMorph:hand:. Object>>#errorNotIndexable. Object>>#enclosedSetElement. Object>>#metacelloSemanticVersionComponentLessThan:. 
	Fin Object>>#setActionSequence:forEvent:. Object>>#veryDeepFixupWith:. Object>>#stepTimeIn:. Object>>#split:indicesDo:. Object>>#doesNotUnderstand:. ProtoObject>>#primitiveFail. Rectangle>>#origin}"

* Alors ça c'est pareil, "allSelectors = méthodes" et "allMethods = (?) = doute = méthodes (?)).
Le début ne commence pas pareil, mais le résultat semble être le même.
Pourquoi s'enquiquiner avec "allSelectors" alors qu’"allMethods" existe ?
((pa)=package, (c)=classe, (pr)=protocole, (m)=méthode))

	Rectangle allInstancesOrNil		> CTRL+P >
	Debut Rectangle allInstancesOrNil  "{(10.0@28.0) corner: (371.0@149.0). (10.0@28.0) corner: (371.0@149.0). (0@0) corner: (73@18). (85.0@22.0) corner: (284.0@40.0). (85.0@22.0) corner: (284.0@40.0). (85.0@41.0) corner: (284.0@59.0). (85.0@41.0) corner: (284.0@59.0).
	Fin corner: (725.0@382.0). (707.0@366.0) corner: (725.0@382.0). (708.0@366.0) corner: (724.0@382.0). (708.0@366.0) corner: (724.0@382.0). (299.0@18.0) corner: (523.0@187.0). (299@18) corner: (523@187). (-1...etc..."

	Rectangle allInstances  
	Debut "{(10.0@28.0) corner: (371.0@149.0). (10.0@28.0) corner: (371.0@149.0). (0@0) corner: (73@18). (85.0@22.0) corner: (284.0@40.0). (85.0@22.0) corner: (284.0@40.0). (85.0@41.0) corner: (284.0@59.0). (85.0@41.0) corner: (284.0@59.0).
	Fin corner: (725.0@382.0). (707.0@366.0) corner: (725.0@382.0). (708.0@366.0) corner: (724.0@382.0). (708.0@366.0) corner: (724.0@382.0). (299.0@18.0) corner: (523.0@187.0). (299@18) corner: (523@187). (-1...etc..."
	
	*(c)Rectangle
	Rectangle allInstVarNames  		"#(#origin #corner)"

"SystemNavigation est une façade qui prend en charge diverses méthodes utiles pour interroger et parcourir le code 
source du système. 
La valeur par défaut de SystemNavigation renvoie une instance que vous pouvez utiliser pour naviguer dans le système."
	 
- 2 mns - 11:36 16/05/2021 - 11:38 16/05/2021

* "est une façade" ?

Playground >
	SystemNavigation default allClassesImplementing: #yourself 	"an OrderedCollection(Object)"

Test :	
	SystemNavigation default  					"a SystemNavigation"
	SystemNavigation default allClassesImplementing: #aMessage  	"an OrderedCollection()"
	SystemNavigation default allClassesImplementing: #aClassMethod  "an OrderedCollection()"
	SystemNavigation default allClassesImplementing: #aCanvas  	"an OrderedCollection()"

* Ensuite, il faut s'amuser avec la longueeeeeee liste de vocabulaire proposé par Pharo.
Au moins, le lecteur n'est pas perdu, car c'est par ordre alphabétique.

Playground >
	SystemNavigation default allSentMessages size "44394"

Test : 	
	SystemNavigation default allSentMessages 
	Debut "an IdentitySet(#dirtyPackages #primSubArray: #ffiGetBitmap:fromOutline: #navigationViews #exampleBlockNested #okToDoSlice #onConflictUseLoaded #selectedPathName #markFullyClean: #initializeX86Stdcall: 
	Fin #isShowColumnHeaders #reverseNodesDo: #itemDepth #axis #issue12027 #tolower #mouseOverAllowed #getNext: #fixBytesForMono: #versionInfo #macRomanMapping #deprecated:transformWith: #isReferenced #tex...etc..."

	SystemNavigation default aCategory	> CTRL+P > Instance of SystemNavigation did not understand #aCategory
	SystemNavigation default aClassName 	> CTRL+P > Instance of SystemNavigation did not understand
	SystemNavigation default allAccesses  	> CTRL+P > Instance of SystemNavigation did not understand
	SystemNavigation default allActions	> CTRL+P > Instance of SystemNavigation did not understand
	SystemNavigation default allBranches	> CTRL+P > Instance of SystemNavigation did not understand

* Donc, tu peux y passer toute l'année à chercher dans la liste alphabétique.


Playground >	
	(SystemNavigation default allUnsentMessagesIn: Object selectors) size "38"

* Il a mis quelques secondes pour afficher "38". :-(
* La parenthèse permet d'afficher un résultat numérique, tandis que le code ci-dessous c'est la liste des méthodes.

* C'est incompréhensible, l'instance renvoie "38" alors que lorsque je m'arrête de compter à "38" les méthodes
de la classe "Object", le curseur n'est qu'au début du volet.
Cela implique un plus grand nombre de méthodes, mais combien utilise le message ? -> allUnsentMessagesIn: 

Test : 

	SystemNavigation default allUnsentMessagesIn: Object selectors 			> CTRL+P > "#(#gtInspectorActionSpot #setPinned: #newCallbackWithSignature:block: #deprecated:transformWith:when: #removeAction:forEvent: #copyTwoLevel #fullDisplayString #crLog: #inspectInExternalWindow #link:toTemporary: #enclosedSetElement #gtInspectorEProportiesIn: #retryWithGC:until: #actionForEvent:ifAbsent: #logCr #deprecated:on:in:transformWith:when: #isEpEvent #actionsDo: #asSetElement #logExecution #logExit #isRectangle #link:toMethodNamed: #phlowValue:value: #spotterPreviewRawIn: #gtDebuggerEvaluatorIn: #logCrTab: #fuelOut #phlowValue:withEnoughArguments: #removeActionsSatisfying: #storeAt:inTempFrame: #gtDebuggerRawIn: #haltIfNotTest #printDirectlyToDisplay #trace #logEntry #haltIfTest #isPinned)"
	SystemNavigation default allUnreferencedClassVariables Object selectors 	> CTRL+P > Instance of SystemNavigation did not understand
	SystemNavigation default allUnreferencedClassVariablesOf: Object selectors 	> CTRL+P > Warning - The method SystemNavigation>>#allUnreferencedClassVariablesOf: called from UndefinedObject>>#DoIt has been deprecated. just all allUnreferencedClassVariables on the class Select Proceed to continue, or close this window to cancel the operation.
	SystemNavigation default allUnreferencedInstanceVariables Object selectors	> CTRL+P > Instance of System xxxx

	
Playground >
	SystemNavigation default allUnimplementedCalls size	> CTRL+P > "280"

Test : 
	SystemNavigation default allUnimplementedCalls 		> CTRL+P > 
	Debut "#(#'AbstractTool removeMethod:inClass: calls: removeEmptyUnclassifiedCategoryFrom: removeNonLocalSelector: ' #'AccessorInstanceVariableSlotTest testAccessorInstanceVariableSlot calls: slot1: slot1 ' 'Alien class libcName calls: osVersion ' 'Alien class ensureNotifiedAtStartup calls: 
	Fin	createConfiguration ' #'WorkingCopyToolBar setSliceButton calls: createSlice ' #'WriteOnceSlotTest testRead calls: slot1 ' #'WriteOnceSlotTest testWriteTwice calls: slot1: slot1 ' #'WriteOnceSlotTest testWriteAndRead calls: slot1: slot1 ')"

	SystemNavigation default allUnreferencedClassVariables		> CTRL+P > Instance of System xxxx
	SystemNavigation default allUnreferencedInstanceVariables	> CTRL+P > Instance of System xxxx
	SystemNavigation default allUnselectedItems			> CTRL+P > Instance of System xxxx
	SystemNavigation default allUnsentMessages			> CTRL+P > Instance of System xxxx

* Cette fois, tu ne cherches pas toute l'année, car tu es limité à quelques lignes sans résultats.


"Notez que les messages implémentés mais non envoyés ne sont pas nécessairement inutiles, 
car ils peuvent être envoyés implicitement (par exemple, en utilisant perform:)."

Playground >
	SystemNavigation default perform: Object selectors 		> CTRL+P > Instance of System xxxx
	SystemNavigation default perfomr: #yourself			> CTRL+P > Instance of System xxxx
	(SystemNavigation default perform: Object selectors) size	> CTRL+P > Instance of System xxxx


Rechercher : peform:
------------

Object>>#perform:with:with:with:with:.
Object>>#perform:withArguments:inSuperclass:.


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------
"Les messages envoyés mais non implémentés sont cependant plus problématiques, 
car les méthodes d'envoi de ces messages échouent au moment de l'exécution. 
Ils peuvent être le signe d'une implémentation inachevée, d'API obsolètes ou de bibliothèques manquantes."


"Figure 14-4 Parcourir toutes les implémentations de  ifTrue:."

Playground >
	SystemNavigation default browseAllImplementorsOf: #ifTrue: > CTRL+P > Implementors of ifTrue: (4)


"Point allCallsOn renvoie tous les messages envoyés explicitement à Point en tant que récepteur."
* Il sait perdu le "Point allCallsOn" !

* Bon, ci-dessous j'ai quand même trouvé une commande qui donne un résultat, 
mais est-ce que c'est "les messages envoyés explicitement à "Point" en tant que récepteur ?


Playground >
	SystemNavigation default Point allCallsOn 			> CTRL+P > Instance of System xxxx
	SystemNavigation default allCallsOn Point 			> CTRL+P > Instance of System xxxx
	SystemNavigation default allUnsentMessagesIn: allCallsOn Point 	> CTRL+P > #allCallsOn is missing, and does not understand #Point
	
	SystemNavigation default allUnsentMessagesIn: Point allCallsOn	> CTRL+P >
	Debut "an OrderedCollection(AthensAffineTransform>>#transform: AthensAffineTransform>>#transformX:Y: BehaviorTest>>#testMethodsAccessingSlot BehaviorTest>>#testWhichSelectorsAccess BehaviorTest>>#testIncludesMethod 
	Fin GLMEastDirection>>#* GLMNorthDirection>>#* GLMSouthDirection>>#* GLMVector>>#offset GLMWestDirection>>#* RGReadOnlyImageBackendTest>>#testSlots RGReadOnlyImageBackendTest>>#testBehavior)"

	²SystemNavigation default allUnsentMessagesIn: Point		> CTRL+P > Unknown character ->


--------------------------------------- Intermède : Debut

"parcourir par programme tous les implémenteurs du message ifTrue: "

Playground >
	SystemNavigation default browseAllImplementorsOf: #ifTrue:

* Après un copié et collé de la commande ci-dessus, c'est alors que je me suis dit : 
"Aie, on te l'as déjà faite celle-là ! "

-> Figure 14-4

--------------------------------------- Intermède : Fin


D09:44 16/05/2021 - F12:50 - Chapitre 14 - p.220/259 FR 321/376 EN
-------------------------------------------------------------------------------------------------------16/05/2021 fin




-------------------------------------------------------------------------------------------------------17/05/2021 debut
D11:01 17/05/2021 - F00:00 - Chapitre 14 - p.220/259 FR 321/376 EN
D11:01 17/05/2021 - F13:34 - Chapitre 14 - p.221/259 FR 322/376 EN

Ces méthodes sont particulièrement utiles :

browserAllSelect:
browseMethodsWithSourceString:matchCase: 


package 			sous-classe		instanceVN	classe			protocol	méthode
---------------------------------------------------------------------------------------------------------------------------------------------------------
System-Support-Image	Object  #SystemNavigation	environment	(c)SystemNavigation	instance side	browserAllSelect:
												extensions
System-Support-Image	Object  #SystemNavigation	environment	(c)SystemNavigation	instance side	browseMethodsWithSourceString:matchCase:
												extensions
---------------------------------------------------------------------------------------------------------------------------------------------------------

"deux façons différentes de parcourir toutes les méthodes du système qui effectuent des super envois 
(la première est plutôt la force brute, la seconde est meilleure et élimine certains faux positifs)"

Code : 
------

Playground >
SystemNavigation default browseMethodsWithSourceString: 'super' matchCase: true.> DoIt (CTRL+P) > "a ClyOldMessageBrowserAdapter"
 	- Ouvre la fenêtre "Methods containing 'super' (case-sensitive) (6472)

SystemNavigation default browseAllSelect: [:method | method sendsToSuper].	> DoIt (CTRL+P) > "a ClyOldMessageBrowserAdapter"
	- Ouvre la fenêtre "Selected messages (5339)

* À force, c'est comme avoir un carnet d'adresses et c'est carrément un carnet.


11:22 17/05/2021 - 14.3
------------------------
Evalutation de "Point"

- Figure 14-5 Inspecteur sur la classe Point et le bytecode de sa méthode # *.

"l'inspecteur montre la structure de la classe Point. 
Vous pouvez voir que la classe stocke ses méthodes dans un dictionnaire, les indexant par leur sélecteur. 
Le sélecteur # * pointe vers le bytecode décompilé de Point>>*.

* Je constate qu'il pointe vers le bytecode "Compile" de "Point>>#*.
Donc, ce n'est pas "décompilé" et "Point>>*.

"? Comment - 
CompiledMethod instances can be in two forms:
- up until Pharo 6, they encode both the method and the inner closures bytecodes and literals.
- since Pharo 6, they encode only the method's bytecodes and literals."

Playground >
	Point > InspectIt (CTRL+I)> Inspector on a Point class (Point)
		|
	a Point class (Point)
		|-> Raw ()methodDict - a MethodDictionary (103 items) (size 103)
			|
		a MethodDictionary (103 items) (size 103)
			|-> Items #* - Point>>#*
				|
			a CompiledMethod (Point>>#*)
				|-> () self - Point>>#* 


 - Figure 14-6 -  Classes, dictionnaires de méthodes et méthodes compilées


"relation entre les classes et les méthodes." : C'est aussi opaque qu'une marre à canard.
---------------------------------------------


MetaClass

--------- (?)

* Depuis Inspector -> Meta -> Class Hierarchy : Class -> Methods : Tout ce qui est indiqué dans le livret n'existe pas dans l'inspecteur.
* Est-ce que ça correspond à "Class Hierarchy" ?

(c)Class
	selectors		(inexistant)
	superclass		(inexistant)
	compiledMethodAt:	(inexistant)
	compiler		(inexistant)	


--------- (?)

* Depuis Inspector -> Meta -> Class Hierarchy : ClassDescription -> Methods : name et category = inexistant.
* Est-ce que ça correspond à "Inspector -> Raw -> name, category" ?  

ClassDescription
	name			(inexistant)
	category		(inexistant)

---------(?)

* Depuis Inspector -> Meta -> Class Hierarchy : Behavior -> Methodes : superclass(ok), new(ok), compile(ok),
								addSelector:withMethod:(ok), removeSelector:(ok)
* Pourquoi lorsque j'interroge "Behavior" depuis l'inspecteur 
toutes les méthodes sont-elles présentes contrairement à "Class" ?

(c)Behavior
	superclass
	------------
	new
	compile:
	addSelector:withMethod:
	removeSelector:

---------

(m)methodDict
	|-> MethodDictionary

---------

* Il existe la classe "MethodDictionary" et la méthode "methodDictionary". 
* Depuis Inspector -> Meta -> Class Hierarchy : Behavior -> Methodes : methodDictionary
* Lorsque je lance une recherche "Wildcard filtering (e.g., "'pattern*")" avec "method" ou "Metho" alors s'affiche "methodDictionary". (?)
* En fait, "Behavior" interroge la méthode "methodDict", lorsque le résultat est "nil" alors "une nouvelle classe - "MethodDictionary" est créée.
* SystemBrowser -> MethodDictionary -> protocol -> at:(no), keys(no)

a MethodDictionary
MethodDictionary
	at: 			(inexistant)
	at:put:
	keys 			(inexistant)
	removeKey:ifAbsent:

---------

	*

---------

(cm)a CompiledMehod
(c)CompiledMethod					(m)methodClass (pr)accessing
	sendsToSuper		(inexistant)		methodClass
	methodReference					"answer the class that I am installed in"
	getSource		(inexistant)		^self classBinding value
	valueWithReceiver:arguments:			 |
							\|/
---------

(m)methodClass


---------

(c)Behavior
	superclass
	------------
	new
	compile:
	addSelector:withMethod:
	removeSelector:




-------------------- HAUT - DEBUT


* Mise à jour : 10:45 18/05/2021
Figure 14-6 Classes, method dictionaries and compiled methods

* Lire du bas vers le haut.


		(c)Behavior
		superclass
		new
		compile:
		addSelector:withMethod:
		removeSelector:
		  /|\ 	
		   |
	* Rien n'explique le passage de "(m)methodClass" vers "(c)Behavior" ou l'une de ses classes. (?)
		  /|\ 	
		   |
		(m)methodClass
		methodClass
		"answer the class that I am installed in"
		^self classBinding value
		  /|\ 	
		   |
	* Rien n'explique le passage de "(c)CompiledMethod" vers "(m)methodClass". 	(?)
	* "methodReference" utilise "(m)methodClass" et renvoie vers une variable "class". (?) 
	* "methodReference" renvoie également vers la variable "selector". 		(?)
		  /|\ 	
		   |
		(cm)a CompiledMethod	-> (c)CompiledMethod = 202 méthodes
		sendsToSuper			(?)
		methodReference			methodReference
		getSource			(?)
		valueWithReceiver:arguments:	valueWithReceiver:arguments:
		  /|\ 	
		   |
	* Rien n'explique le passage de "(cm)a MethodDictionary" -> "(c)MethodDictionary" vers
	"(cm)a CompiledMethod -> (c)CompiledMethod". (?) ((m)compiledMethod - (pr)*Reflectivity, (m)isCompiledMethod - (pr)testing, 
		  /|\ 	
		   |
		(cm)a MethodDictionary -> (c)MethodDictionary
		at:				(?)
		at:put:			at:put:
		keys 				(?)
		removeKey:ifAbsent:	removeKey:ifAbsent:
		  /|\ 	
		   |
--------------------------------- Ce qui se passe après "methodDict".

		(m)methoDict renvoie vers "(c)MethodDictionary).
		
		methodDict
		^ methodDict ifNil: [ MethodDictionary new ]

		Important : 
		-----------
		Il existe "(m)methoDict, (c)MethodDictionary, (m)methodDictionary).

--------------------------------- Ce qui se passe avant "methodDict".
		  /|\ 	
		   |
		(c)Behavior
		superclass
		new
		compile:
		addSelector:withMethod:
		removeSelector:
		  /|\ 	
		   |
	* Rien n'explique le passage de "name, category" vers "(c)Behavior". (?)
		  /|\ 	
		   |
		ClassDescription
		name 				(?)
		category 			(?)
		  /|\ 	
		   |
	* Rien n'explique le passage de "Class" vers "ClassDescription". (?)
	Peut-être le "protocole " superclass, ce n'est pas clair. 	(?)
	* Tandis que "MetaClass", n'en parlons pas. 			(?)
		/\     |\	
	       /	 \
	MetaClass	Class
			selectors		(?)
			superclass		(?)
			compiledMethodAt:	(?)
			compiler		(?)


-------------------- BAS - FIN


"Dans la figure 14-6, nous voyons que les classes et les métaclasses ont en commun superclass behavior."
* La suite n'est pas très claire.

* Où se situe "Inpector" ?

* En résumé, c'est aussi opaque qu'une marre à canard.
* En résumé, c'est aussi opaque que l'océan Atlantique rempli d'armes de la Seconde Guerre mondiale. (Phare, Pharo, océan)

D11:01 17/05/2021 - F13:34 - Chapitre 14 - p.221/259 FR 322/376 EN
-------------------------------------------------------------------------------------------------------17/05/2021 fin




-------------------------------------------------------------------------------------------------------18/05/2021 debut
D10:24 18/05/2021 - F00:00 - Chapitre 14 - p.221/259 FR 322/376 EN
D10:24 18/05/2021 - F13:15 - Chapitre 14 - p.221/259 FR 324/376 EN

- 10 mns 12:07 18/05/2021 - 12:17 18/05/2021
- 10 mns 12:46 18/05/2021 - 12:56 18/05/2021

* Il faudrait créer un tableau réunissant les codes et suggestions à retenir.
	- Relire l'ensemble des notes et/ou livret,
	- Étant donné la longueur des notes, ça va prendre beaucoup de temps.
	- Laisse tomber = prise de tête = pas kisscool

Recherche :  mappe
[INFORMATIQUE] Mettre en correspondance (un ensemble de valeurs) avec un autre ensemble de valeurs. Mapper un fichier.

"Chaque classe a un dictionnaire de méthodes, qui mappe les sélecteurs de méthode aux méthodes compilées."
	
	- Class 1 Behavior -> methodDic -> MethodDictionary -> selecteurs de méthode <-> correspondance <-> méthodes compilées
	- Class 2 ? -> methodDic -> MethodDictionary -> selecteurs de méthode <-> correspondance <-> méthodes compilées
	- Class 3 ? -> methodDic -> MethodDictionary -> selecteurs de méthode <-> correspondance <-> méthodes compilées
	- Class 4 ? -> methodDic -> MethodDictionary -> selecteurs de méthode <-> correspondance <-> méthodes compilées


* Mise à jour : 10:45 18/05/2021
Figure 14-6 Classes, method dictionaries and compiled methods

11:10 18/05/2021
"Nous pouvons exploiter les relations entre les classes et les méthodes pour poser des requêtes sur le système."
"Par exemple, pour découvrir quelles méthodes sont nouvellement introduites dans une classe donnée, 
c'est-à-dire ne pas surcharger les méthodes de superclasse, nous pouvons naviguer de la classe au dictionnaire de méthodes"

Code : 
------

Playground >
[:aClass| aClass methodDict keys select: [:aMethod | (aClass superclass canUnderstand: aMethod) not ]] value: SmallInteger > CTRL+P > "#(#rfPlus: #hashMultiply #printStringBase:nDigits: #threeDigitName #byteAt:put: #isLarge #rfMinus: #highBitOfPositiveReceiver #byteAt: #unpackFromArity:)"

-----------------DEBUT code 
* (cm)aClass 	-> Implementors = choose a class to browse
	|	-> Senders = (c)RGMethodDefinitionTest, (m)testArgumentNamesNonExistingMethodWithSource
	|
	(c)Class-> (pa)Kernel-Classes, ClassDescription, (sb)#Class, (IntsVarNa)subclasses, name, classPool, sharedPools, environment, category.
	    |
	    |----> (pr)methodDict
			|	
			(?)
			|
* (m)methodDict	  (m)methodDict	-> Implementors (3)
				-> Senders (73)
	|	
	(?)
	|
* (m)keys	-> Implementors (10)
		-> Senders (201)
		-> (Class - classVarNames) (?), (Class - fileOutPool:onFileStream:) (?)
		-> 

* (m)aMethod	-> Implementors (1)
	|	-> Senders (2)
 	|
	(?)Method-> Implementors = choose a class to browse
		-> Senders = There are not Senders of Method
-----------------FIN code 


Réponse du code : 
-----------------

#rfPlus: 			-> Implementors (1) - SmallInteger
				-> Senders (1)	    - (c)Process

#hashMultiply 			-> Implementors (3) - SmallInteger x1
				-> Senders (16)	    - SmallInteger x1

#printStringBase:nDigits: 	-> Implementors (1) - SmallInteger
				-> Senders (1)	    - SmallInteger

#threeDigitName 		-> Implementors (1) - SmallInteger
				-> Senders (2)	    - SmallInteger x1
	
#byteAt:put: 			-> Implementors (10)- SmallInteger x1
				-> Senders (32)	    - SmallInteger x2

#isLarge 			-> Implementors (2)- SmallInteger x1
				-> Senders (3)	   - NumberParser x3

#rfMinus: 			-> Implementors (1) - SmallInteger
				-> Senders (1)	    - (c)Process
		
#highBitOfPositiveReceiver 	-> Implementors (1) - SmallInteger 
				-> Senders (4)	    - SmallInteger x2

#byteAt:		 	-> Implementors (11) - SmallInteger x1
				-> Senders (93)	    - SmallInteger x1 - SmallIntegerTest x1

#unpackFromArity:	 	-> Implementors (2) - SmallInteger x1
				-> Senders (2)	    - (c)ExternalAddress, (c)FFIFunctionArgumentLoader

- 10 mns 12:07 18/05/2021 - 12:17 18/05/2021

Playground >
[:aClass| aClass methodDict keys select: [:aMethod | (aClass superclass canUnderstand: aMethod) not ]] value: SmallInteger > CTRL+P > "#(#rfPlus: #hashMultiply #printStringBase:nDigits: #threeDigitName #byteAt:put: #isLarge #rfMinus: #highBitOfPositiveReceiver #byteAt: #unpackFromArity:)"

* Plus simple ?

* Renvoie toutes les méthodes en plus de celle du dessus.
SmallInteger methodDict

- 10 mns 12:46 18/05/2021 - 12:56 18/05/2021

"L'une de ces méthodes est isAbstract (qui indique si la méthode envoie la sous-classe-Responsabilité ). 
Nous pouvons l'utiliser pour identifier toutes les méthodes abstraites d'une classe abstraite."

isAbstrat
not

Playground >
[:aClass| aClass methodDict keys select: [:aMethod | (aClass>>aMethod) isAbstract ]] value: Number >

[:aClass| aClass methodDict keys select: [:aMethod | (aClass superclass canUnderstand: aMethod) not ]] value: SmallInteger > 

"parcourir les super-envois dans une hiérarchie donnée, par exemple dans le Hiérarchie des collections,"

* Magnifique /---- = Boum !  Au lieu d'aller vers le plus simple, ça va vers le plus absurde.

Playground >
class := Collection.
SystemNavigation default
browseMessageList: (class withAllSubclasses gather: [:each |each methodDict associations select: [:assoc | assoc value sendsToSuper]
thenCollect: [:assoc | RGMethodDefinition realClass: each selector: assoc key]])
name: 'Supersends of ', class name, ' and its subclasses'

* Super ! 
* Je suis étonné qu'il faille utiliser autant de code pour afficher trois résultats.
* Étant donné qu'il y a des objets partout et que la syntaxe tient sur une carte postale, 
pourquoi n'est-il pas possible d'utiliser un mot et un objet pour avoir des résultats similaires ?

D10:24 18/05/2021 - F13:15 - Chapitre 14 - p.221/259 FR 324/376 EN
-------------------------------------------------------------------------------------------------------18/05/2021 fin




-------------------------------------------------------------------------------------------------------19/05/2021 debut
D10:51 19/05/2021 - F00:00 - Chapitre 14 - p.221/259 FR 324/376 EN
D10:51 19/05/2021 - F13:32 - Chapitre 14 - p.224/259 FR 327/376 EN

- 8 mns - 11:31 19/05/2021 - 11:39 19/05/2021
- 15 mns 12:56 19/05/2021 - 13:11 19/05/2021

14.4 Environnements de navigation

"Action-click" (?) - Rechercher "Browse scoped".
	- "Browse scoped" -> N'existe pas.

* Volet package, 
	- clic droit sur le package "Kernel" 
		-> "Browse dependencies" -> Analysis of 1 package(s)

-> Affiche -> Kernel -> Dependent packages : 27 | Dependencies : 320 (+1 extension dependencies)
	- clic droit sur le package "Kernel"
		-> "Browse scoped dependencies -> 

-> Volet de gauche sous "Analysis of 1 package -> Clic sur Kernel pour faire apparaître les classes.
	- Recherche la classe "Point"

-> Recherche "Analyze > Class refs"
	"Analyser> Class var refs" ou "Analyze > Class refs"
		p. 98 FR 142 EN
		Finding variable references
		"en sélectionnant  Analyser> Inst var références ... ou  Analyser> Class var refs"
		Aucun "Analyser", c'est seulement "Class refs." (CTRL + N).

		10:55 09/11/2020 - vid 11:08 09/11/2020
		88. Chap.7 - p. 98 FR 142 EN - Finding variables references
		Dans ce chapitre, entre l'explication, la figure 7-12 et le résultat rien ne correspond. 
		1. "Analyse" inexistant depuis le volet classe, mais "Class refs." disponible.

- 8 mns - 11:31 19/05/2021 - 11:39 19/05/2021

"Comparez ce résultat avec la recherche depuis un navigateur sans portée restreinte."
* Étant donné qu'"Analyse > Class refs" est inexistant, alors je passe à autre chose.
Une capture cela aurait été un plus.

 
"Les environnements de navigateur peuvent également être créés par programmation."

Code : 
------

((RBBrowserEnvironment new forClasses: (Collection
withAllSubclasses))
selectMethods: [:method | method sendsToSuper])
browse.

Playground >
((RBBrowserEnvironment new forClasses: (Collection withAllSubclasses)) selectMethods: [:method | method sendsToSuper]) browse. > CTRL+P > "a ClyFullBrowser(850571264)"
* Ouvre la fenêtre de "SystemBrowser" et affiche la classe "RBSelectorEnvironment".

"trouver uniquement les méthodes qui envoient un super message différent par programme"

((RBBrowserEnvironment new forClasses: (Collection
withAllSubclasses))
selectMethods: [:method |
method sendsToSuper
and: [(method parseTree superMessages includes: method selector)
not]])
browse

Playground >
((RBBrowserEnvironment new forClasses: (Collection withAllSubclasses)) selectMethods: [:method | method sendsToSuper and: [(method parseTree superMessages includes: method selector) not]]) browse > CTRL+P > "a ClyFullBrowser(454616064)"


"Jetez un œil au protocole d'interrogation "querying" de la classe RBProgramNode pour voir certaines choses que nous pouvons demander aux arbres d'analyse."
* Je suis complètement perdu, en passant du coq à l'âne.
	- superMessages


Figure 14-7 Finding methods

Code : 
-----

MessageBrowser browse: ((RBBrowserEnvironment new forClasses:
(Collection withAllSubclasses))
selectMethods: [:method |
method sendsToSuper
and: [(method parseTree superMessages includes: method selector)
not]]) methods
title: 'Collection methods sending different super'

Playground >
MessageBrowser browse: ((RBBrowserEnvironment new forClasses: (Collection withAllSubclasses)) selectMethods: [:method | method sendsToSuper and: [(method parseTree superMessages includes: method selector) not]]) methods
title: 'Collection methods sending different super' > CTRL+P > 
Fenêtre "Warning" 
The method SpPresenter>>#title: called from MessageBrowser class>>#browse:title: has been deprecated.
With Spec 2, SpPresenter was refactored to move all window management to WindowPresenter.
From now on, if you want ot interact with a window you need to: 
	- Implement #initializeWindow: method (#initializeDialog: for dialogs) to manage window elements before
the presenter is opened
	- Use the method #window or #withWindowDo: to interact with windows after it has been opened.
Select Proceed to continue, or close this window to cancel the operation.

* Suppression du message "title".
Playground >
MessageBrowser browse: ((RBBrowserEnvironment new forClasses: (Collection
withAllSubclasses)) 
   selectMethods: [:method | 
	    method sendsToSuper and: [(method parseTree superMessages includes: method selector) not]]) methods > CTRL+P > "a SpWindowPresenter"
* Ouvre la fenêtre "Message Browser (12)

* Ouais, super ! :-( passons à autre chose.


12:29 19/05/2021
14.5 Accéder au contexte d'exécution
-------------------------------------

"En fait, le contexte d'exécution d'une méthode d'exécution se trouve dans la machine virtuelle - 
ce n'est pas du tout dans l'image !"

	Machine Virtuelle	Image
	Contexte d'exécution

"Modifiez la définition de Integer>>factorial en insérant l'expression 
"thisContext inspect. self halt." comme indiqué ci-dessous :"

* Celle-ci permet d'inspecter "thisContext inspect.", et de faire un "breakpoints" avec le débogueur "self halt.".

Playground>
	factorial > CTRL+M implementors of factorial >

Modifié
factorial
"Answer the factorial of the receiver."
self = 0 ifTrue: [thisContext inspect. self halt. ^ 1].
self > 0 ifTrue: [^ self * (self - 1) factorial].
self error: 'Not valid for negative integers'

Défaut
factorial
	"Answer the factorial of the receiver."

	self = 0 ifTrue: [^ 1].
	self > 0 ifTrue: [^ self * (self - 1) factorial].
	self error: 'Not valid for negative integers'


"Évaluez maintenant 3 factorielles"

Playground >
		3 factorial > CTRL+P > Ouvre deux fenêtres 
						- Halt
						- Inspector on a Context (SmallInteger(Integer)>>factorial)

"L'inspection de "a Context" vous donne un accès complet au contexte d'exécution actuel, 
à la pile, aux tempories et arguments locaux, à la chaîne des expéditeurs et au récepteur."
		- pile 			(?)
		- tempories 		(?)
		- arguments locaux 	(?)

* C'est bien beau, mais ça donne quoi comme "accès complet" en réalité, concrètement ? (?)

- 15 mns 12:56 19/05/2021 - 13:11 19/05/2021


Code : 
------

"évaluer l'expression suivante pour découvrir quelles méthodes utilisent thisContexte"

Playground >
SystemNavigation default browseMethodsWithSourceString: 'thisContext' matchCase: true > CTRL+P > Methods containing 'thisContext' (case-sensitive) (249)

"applications les plus courantes consiste à découvrir l'expéditeur d'un message."

	""Ce message définit un cadre pour le comportement des sous-classes de la classe. 
	Annoncez que la sous-classe aurait dû implémenter ce message.""

Playground >
subclassResponsibility
"This message sets up a framework for the behavior of the class'
subclasses.
Announce that the subclass should have implemented this message."
SubclassResponsibility signalFor: thisContext sender selector > CTRL+P > #subclassResponsibility is missing, and does not understand #SubclassResponsibility


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------
"Par convention, les méthodes qui envoient self subclassResponsibility sont considérées comme abstraites."

"Mais comment Object >> subclassResponsibility fournit-il un message d'erreur utile indiquant 
quelle méthode abstraite a été invoquée ? 
Très simplement, en demandant thisContext à l'expéditeur."

"SubclassResponsibility signalFor: thisContext sender selector"

* C'était expéditif, succinct, avec des questions en suspend et c'est passer plus de temps à "comprendre"
les interrelations que coder, créer.

D10:51 19/05/2021 - F13:32 - Chapitre 14 - p.224/259 FR 327/376 EN
-------------------------------------------------------------------------------------------------------19/05/2021 fin




-------------------------------------------------------------------------------------------------------20/05/2021 debut
D10:38 20/05/2021 - F00:00 - Chapitre 14 - p.224/259 FR 327/376 EN
D10:38 20/05/2021 - F13:48 - Chapitre 14 - p.225/259 FR 329/376 EN

- 10 mns - 12:57 20/05/2021 - 13:07 20/05/2021
- 14 mns - 13:09 20/05/2021 - 13:23 20/05/2021
- 11 mns - 12:31 20/05/2021 - 13:42 20/05/2021

Points d'arrêt intelligents
----------------------------

* Point d'arrêt -> self halt = auto-arrêt.

réification : [PHILOSOPHIE] Transformation en chose.

"Malheureusement, cela pose des problèmes pour les méthodes qui sont intensivement utilisées dans le système."
"Supposons, par exemple, que nous voulons explorer l'exécution de  Morph >> open-InWorld. 
La définition d'un point d'arrêt dans cette méthode est problématique.
Faites attention, l'expérience suivante va tout casser ! Prenez une nouvelle image xxxxxxxx"

* Inutile, car l'astuce consiste à cliquer sur la croix (en haut à droite) puis répondre au message :
"Pharo Virtual Machine - Quit Pharo Virtual Machine without saving ?" Yes :-)

Code :
------

Morph >> openInWorld
"Add this morph to the world."
self halt.
self openInWorld: self currentWorld

Playground >
	openInWorld > CTRL+M > Vérifier qu'il s'agit de "Morph>> openInWorld > modifier le code 

Défaut
openInWorld
        "Add this morph to the world."

        self openInWorld: self currentWorld


* Ajout de "self halt." après le commentaire.
Modifié
Morph >> openInWorld
"Add this morph to the world."
self halt.
self openInWorld: self currentWorld


* Autre modification par rapport à "factorial".
* Ajout de "thisContext inspect. self halt." après "self openInWorld".
Modifié
Morph >> openInWorld
"Add this morph to the world."
self openInWorld: thisContext inspect. self halt. self currentWorld


* Concernant l'ancien code ci-dessous qui a été modifié, il a été mis de côté.
Doit-on le remettre par défaut ou le laisser ?

Modifié
factorial
"Answer the factorial of the receiver."
self = 0 ifTrue: [thisContext inspect. self halt. ^ 1].
self > 0 ifTrue: [^ self * (self - 1) factorial].
self error: 'Not valid for negative integers'

* Pour FirstnameLastname mettre LObjetVivantcoule

"Remarquez comment votre image se fige immédiatement dès que vous essayez d'ouvrir un nouveau Morph (Menu / Fenêtre / ...) !"
"Notice how your image immediately freezes as soon as you try to open any new Morph (Menu/Window/...)!"

* Il a fallu quelques secondes pour que Pharo se fige, sans avoir eu le temps d'ouvrir un nouveau Morph.
"nouveau Morph (?) Menu/Window/... (?)"
Le sablier (souris) est apparu au bout d'une minute.

* D'ailleurs, je ne comprends pas comment ouvrir un nouveau Morph par "Menu/Window/..." ? Encore une manière d'envoyer le lecteur dans l'écume.
* Cela aurait été plus simple d'indiquer "Morph new openInWorld.".

D10:53 29/04/2021 - F13:22 - Chapitre 12 - p.177/259 FR 258/376 EN
Pour tester votre nouveau morph, exécutez :  CrossMorph new openInWorld.

Code : 
-----

* Affiche un carré bleu dans Pharo.
Playground >
	Morph new openInWorld. CTRL+P > "a Morph(1023401984)"

* Second test 
Modifié
Morph >> openInWorld
"Add this morph to the world."
self openInWorld: thisContext inspect. self halt. self currentWorld

Playground >
	openInWorld > CTRL+M > ajout de "self openInWorld: thisContext inspect. self halt. self currentWorld"

* Pour FirstnameLastname mettre LObjetVivantcoule

* Il s’est figé immédiatement après l'enregistrement.


* Je refais le 1 test.
-----------------------

* Ouverture d'un Morhp.
Playground >
	Morph new openInWorld. CTRL+P >

* Modification du code.
Playground >
	openInWorld > CTRL+M > ajout de "self halt."

Modifié
Morph >> openInWorld
"Add this morph to the world."
self halt.
self openInWorld: self currentWorld

* Pour FirstnameLastname mettre LObjetVivantcoule

* Contrairement au début, cette fois il s'est figé après l'enregistrement.


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------
"un moyen de s'arrêter conditionnellement que si nous sommes dans un contexte d'intérêt. 
C'est exactement ce que propose Object >> haltIf:."


"Supposons maintenant que nous ne voulions nous arrêter que si openInWorld est envoyé depuis, 
par exemple, le contexte de MorphTest >> testOpenInWorld."

Code : 
------

Defaut 
openInWorld
"Add this morph to the world."

self openInWorld: self currentWorld

* Modification du code.
Playground >
	openInWorld > CTRL+M > ajout de "self haltIf: #testOpenInWorld."

Modifié
Morph>>openInWorld
"Add this morph to the world."
self haltIf: #testOpenInWorld.
self openInWorld: self currentWorld

* Le Morhp s'ouvre.
Playground >
	Morph new openInWorld. CTRL+P > 

* C'est tout de même curieux. 
Maintenant, il met le code permettant de tester un Morhp contrairement à tout à l'heure : (Menu/Window/...).

"Cette fois, l'image ne se fige pas. Essayez d'exécuter le MorphTest."
 MorphTest run:#testOpenInWorld.

* Du coup, je n'ai pas du tout utilisé la même commande de test.
Comme quoi le lecteur est laissé dans le vague ou sur le banc de touche.

* La commande "MorphTest run:#testOpenInWorld.", ouvre le débogueur contenant la modification précédente.

Méthode : haltIf: 
-----------
Kernel-Objects - cVN: DependentsFields - iVN: '' - (sc): #Object - ProtoObject - (c) Object - (pr)instance side, (pr)halting - (m)haltIf:

* La surprise est de constater la méthode "haltIf:", qui se décompose en deux entités "Halt" et "if:".
Puis, "halt" ne commence plus par une minuscule et "If" par une majuscule et le tout se disloque.
Ensuite, il faut savoir qu'"Halt" devient une classe.
Mais que devient "if:" ? 

Bonne question.

"if:", devient une méthode, mais pas n'importe laquelle puisque c'est une méthode côté classe.
Elle n'est plus rattachée à la classe "Object", ni au package "Kernel-Objects".
Plutôt au package "Kernel", à la classe "Halt" et aux protocoles "class side" et "halting".


p. 225 FR 328 EN
"Cette méthode elle-même vérifiera si la condition est un symbole"
"This method itself will check if the condition is a symbol"

Object >> haltIfCallChainContains: aSelector

* Je ne comprends par, car le code de "if:" indique une "condition" ? Réponse dessous.
"[ ^ self haltIfCallChain: thisContext home sender contains: condition ]"

* Il faut lire l'ensemble du code de "if:" qui indique une condition est un symbole si c'est vrai.
LocalRecursionStopper during: [ condition isSymbol ifTrue: [ ^ self haltIfCallChain: thisContext home sender contains: condition ].

* Je ne comprends pas "Object >> haltIfCallChainContains: aSelector", car il s'agit d'un symbole au lieu d"un "aSelector" ?
D'autre part, il s'agit de "if:" et non de "haltIfCallChainContains:" ?
Du reste "haltIfCallChainContains:" n'existe pas, par contre celui-ci existe "haltIfCallChain:contains:"  
 
* Je constate du désordre mental qu'occasionnent toutes ces peintures Pharo. (haltIf: -> Halt -> if: -> haltIfCallChainContains: -> haltIfCallChain:contains:)  

Code : if: copie code if:
------
if: condition
	<debuggerCompleteToSender>
	"This is the typical message to use for inserting breakpoints during 
	debugging.
	
	The argument can be one of the following:
		- a block: if the Block has one arg, the calling object is bound to that.
		- an expression
 		- a selector: Halt if found in the call chain"
	LocalRecursionStopper during: [ 
		condition isSymbol ifTrue: [ ^ self haltIfCallChain: thisContext home sender contains: condition ].


En résumé : 
-----------
 
* Ce lit de la gauche à droite étant donné qu'il s'agit de décrire par exemple la méthode "haltIf:".
(méthode -> protocol -> classe -> ? -> sous-classe -> instanceVN -> classVN -> package)

(m)haltIf: - (pr)halting, (pr)instance side - (c) Object - ProtoObject - (sc): #Object - iVN: '' - cVN: DependentsFields - Kernel-Objects
	|
	|-> (c)Halt - Halt clas - iVN: '' - Kernel (*depuis if:)
	|-> (c)Halt - Exception - (sc) #Halt - iVN: '' - cVN: '' - Kernel-Exceptions (*depuis playground->Implementors)
		|
		|-> (m)if: - (pr)halting, (pr)class side - (c)Halt - class - iVN: '' - (*n'affiche plus rien d'autre.)
		|-> (m)if: = code :  ^ self haltIfCallChain: thisContext home sender contains: condition].
					|
 					|-> (m)haltIfCallChain:contains: - (pr)private, (pr)class side - (c)Halt - class - iVN: '' - (*n'affiche plus rien d'autre.)
					|-> (m)haltIfCallChain:contains: = code : haltIfCallChain: haltSenderContext contains: aSelector

* Je passe mon temps à essayer de comprendre les relations entre tous ces concepts.
On est loin de la simple syntaxe sur une carte postale.

12:55 20/05/2021
14.6 Interception de messages non compris

- 10 mns - 12:57 20/05/2021 - 13:07 20/05/2021
- 14 mns - 13:09 20/05/2021 - 13:23 20/05/2021


Recherche :  doesNotUnderstand:
----------
doesNotUnderstand: : Il peut être utile de remplacer doesNotUnderstand: pour fournir un autre comportement.

Playground >
	doesNotUnderstand: > CTRL+M - Implementors > Implementors of doesNotUnderstand: (36)

13:29 20/05/2021
Proxys légers
-------------

* Je n'ai rien compris. C'est une période ou je n'ai plus envie de faire l'effort de comprendre.

- 11 mns - 12:31 20/05/2021 - 13:42 20/05/2021

* procuration : Pouvoir qu’une personne donne à une autre d’agir en son nom dans une circonstance déterminée.

* Houla, c'est parti pour une création d'un proxy léger. 
Je laisse tomber pour aujourd'hui et un autre jour je me prendrais de nouveau la tête.

D10:38 20/05/2021 - F13:48 - Chapitre 14 - p.225/259 FR 329/376 EN
-------------------------------------------------------------------------------------------------------20/05/2021 fin




-------------------------------------------------------------------------------------------------------24/05/2021 debut
D10:16 24/05/2021 - F00:00 - Chapitre 14 - p.225/259 FR 329/376 EN
D10:16 24/05/2021 - F00:00 - Chapitre 14 - p.226/259 FR 330/376 EN

- 10 mns - 11:01 24/05/2021 - 11:11 24/05/2021
- 20 mns - 13:35 24/05/2021 - 13:55 24/05/2021
- 7 mns - 13:55 24/05/2021 - 14:02 24/05/2021


Proxys légers
-------------

1 cas - Introduction -> objet minimal -> agir (proxy) -> objet existant

			objet minimal
				|
			* procuration
				|
			* pratiquement aucune méthode
				|
		       ---- messages ----
mesures spéciales -----|	|	|----- déléguer au sujet réel
				|
			doesNotUnderstand

* procuration : Pouvoir qu’une personne donne à une autre d’agir en son nom dans une circonstance déterminée.
* pratiquement : Presque. Voiture pratiquement neuve. C’est pratiquement la même chose. Il n’y avait pratiquement personne.

Code : Proxy légers
------

Nom : LoggingProxy 
-----


Package
-------

ProtoObject subclass: #LoggingProxy
instanceVariableNames: 'subject invocationCount'
classVariableNames: ''
package: 'PBE-Reflection'


Question : 
----------
* Pourquoi rattaché à "ProtoObject" plutôt" que "Object" ? Car précédemment, il a été fait allusion à un "objet minimal"
ou un "objet existant" qui porte à confusion puisque tout est objet.


Réponse : juste après mon interrogation !
---------
Note that we subclass ProtoObject rather than Object because we do not want our proxy to inherit around 400 methods (!) from Object.
Notez que nous sous-classes ProtoObject plutôt que Object car nous ne voulons pas que notre proxy hérite d'environ 400 méthodes (!) D'Object.


Code : 
------

Object methodDict size "'443'"

* Il interroge la méthode "methodDict" située dans la classe "Behavior" qui est rattachée (hérite) à la classe "Object".


Question : 
----------
* Donc, le nombre de méthodes par "héritages" avec ProtoObject est restreint.
Alors, pourquoi ne pas "désolidariser" le proxy de tous héritages par principe de précaution et la sécurité du programme ? 

- 10 mns - 11:01 24/05/2021 - 11:11 24/05/2021

* Outre les méthodes, reste à savoir quels sont les autres "condiments" qui vont être hérités de "ProtoObject" !


Package : 
---------
ProtoObject subclass: #LoggingProxy
instanceVariableNames: 'subject invocationCount'
classVariableNames: ''
package: 'PBE-Reflection'

"Notre proxy a deux variables d'instance: le "subject" est un proxy pour, et un "count" du nombre de messages qu'il a interceptés."

* Ci-dessus indique "count" alors qu'il s'agit de "invocationCount", il faut s'attendre à une surprise.


Schémas LoggingProxy : 1
---------------------

	(pa)PBE-Reflection -------------
		|			|
	(c)ProtoObject			|
		|			|- Création du package
	(sc)#LoggingProxy		|
		|			|
	(iVN)subject 	     		|
	(iVN)invocationCount -----------
		|
	(c)LoggingProxy ---------------- - Après l'enregistrement du package
		|
	Nouvelle Inst. side method ----- -  Création de l'Initialization des deux variables
		|
	initialize --------------------- - "initialize" contenant les variables


* Lorsque le package "PBE-Reflection" est créé, alors la classe "LoggingProxy" apparaît.


A.
"Nous initialisons les deux variables d'instance"
iniitialisons : [INFORMATIQUE] Affecter une valeur initiale à. Initialiser une variable.

invocationCount := 0.
subject := self.

B.
"nous fournissons un accesseur pour le nombre de messages."

LoggingProxy >> initialize

C.
"Initialement, la variable "subject" pointe vers l'objet proxy lui-même."

subject := self. -> LoggingProxy


Code : 
------

LoggingProxy >> initialize
invocationCount := 0.
subject := self.


Schémas LoggingProxy : 2
---------------------


	(pa)PBE-Reflection -------------
		|			|
	(c)ProtoObject			|
		|			|- Création du package
	(sc)#LoggingProxy		|
		|			|
	(iVN)subject 	     1 		|
	(iVN)invocationCount 2 ---------
		|
	(c)LoggingProxy ---------------- - Après l'enregistrement du package
		|
	Nouvelle Inst. side method ----- - Création de l'Initialization des deux variables
		|
	initialize --------------------- - "initialize" contenant les variables
	invocationCount := 0. ---------- - variable 2
	subject := self. --------------- - variable 1 pointe vers l'objet proxy ? 
		|
	(pr)initialization ------------- - protocole
	(pr)overrides ------------------ - protocole
		|
	(m)initialize ------------------ - méthode



Questions : 
----------
* Pourquoi les variables sont-elles inversées après la création de l'accesseur ? Peut-on les inverser que ce soit 
à partir du "package" ou de l'"accesseur" ?

* La variable "subject" pointe vers l'objet "proxy" lui-même ? ((c)LoggingProxy, (sc)#LoggingProxy)


Code : 
------

LoggingProxy >> invocationCount
^ invocationCount


Schémas LoggingProxy : 3
---------------------


	(pa)PBE-Reflection -------------
		|			|
	(c)ProtoObject			|
		|			|- Création du package
	(sc)#LoggingProxy		|
		|			|
	(iVN)subject 	     1 		|
	(iVN)invocationCount 2 ---------
		|
	(c)LoggingProxy ---------------- - Après l'enregistrement du package
		|
	Inst. side method -------------- - Création de l'Initialization des deux variables
		|
	initialize --------------------- - "initialize" contenant les variables
	invocationCount := 0. ---------- - variable 2
		|				|-> Affectation. := affecte un objet à une variable.
		|
	subject := self. --------------- - variable 1 pointe vers l'objet proxy ? 
		|				|-> self - pseudo-variable
		|				|-> Le récepteur. self est un mot clé qui fait référence à l'objet à l'intérieur duquel la méthode 
		|				|	actuelle s'exécute. Nous l'appelons «le récepteur» parce que cet objet a reçu le message
		|				|	qui a entraîné l'exécution de la méthode. self est appelé une «pseudo-variable»
		|				|	car nous ne pouvons pas l'assigner.
		|				|
		|				|-> Affectation. := affecte un objet à une variable.  
		|
	(pr)initialization ------------- - protocole
	(pr)overrides ------------------ - protocole
		|
	(m)initialize ------------------ - méthode
		|
	Inst. side method -------------- - Création d'un accesseur
		|
	invocationCount ---------------- - Fournis un accesseur pour le nombre de messages
	^ invocationCount -------------- - méthode
		|				|-> Retour de méthode. ^ est utilisé pour renvoyer une valeur à partir d'une méthode. 
		|
	(pr)accessing ------------------ - protocole - accesseur
		|
	(c)invocationCount ------------- - méthode


Questions : 
-----------
1.
* "invocationCount := 0." -> := affecte un objet à une variable alors que "0" est un (entier décimal, argument) et non un objet, mais la confusion instaure que tout est objet ?

2.
* Le package n'hérite pas d'"Object" mais la pseudo-variable "self" fait référence à l'objet à l'intérieur duquel la méthode actuelle s'exécute ?
De mon point de vue, on revient au même point que d'hériter d'environ 400 méthodes d'"Object".

"Notez que nous sous-classes ProtoObject plutôt que Object car nous ne voulons pas que notre proxy hérite d'environ 400 méthodes (!) D'Object."


------------------------------------------Syntaxe DEBUT

p. 53 FR 75 EN
Chapitre 4 - La syntaxe en bref - Syntax in a nutshell

self - pseudo-variable

Le récepteur. self est un mot clé qui fait référence à l'objet à l'intérieur duquel la méthode actuelle s'exécute. 
Nous l'appelons «le récepteur» parce que cet objet a reçu le message qui a entraîné l'exécution de la méthode. 
self est appelé une «pseudo-variable» car nous ne pouvons pas l'assigner.

Affectation. : = affecte un objet à une variable.  

Retour de méthode. ^ est utilisé pour renvoyer une valeur à partir d'une méthode. 

------------------------------------------Syntaxe FIN


"Nous interceptons simplement tous les messages non compris, les imprimons dans le script Tran , 
mettons à  jour le nombre de messages et transmettons le message au vrai sujet."

Code : 
------

LoggingProxy >> doesNotUnderstand: aMessage
Transcript show: 'performing ', aMessage printString; cr.
invocationCount := invocationCount + 1.
^ aMessage sendTo: subject


Schémas LoggingProxy : 4
---------------------


	(pa)PBE-Reflection -------------
		|			|
	(c)ProtoObject			|
		|			|- Création du package
	(sc)#LoggingProxy		|
		|			|
	(iVN)subject 	     1 		|
	(iVN)invocationCount 2 ---------
		|
	(c)LoggingProxy ---------------- - Après l'enregistrement du package
		|
	Inst. side method -------------- - Création de l'Initialization des deux variables
		|
	initialize --------------------- - "initialize" contenant les variables
	invocationCount := 0. ---------- - variable 2
		|				|-> Affectation. := affecte un objet à une variable.
		|
	subject := self. --------------- - variable 1 pointe vers l'objet proxy ? 
		|				|-> self - pseudo-variable
		|				|-> Le récepteur. self est un mot clé qui fait référence à l'objet à l'intérieur duquel la méthode 
		|				|	actuelle s'exécute. Nous l'appelons «le récepteur» parce que cet objet a reçu le message
		|				|	qui a entraîné l'exécution de la méthode. self est appelé une «pseudo-variable»
		|				|	car nous ne pouvons pas l'assigner.
		|				|
		|				|-> Affectation. := affecte un objet à une variable.  
		|
	(pr)initialization ------------- - protocole
	(pr)overrides ------------------ - protocole
		|
	(m)initialize ------------------ - méthode
		|
	Inst. side method -------------- - Création d'un accesseur
		|
	invocationCount ---------------- - Fournis un "accesseur - accessing - protocole" pour le nombre de messages
	^ invocationCount -------------- - méthode
		|				|-> Retour de méthode. ^ est utilisé pour renvoyer une valeur à partir d'une méthode. 
		|
	(pr)accessing ------------------ - protocole - accesseur
		|
	(c)invocationCount ------------- - méthode
		|
	Inst. side method -------------- - Création d'un intercepteur de messages non compris
		|
	doesNotUnderstand:
	aMessage
	Transcript show: 'performing ', aMessage printString; cr.
	invocationCount := invocationCount + 1.
	^ aMessage sendTo: subject
		|
	(pr)instance side -------------- - protocole
	(pr)reflective operations ------ - protocole
	(pr)overrides ------------------ - protocole
		|
	(m)doesNotUnderstand: ---------- - méthode
		|

Questions : 
-----------

1.
* "doesNotUnderstand:" est implémenté trente-sept fois et relié à "Object" et "ProtoObject", hérite-t-il des trente-sept objets ou seulement de ProtoObjet ?
Ou alors seulement "ProtoObject" et "Object" ?

"Notez que nous sous-classes ProtoObject plutôt que Object car nous ne voulons pas que notre proxy hérite d'environ 400 méthodes (!) D'Object."



* La classe miroir "aMessage" renvoie vers la classe "Message", relié à "Object" et même question que la "1" ?


Codes : 
-------

Object methodDict size. "443"
ProtoObject methodDict size. "57"


-------------------------------------------------------------------------------CODES TESTS DEBUT
Codes : TEST
------------

Behavior allSuperclasses 
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own isBehavior ] ] >  "an OrderedCollection(Object)"

(c)Point
Point whichSelectorsAccess: 'x'		> CTRL+P > "#(#'\\' #asNonFractionalPoint #min: #translateBy: #asFloatPoint #adhereTo: #setR:degrees: #hash #rightRotated #< #roundDownTo: #/ #deepCopy #truncated #asIntegerPoint #normal #isFloatPoint #'>=' #sign #negated #distanceTo: #- #'//' #onLineFrom:to:within: #flipBy:centerAt: #octantOf: #> #normalized #= #ceiling #setX:setY: #dist: #scaleFrom:to: #reciprocal #x #+ #truncateTo: #closeTo: #theta #quadrantOf: #abs #floor #bitShiftPoint: #max: #dotProduct: #* #scaleBy: #rounded #transposed #isZero #roundTo: #printOn: #isIntegerPoint #roundUpTo: #bearingToPoint: #leftRotated #crossProduct: #nearestPointAlongLineFrom:to: #fromSton: #stonOn: #grid: #degrees #sortsBefore: #'<=')"
Point whichSelectorsAccess: 'y'	

Playground >
	Rectangle allClassVarNames  		"#(#DependentsFields)"
	Rectangle allInstVarNames  		
	Rectangle allMethods  			>
	Rectangle allSelectors  		>	

	Rectangle allSharedPools  		>

	Rectangle allSuperclasses  		"an OrderedCollection(Object ProtoObject)"
	Rectangle allSubclasses  		"an OrderedCollection(CharacterBlock)"
	Rectangle allSubInstances  		>


	Rectangle basicIdentityHash  		"4315"
	Rectangle classVarNames  		"#()"
	Rectangle dependentClasses 		"{SmallInteger. Margin. Object. Rectangle class. Rectangle. Array}"

	Rectangle isVariable  				"false"
	Rectangle instVarNames  			"#(#origin #corner)"

	Rectangle protocols  			> CTRL+P > "#(#'*OSWindow-SDL2' #'*Athens-Core' #accessing #transforming #'truncation and round off' #'*Spec2-Layout' #private #'rectangle functions' #converting #'*Fuel-Core' #testing #printing #fmp #comparing #'*Spec-Core' #'*Morphic-Base' #'*Rubric' #'truncation and roundoff' #'self evaluating')"
	CircleMorph protocols  			> CTRL+P > "#(#geometry #'rotate scale and flex' #initialization #accessing #menus #'geometry etoy')"
	Rectangle properties    			"nil"

	Rectangle realClass  			> "Rectangle"

	Rectangle subclassDefinerClass  	> CTRL+P > "OpalCompiler"
	Rectangle superclass  					"Object"
	Rectangle startUp  					"Rectangle"
	Rectangle spaceUsed  					"9227"
	Rectangle sourceCodeTemplate  		>
	Rectangle slots
	Rectangle sharedPoolNames 

	Rectangle selectors  			>

	Rectangle typeOfClass			> CTRL+P > "#normal"
	Rectangle usingMethods  		> CTRL+P > 

	Rectangle whichClassIncludesSelector: #inspect	> CTRL+P > "Object"
	Rectangle withAllSubclasses  		>
	Rectangle withAllSuperAndSubclasses	>



"SystemNavigation est une façade qui prend en charge diverses méthodes utiles 
pour interroger et parcourir le code source du système. 
La valeur par défaut de SystemNavigation renvoie une instance que vous pouvez utiliser pour naviguer dans le système."
Playground >
	SystemNavigation default allClassesImplementing: #yourself 

Playground >
	SystemNavigation default allSentMessages size
Playground >	
	(SystemNavigation default allUnsentMessagesIn: Object selectors) size
Playground >
	SystemNavigation default allUnimplementedCalls size	> 

"Figure 14-4 Parcourir toutes les implémentations de  ifTrue:."
Playground >
	SystemNavigation default browseAllImplementorsOf: #ifTrue: > 


"Point allCallsOn renvoie tous les messages envoyés explicitement à Point en tant que récepteur."
Playground >
	SystemNavigation default allUnsentMessagesIn: Point allCallsOn	>

"deux façons différentes de parcourir toutes les méthodes du système qui effectuent des super envois 
(la première est plutôt la force brute, la seconde est meilleure et élimine certains faux positifs)"
Playground >
SystemNavigation default browseMethodsWithSourceString: 'super' matchCase: true.> DoIt (CTRL+P) > "a ClyOldMessageBrowserAdapter"
 	- Ouvre la fenêtre "Methods containing 'super' (case-sensitive) (6472)

SystemNavigation default browseAllSelect: [:method | method sendsToSuper].	> DoIt (CTRL+P) > "a ClyOldMessageBrowserAdapter"
	- Ouvre la fenêtre "Selected messages (5339)


"Nous pouvons l'utiliser pour identifier toutes les méthodes abstraites d'une classe abstraite."
Playground >
[:aClass| aClass methodDict keys select: [:aMethod | (aClass>>aMethod) isAbstract ]] value: Number >

[:aClass| aClass methodDict keys select: [:aMethod | (aClass superclass canUnderstand: aMethod) not ]] value: SmallInteger > 


"parcourir les super-envois dans une hiérarchie donnée, par exemple dans le Hiérarchie des collections,"
Playground >
class := Collection.
SystemNavigation default
browseMessageList: (class withAllSubclasses gather: [:each |each methodDict associations select: [:assoc | assoc value sendsToSuper]
thenCollect: [:assoc | RGMethodDefinition realClass: each selector: assoc key]])
name: 'Supersends of ', class name, ' and its subclasses'

-------------------------------------------------------------------------------CODES TESTS FIN

- 20 mns - 13:35 24/05/2021 - 13:55 24/05/2021
- 7 mns - 13:55 24/05/2021 - 14:02 24/05/2021

D10:16 24/05/2021 - F00:00 - Chapitre 14 - p.226/259 FR 330/376 EN
-------------------------------------------------------------------------------------------------------24/05/2021 fin




-------------------------------------------------------------------------------------------------------/05/2021 debut
D17:06 24/05/2021 - F00:00 - Chapitre 14 - p.226/259 FR 330/376 EN
D17:06 24/05/2021 - F17:26 - Chapitre 14 - p.226/259 FR 330/376 EN


17:01 24/05/2021
* Faire des recherches sur l'"accesseur".
 - Méthode d'accesseur côté classe uniqueInstance -> p.77 FR
 - Créer dynamiquement des accesseurs -> p.227 FR

p.46 FR
"Un getter a toujours le même nom que la variable correspondante et un setter est nommé de même, mais avec une fuite « : », d' où 
mouseAction  et  mouseAction: . Collectivement, setters et getters sont appelés  accesseur méthodes et par Conven tion , ils
doivent être placés dans l'  Accès   protocole. Dans Pharo, toutes les variables d'instance sont privées de l'objet qui les possède,
donc le seul moyen pour un autre objet de lire ou d'écrire ces variables est d'utiliser des méthodes d'accesseur comme celle-ci. En
fait, les variables d'instance sont également accessibles dans les sous-classes."

p.73 FR
"Certains développeurs préfèrent accéder aux variables d'instance uniquement via des accesseurs. 
Cette pratique a une certaine valeur, mais elle encombre également l'interface de vos classes, 
et pire, elle expose son état privé au monde."

p.73 FR
"Toutes les méthodes sont publiques et virtuelles (c'est-à-dire recherchées dynamiquement)."


D17:06 24/05/2021 - F17:26 - Chapitre 14 - p.226/259 FR 330/376 EN
-------------------------------------------------------------------------------------------------------/05/2021 fin




-------------------------------------------------------------------------------------------------------25/05/2021 debut
D07:16 25/05/2021 - F00:00 - Chapitre 14 - p.226/259 FR 330/376 EN
D07:16 25/05/2021 - F11:27 - Chapitre 14 - p.226/259 FR 330/376 EN



-18 mns - 08:32 25/05/2021 - 08:50 25/05/2021
-16 mns - 09:20 25/05/2021 - 09:36 25/05/2021
-25 mns - 10:34 25/05/2021 - 10:59 25/05/2021


Mise à jour "Schémas LoggingProxy.

Schémas LoggingProxy : 4
---------------------


	(pa)PBE-Reflection -------------
		|			|
	(c)ProtoObject			|
		|			|- Création du package
	(sc)#LoggingProxy		|
		|			|
	(iVN)subject 	     1 		|
	(iVN)invocationCount 2 ---------
		|
	(c)LoggingProxy ---------------- - Après l'enregistrement du package
		|
	Inst. side method -------------- - Création de l'Initialization des deux variables
		|
	initialize --------------------- - "initialize" contenant les variables
	invocationCount := 0. ---------- - variable 2
		|				|-> Affectation. := affecte un objet à une variable.
		|
	subject := self. --------------- - variable 1 pointe vers l'objet proxy ? 
		|				|-> self - pseudo-variable
		|				|-> Le récepteur. self est un mot clé qui fait référence à l'objet à l'intérieur duquel la méthode 
		|				|	actuelle s'exécute. Nous l'appelons «le récepteur» parce que cet objet a reçu le message
		|				|	qui a entraîné l'exécution de la méthode. self est appelé une «pseudo-variable»
		|				|	car nous ne pouvons pas l'assigner.
		|				|
		|				|-> Affectation. := affecte un objet à une variable.  
		|
	(pr)initialization ------------- - protocole
	(pr)overrides ------------------ - protocole
		|
	(m)initialize ------------------ - méthode
		|
	Inst. side method -------------- - Création d'un accesseur
		|
	invocationCount ---------------- - Fournis un "accesseur - accessing - protocole" pour le nombre de messages
	^ invocationCount -------------- - méthode
		|				|-> Retour de méthode. ^ est utilisé pour renvoyer une valeur à partir d'une méthode. 
		|
	(pr)accessing ------------------ - protocole - accesseur
		|
	(c)invocationCount ------------- - méthode
		|
	Inst. side method -------------- - Création d'un intercepteur de messages non compris
		|
	doesNotUnderstand:
	aMessage
	Transcript show: 'performing ',- - Cascade de message "Transcript show: , cr." 
	aMessage printString; cr. ------ - (cm)aMessage : méthode mirroir, printString : affiche le message à l'écran
	invocationCount := invocationCount + 1. - (?) 
				|-> ---- - Affectation. := + 1 et "invocationCount" lui même ?
	^ aMessage sendTo: subject ----- - "subject" est envoyé à (cm)aMessage ?
		|				|-> Retour de méthode. ^ est utilisé pour renvoyer une valeur à partir d'une méthode. 
		|				|-> 1 subject -> 2 aMessage -> 3 ^ ou 1 aMessage -> 2 subject -> 3 ^ ?
		|
	(pr)instance side -------------- - protocole
	(pr)reflective operations ------ - protocole
	(pr)overrides ------------------ - protocole
		|
	(m)doesNotUnderstand: ---------- - méthode
		|


Questions : 
-----------

1.
"^ aMessage sendTo: subject".
Si comme l'énoncé l'indique "le retour de méthode ^ est utilisé pour renvoyer une valeur à partir d'une méthode 
alors la classe miroir "aMessage" envoie le message à la variable "subject" qui renvoie celui-ci au "Retour de méthode" ?

		^ aMessage sendTo: subject 
			1 ------>---- 2
		3 -----------<---------		

2.
Messages Pharo : (Transcript global variable usage) - Why Global Variables Should Be Avoided When Unnecessary	
D'un côté, on t'indique de ne pas employer des variables globales, mais elles sont mises en oeuvre sur 
un "proxy" considéré comme programme vulnérable.
Ce n'est pas un Phare qu'il faut, mais des sauveteurs en mer.

3.
"Use cascaded nextPutAll:'s instead of #, in #nextPutAll:."
Les messages s'enchaînent et il s'agit là d'un "proxy léger".


Interrogation :
---------------

À ce stade, je ne comprends pas comment fonctionne ce "proxy léger", parce que ça envoie des messages à droite et à gauche, mais où se trouve l'interface,
les options réseau, journal, etc. ?


07:57 25/05/2021  * Tests de commandes - Playground

Playground >
LoggingProxy allSuperclasses 
select: [ :each | | subject | subject := (each instVarNamed: 'subject'). own isNotNil and: [ subject doesNotUnderstand: ] ] > Variable or expression expected ->

LoggingProxy allSuperclasses 
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own doesNotUnderstand:  ] ] > Variable or expression expected ->

LoggingProxy allSuperclasses 
select: [ :each | | initialize | initialize := (each instVarNamed: 'subject'). initialize isNotNil and: [ initialize doesNotUnderstand:  ] ]  > Variable or expression expected ->

LoggingProxy allSuperclasses 
select: [ :each | | initialize | initialize := (each instVarNamed: 'invocationCount'). initialize isNotNil and: [ initialize doesNotUnderstand:  ] ] > Variable or expression expected ->

LoggingProxy whichSelectorsAccess: 'x' > "#()"

Playground >
	LoggingProxy allClassVarNames  		> "#()"
	LoggingProxy allInstVarNames  		> "#(#subject #invocationCount)"
	LoggingProxy allMethods  		>  "{ProtoObject>>#primitiveFailed:. ProtoObject>>#rfIsEqual:. ProtoObject>>#'=='. ProtoObject>>#mustBeBooleanDeOptimizeIn:. ProtoObject>>#glamourValueWithArgs:. ProtoObject>>#becomeForward:copyHash:. ProtoObject>>#ifNotNil:ifNil:. ProtoObject>>#largeIdentityHash. ProtoObject>>#gtDebuggerPresentationsIn:inContext:. ProtoObject>>#flag:. ProtoObject>>#instVarsInclude:. ProtoObject>>#withArgs:executeMethod:. LoggingProxy>>#doesNotUnderstand:. ProtoObject>>#gtInspectorActionBrowse. ProtoObject>>#fuelPointsTo:. ProtoObject>>#nextInstance. ProtoObject>>#executeMethod:. ProtoObject>>#gtInspectorPresentationsFromPragmas:In:inContext:. ProtoObject>>#ifNil:. ProtoObject>>#allSelectorsToTestInMethodFinder. ProtoObject>>#cannotInterpret:. ProtoObject>>#gtInspectorIcon. LoggingProxy>>#invocationCount. ProtoObject>>#gtDebuggerEvaluatorIn:. ProtoObject>>#become:. ProtoObject>>#modificationForbiddenFor:index:value:. ProtoObject>>#asGlamorousMultiValue. ProtoObject>>#gtInspectorRawIn:. ProtoObject>>#gtInspectorMetaIn:. ProtoObject>>#pointersTo. ProtoObject>>#isNil. ProtoObject>>#basicIdentityHash. ProtoObject>>#pointsTo:. ProtoObject>>#mustBeBooleanCompileExpression:andCache:. ProtoObject>>#becomeForward:. ProtoObject>>#glamourValue:. ProtoObject>>#gtInspectorPresentationsIn:inContext:. ProtoObject>>#gtDebuggerRawIn:. ProtoObject>>#'~~'. LoggingProxy>>#initialize. ProtoObject>>#gtInspectorActions. ProtoObject>>#rearmOneShot. ProtoObject>>#ifNotNil:. ProtoObject>>#pointersToExcept:. ProtoObject>>#asGlamorousArray. ProtoObject>>#rFwithArgs:executeMethod:. ProtoObject>>#class. ProtoObject>>#primitiveFailed. ProtoObject>>#doOnlyOnce:. ProtoObject>>#primitiveFail. ProtoObject>>#modificationForbiddenFor:value:. ProtoObject>>#mustBeBoolean. ProtoObject>>#metaLinkOptions. ProtoObject>>#identityHash. ProtoObject>>#nextObject. ProtoObject>>#mustBeBooleanIn:. ProtoObject>>#tryPrimitive:withArgs:. ProtoObject>>#ifNil:ifNotNil:}"

	LoggingProxy allSelectors  		> "an IdentitySet(#primitiveFailed: #rfIsEqual: #'==' #mustBeBooleanDeOptimizeIn: #glamourValueWithArgs: #becomeForward:copyHash: #ifNotNil:ifNil: #largeIdentityHash #gtDebuggerPresentationsIn:inContext: #flag: #instVarsInclude: #withArgs:executeMethod: #doesNotUnderstand: #gtInspectorActionBrowse #fuelPointsTo: #nextInstance #executeMethod: #gtInspectorPresentationsFromPragmas:In:inContext: #ifNil: #allSelectorsToTestInMethodFinder #cannotInterpret: #gtInspectorIcon #invocationCount #gtDebuggerEvaluatorIn: #become: #modificationForbiddenFor:index:value: #asGlamorousMultiValue #gtInspectorRawIn: #gtInspectorMetaIn: #pointersTo #isNil #basicIdentityHash #pointsTo: #mustBeBooleanCompileExpression:andCache: #becomeForward: #glamourValue: #gtInspectorPresentationsIn:inContext: #gtDebuggerRawIn: #'~~' #initialize #gtInspectorActions #rearmOneShot #ifNotNil: #pointersToExcept: #asGlamorousArray #rFwithArgs:executeMethod: #class #primitiveFailed #doOnlyOnce: #primitiveFail #modificationForbiddenFor:value: #mustBeBoolean #metaLinkOptions #identityHash #nextObject #mustBeBooleanIn: #tryPrimitive:withArgs: #ifNil:ifNotNil:)"	

	LoggingProxy allSharedPools  		> "an OrderedCollection()"

	LoggingProxy allSuperclasses  		> "an OrderedCollection(Object ProtoObject)"
	LoggingProxy allSubclasses  		> "an OrderedCollection()"
	LoggingProxy allSubInstances  		> "an OrderedCollection()"


	LoggingProxy basicIdentityHash  	> "9454"
	LoggingProxy classVarNames  		> "#()"
	LoggingProxy dependentClasses 		> "{ProtoObject. LoggingProxy}"

	LoggingProxy isVariable  		> "false"
	LoggingProxy instVarNames  		> "#(#subject #invocationCount)"

	LoggingProxy protocols  		> "#(#'reflective operations' #accessing #initialization)"
	LoggingProxy properties    		> "nil"

	LoggingProxy realClass  		> "LoggingProxy"

	LoggingProxy subclassDefinerClass  	> "OpalCompiler"
	LoggingProxy superclass  		> "ProtoObject"
	LoggingProxy startUp  			> "LoggingProxy"
	LoggingProxy spaceUsed  		> "187"
	LoggingProxy sourceCodeTemplate  	> "'messageSelectorAndArgumentNames
	""comment stating purpose of instance-side message""
	""scope: class-variables  &  instance-variables""	
			
	| temporary variable names |
	statements'"
	
	LoggingProxy slots			> "{#subject => InstanceVariableSlot. #invocationCount => InstanceVariableSlot}"

	LoggingProxy sharedPoolNames 		> "an OrderedCollection()"
	LoggingProxy selectors  		> "#(#initialize #doesNotUnderstand: #invocationCount)"

	LoggingProxy typeOfClass		> "#normal"
	LoggingProxy usingMethods  		> "an OrderedCollection()"

	LoggingProxy whichClassIncludesSelector: #inspect 	> "nil"
	LoggingProxy whichClassIncludesSelector: #subject 	> "nil"
	LoggingProxy whichClassIncludesSelector: #invocationCount > "LoggingProxy"
	LoggingProxy withAllSubclasses  	> "an OrderedCollection(LoggingProxy)"
	LoggingProxy withAllSuperAndSubclasses	> "an OrderedCollection(ProtoObject LoggingProxy)"

"SystemNavigation est une façade qui prend en charge diverses méthodes utiles pour interroger et parcourir 
le code source du système. La valeur par défaut de SystemNavigation renvoie une instance que vous pouvez utiliser 
pour naviguer dans le système."
Playground >
	SystemNavigation default allClassesImplementing: #subject	  	> "an OrderedCollection(AthensSimpleTreeNode CDTraitCompositionNode ClassOrganization MailMessage RGTraitTransformation TaSingleComposition ZnServerGenericLogEvent)"
	SystemNavigation default allClassesImplementing: #invocationCount 	> "an OrderedCollection(LoggingProxy)"
	SystemNavigation default allClassesImplementing: #LoggingProxy		> "an OrderedCollection()"
	SystemNavigation default allClassesImplementing: #doesNotUnderstand 	>  "an OrderedCollection()"
	SystemNavigation default allClassesImplementing: #initialize		> "an OrderedCollection(AColorSelectorMorph AbstractCache AbstractEnvironmentTestCase AbstractFont class AbstractFontSelectorDialogWindow AbstractFormButtonPresenter AbstractMessageCentricBrowser AbstractMethodReferenceConverter AbstractResizerMorph AbstractWidgetPresenter AbstractWorldRenderer AbstractWorldRenderer class AdvancedHelpBrowserDummy Alien Alien class AlignmentMorph AlphaImageMorph AnimatedImageFrame AnimatedImageMorph AnnotationUserExample AnnouncementMockC AnnouncementSetWithExclusions Announcer Archive ArchiveMember AsClassRule AssertEqualSignIntoAssertEquals AsyncFile class AthensAffineTransform AthensBackgroundChange AthensBalloonImagePaint AthensBalloonSurface AthensBezierConverter AthensBezierConverter class AthensCairoDefinitions class AthensCairoMatrix AthensCairoPath AthensCairoPatternPaint AthensCairoStrokePaint AthensCairoSurface AthensCairoText AthensCanvas class AthensCanvasWrapper AthensCompositeStrokePaint AthensCurveFlattener AthensCurveFlattener class AthensDemoMorph AthensDisplayScanner AthensFlakeDemo AthensFontDescription AthensPathBuilder class AthensSceneView AthensShadowPaint AthensSimplePathBuilder AthensStrokePaint AthensTextLine AthensTextRenderer AthensTextScanner AthensTigerShape AthensWorldMorph AthensWrapWorldMorph AthensWrappedWorldDisplay AtomicQueueItem AtomicSharedQueue Author BIConfigurableFormatter BIConfigurableFormatter class BIPrettyPrinterContext BalloonBezierSimulation class BalloonCanvas BalloonEngine BalloonEngine class BalloonEngineConstants class BalloonMorph BalloonMorph class Base64MimeConverter Base64MimeConverter class BasicCommandLineHandler BasicCommandLineHandler class Beacon BeaconSignal Behavior Behavior class BitBlt class Bitmap class BorderedMorph BracketMorph BracketSliderMorph Breakpoint Breakpoint class BrowseDebugAction ButtonPresenter ByteString class ByteTextConverter class CDBehaviorDefinitionNode CDNode CP1250TextConverter class CP1252TextConverter class CP1253TextConverter class CPUWatcher class CacheStatistics CacheWeight CairoBackendCache CairoFontFace CairoFontMetricsProvider CairoFontOptions CairoFreetypeFontRenderer CairoScaledFont CairoUTF8Converter CalendarDayMorph CalendarMorph CalendarPresenter Callback class Categorizer class ChangeSet ChangeSet class ChangeSorterModel class ChangeSorterPresenter Character class CharacterScanner CharacterScanner class CharacterSet CheckBoxExample CheckboxButtonMorph CheckboxMorph ChooseDropListDialogWindow ChronologyConstants class ChunkFileFormatParser CircleMorph CircularMemoryLogger ClapCommand ClapCompositeMatch ClapContext ClapParameter ClapParameterized ClapPharoVersion ClapValidationReport ClassAPIHelpBuilder ClassAnnotation ClassAnnotationRegistry ClassFactoryForTestCase ClassOrganization Clipboard Clipboard class ClyActiveBreakpointsQuery ClyActivityAnimationIconMorph ClyAllProblemMethodQuery ClyAsyncQuery ClyBrowserButtonMorph ClyBrowserContext ClyBrowserItem ClyBrowserMorph ClyBrowserQueryCache ClyBrowserToolMorph ClyBrowserToolbarItemMorph ClyClassGroup ClyClassHierarchy ClyClassHierarchyMap ClyClassHierarchyScope ClyClassWithScripts class ClyCollapsedDataSource ClyCompositeTestResultProperty ClyConcreteCritiqueMethodGroup ClyConstantMethodQuery ClyCriticEnvironmentPlugin ClyCursorPositionLabelMorph ClyDataSource ClyDataSourceUpdateScheduler ClyDesiredSelection ClyEnvironmentPlugin class ClyExpandedDataSource ClyFilteringCritiqueQuery ClyFormatAsReadSwitchMorph ClyFullBrowser ClyFullEnvironmentUpdateStrategy ClyHierarchicallySortedClasses ClyInheritanceAnalysisEnvironmentPlugin ClyItemCellMorph ClyLongQueryExample ClyMainItemCellMorph ClyMergedHierarchy ClyMethodEditorToolMorph ClyMethodGroup ClyMethodTagsAndPackageEditorMorph ClyMethodVisibilityMorph ClyNavigationEnvironment ClyNavigationHistory ClyOldMessageBrowserAdapter ClyOldMessageBrowserQuery ClyProjectManagerRegistry ClyQuery ClyQueryBrowser ClyQueryBrowserFilter ClyQueryResult ClyQueryResultMetadata ClyQueryViewMorph ClyRing2Environment ClyScopeCompoBox ClySortFunction ClySortSystemItemFunction ClyStatusBarItemMorph ClyStatusBarMorph ClySubstringPattern ClySystemEnvironment ClyTabManager ClyTableFilterFactory ClyTestResultProperty ClyTextEditingMode ClyTextEditorToolMorph ClyTextMorphToolMorph ClyToolbarMorph ClyToolbarSeparatorMorph ClyUnknownQueryResult ClyUnknownScope CmBlockCommand CmCommand CmCommandAborted CmCommandGroup CmCommandsCollector CmFakeCommand CmUICommand CmUICommandGroup CmdMenu CmdMenuCommandActivationStrategy CmdMenuGroup CmdMouseCommandActivation CmdWorldMenuRegistration class CodeImporter CollectionElement class Color class ColorChooserMorph ColorPresenterMorph ColorSelectorDialogWindow CommandLineArguments CommandLineHandler CommandLineTestRunner CommandLineUIManager CompilationContext CompilationContext class CompiledMethod class CompiledMethodTrailer ComposablePresenter ComposedSortFunction CompositeFillStyle CompositionScanner ConfigurableHistoryIterator Context class ControlButtonMorph CornerGripMorph CornerRounder class CoverageDemo CriticBrowser CriticToolbar CriticsCache Cursor class CustomQuestionDialogWindow DAAbstractItemDiff DADependencyChecker DADependencyReport DAPackageCycle DAPackageCycleDetector DAPackageRelationGraphDiff DATarjanAlgorithm DTBrowseSelectedItem DTDebugTestCommand DTFilterableListPresenter DTLeavesCollector DTMockPlugin DTPackagesSelectAllCommand DTRerunCommand DTResultBrowseCommand DTTestsProfilerVisitor DTTreeNode DailyNonInteractiveTranscript DangerousClassNotifier class DashedBorder DateAndTime class DatePresenter DeepCopier DefaultExternalDropHandler class DefaultSortFunction class DeflateStream Delay class DelayBasicScheduler DelayMicrosecondTickerSimulation DelayMillisecondTickerSimulation DelaySchedulerBackgroundWorkerMorph Deprecation class DialogItemsChooser DialogItemsChooserUI DialogItemsChooserUI class DialogWindow DialogWindowPresenter DictionaryValueHolder DieMorph DiffChangeMorph DiffJoinMorph DiffMapMorph DiffMorph DiffPresenter DigitalSignatureAlgorithm class DiskStore DiskStore class DisplayScanner DisplayScreen class DockingBarMorph DropListExample DropListItem DropListMorph DropListPresenter DroppedMorph DualChangeSorterPresenter DummyFindReplaceService Duration DynamicComposablePresenter DynamicPresentersListBuilder DynamicSpecExample DynamicWidgetChange EFContext EFFormatter EFFormatter class EFSettingPreviewer2 EFSettingPreviewer2 class EdgeGripMorph EditableList EditorFindReplaceDialogWindow EditorFindReplaceDialogWindow class EmbeddedFreeTypeFontInstaller EmbeddedFreeTypeFontInstaller class EmbossedStringMorph EncodedCharSet class EndianDetector class EpLogBrowserPresenter EpLogNode EpLostChangesDetector class EphemeronRegistry EventManager class EventSensorConstants class ExampleRadioButtonModel ExceptionSet ExceptionSetWithExclusions ExecutionCounter ExecutionCounter class ExecutionEnvironmentStub ExpanderMorph ExpanderTitleMorph ExternalAddress class ExternalClipboard ExternalDropHandler class ExternalFunction ExternalFunction class ExternalLibrary ExternalObject class ExternalSemaphoreTable class ExternalType class EyeAbstractInspector EyeInspectorNavigator EyeInspectorToolBar EyePointerExplorer FBDExamples FFIAbstract64BitsArgumentReader FFICallbackArgumentReader FFICallbackThunk FFICallbackThunk class FFICallout FFICallout class FFICalloutAPI FFICalloutMethodBuilder FFICompilerPlugin class FFIConstantArgument FFIConstants class FFIEnumeration class FFIExternalObjectType FFIExternalReference FFIExternalResourceExecutor FFIExternalResourceManager FFIExternalStructureFieldSpec FFIExternalStructureFlatLayout FFIExternalType FFIExternalValueHolder FFIFunctionParser FFIFunctionSpec FFIMethodRegistry FFIMethodRegistry class FFISystemV64CallbackArgumentReader FFITestArrayStructure class FFITestEnumeration class FFITestNestingStructure class FFITestPointerStructure class FFITestStructure class FFITutorial class FLAnalyzer FLClusterization FLCompiledMethodCluster class FLFileReferenceStreamStrategy FLHeader FLLargeIdentityDictionary FLLargeIdentityHashedCollection FLLargeIdentityHashedCollection class FLLargeIdentitySet FLMaterializer FLSerializer FT2Constants class FT2FFILibrary class FT2Handle FT2Types class FTBasicItem FTBasicTreeListItem FTCellMorph FTColumn FTEasyListMorph FTExampleClassInfoTableDataSource FTExampleDropDataSource FTFilterFunction FTIndentedCellMorph FTPluggableIconListMorphAdaptor FTSelectableMorph FTStateBasedColumnSortingStrategy FTTableContainerMorph FTTableMorph FTTableRowMorph FTTreeDataSource class FadingMorph FastInflateStream class FastTablePresenter File class FileCompilerRequestor FileDialogWindow FileList FileLocator class FileStream class FileSystemGuide FilteredMorphTreeModel Finder FinderUI FinderUI class FixedFaceFont Float class FloatPrintPolicy FontChooser Form class FreeTypeCache FreeTypeCache class FreeTypeCacheConstants class FreeTypeFontFamily FreeTypeFontProvider FreeTypeFontProvider class FreeTypeNameParser FreeTypeSettings class FreeTypeSubPixelAntiAliasedGlyphRenderer class FullscreenMorph FuzzyLabelMorph FuzzyMatcher FuzzyMatcherExample GB2312 class GIFReadWriter class GLMActionButtonBrick GLMAlertBrick GLMAnnouncingCollection GLMArea GLMBandBrick GLMBrick GLMBrickBorder class GLMBrickBounds class GLMBrickLayoutMyselfState GLMBrickLayoutParentState GLMBrickLayoutProperties GLMBrowser GLMButtonBrick GLMCheckboxBrick GLMCollapsableBrick GLMCompositePresentation GLMDynamicPresentation GLMEditableLabelBrick GLMEditorPopupBrick GLMEmptyPopupBrick GLMErrorPopper GLMEvaluateSelection GLMFastListPresentation GLMFastTablePresentation GLMFastTreePresentation GLMFormBrick GLMFoundationBrick GLMHaloBrick GLMHintableActionButtonBrick GLMHorizontalBandBrick GLMInteractableBrick GLMLabelBrick GLMLiveLabelBrick GLMLoggedObject GLMLoggedObject class GLMMemoryLogger GLMMockSimpleTransmission GLMMorphBrick GLMMorphPresentation GLMMorphicModel GLMNoBrowser class GLMOSWindowWorldMorph GLMPagePoped GLMPagerBarBrick GLMPagerBrick GLMPagerModel GLMPagerPanePreviewMorph GLMPagerScrollBrick GLMPagerScrollButtonBrick GLMPagerScrollSlidingBrick GLMPane GLMPaneScroller GLMPhlowBrick GLMPhlowListBrick GLMPhlowTableRowBrick GLMPhlowTextBrick GLMPopper GLMPopupActionBrick GLMPopupBrickListener GLMPresentation GLMPrintPopper GLMPrivacyAgreementBrick GLMRubEditingAreaBrick GLMRubScrolledTextBrick GLMRubTextAreaBrick GLMRubTextFieldBrick GLMScrollListBrick GLMScrollPaneBrick GLMScrollbarBrick GLMStackedScrollPaneBrick GLMStringBrick GLMSystemWindow GLMTabLabelBrick GLMTablePresentation GLMTransmission GLMUpdateAction GLMVector GLMVector class GLMWatcherWindow GRGuardClauseRule GTBrowseMethodDebuggerAction GTChangeDebuggerAction GTClearEditorDebugAction GTCodeDebugAction GTDebugActionButton GTDebugSelectionDebugAction GTExecuteSelectionDebugAction GTFilter GTGlamourWrapperDebuggingAction GTGoAndInspectBytecodeDebugAction GTHelpDebugAction GTInspectSelectionDebugAction GTInspector GTInspector class GTInspectorMethodListFilter GTInspectorTagFilter GTPlayBook GTPlayBook class GTPlayPage GTPlaygroundBindingsList GTPlaygroundEditableTabLabel GTPlaygroundPlayPagesList GTPrintSelectionDebugAction GTProfileSelectionDebugAction GTSUnitDebuggerJumpToTestAction GTSelectionGoDebugAction GTSpotter GTSpotterCategoryBrick GTSpotterCategoryTitleBrick GTSpotterContentsBrick GTSpotterContext GTSpotterDropDownMorph GTSpotterHeaderBrick GTSpotterItemBrick GTSpotterMethodListProcessorFilter GTSpotterMorph GTSpotterPaneBrick GTSpotterPreviewArrowBrick GTSpotterPreviewBrick GTSpotterResultsBrick GTSpotterStepBreadcrumbItem GTSpotterStepsBreadcrumb GTSpotterStreamMock GTSpotterTriangleRenderer GZipConstants class GeneralScrollBar GeneralScrollPane GlobalIdentifier GlobalIdentifier class Gofer GoferOperation GoferWorking GradientFillStyle class GradientPaint GreekEnvironment class GroupWindowMorph GroupboxMorph GrowlMorph HDTestReport HEExtendedInstaller HEInstaller HEPackage HSVAColorSelectorMorph HSVColorSelectorMorph HaloMorph HaloMorph class HandMorph HandMorph class HandleMorph HashTableSizes HashTableSizes class HelpBrowser HelpBuilder HelpTopic HiColumnController HiColumnController class HiFastTableExample HiRulerBuilder HiRulerBuilderTest class HiSimpleRenderer HiUniformColorStrategy History HistoryCollection HistorySlot IRBuilder IRBytecodeGenerator IRBytecodeScope IRClosureStackCount IRFix IRMethod IRPushArray IRPushClosureCopy IRReconstructor IRSequence IRTempVector IRTranslatorV2 ISO885915TextConverter class ISO88592TextConverter class ISO88597TextConverter class ISOLanguageDefinition class IceAnnouncer IceBasicProject IceCredentialStore IceCredentialsProvider IceExternalJob IceGitCheckoutProgress IceGitHubAPI IceGitHubAction IceGitHubNewBranchFromIssuePanel IceGitHubPullRequest IceGitHubRemoveBranchesAction IceGitHubSelectListModel IceGitIndex IceGitTransferProgress IceLibgitTreeBuilder IceMCVersionInfo IceMetacelloLoadSession IceMetacelloPharoPlatform class IceNode IcePackage IcePackageDefinition IcePushTransferProgress IceRemoteDesynchronized IceRepository IceRepositoryCommand IceRepositoryCreator IceRootDefinition IceSortingStrategy IceSystemEventListener class IceTipAbstractAskCredentialsModel IceTipActionPanel IceTipBrowser IceTipCache IceTipCheckoutModel IceTipCommentPanel IceTipCommitInfoPresenter IceTipCredentialsStoreBrowser IceTipDiffSelectingPanel IceTipDirectoryDataSource IceTipEditProjectDialog IceTipInteractiveCredentialsProvider class IceTipItemBar IceTipOutlineMorph IceTipReadOnlyForm IceTipReadOnlyTextMorph IceTipRemoteActionContext IceTipRepositoriesBrowser IceTipSelectingDataSource IceTipTreeSelectingDataSource IceUndefinedRemote IceUnknownCommit IceWorkingCopy IceWorkingCopyPatcherVisitor Iceberg class IconHardcodedMessageRule IconListPresenter IconicButton IconicButton class IconicListItem IdentifierChooserMorph IdentityTransform class ImageFillStyle ImageMorph ImageMorph class ImagePresenter ImagePreviewMorph ImmediateLayout IncrementalSliderMorph IndentingListItemMorph InflateStream class InputEventSensor InstructionStream class InteractiveResolver InternetConfiguration class JISX0208 class JPEGHuffmanTable class JPEGReadStream class JPEGReadWriter class JapaneseEnvironment class Job JobProgressBarMorph JobProgressMorph JoinSection JoinSide KMAltModifier KMBuffer KMCatcherMorph KMCategory KMCommandModifier KMComposedModifier KMCtrlModifier KMLog class KMMetaModifier KMNoModifier KMPragmaKeymapBuilder KMPragmaKeymapBuilder class KMShiftModifier KMStorage KOI8RTextConverter class KSX1001 class KernelClassesFilter KeyboardKey class KoreanEnvironment class LGitAbstractError LGitDiffHunk class LGitExternalEnumerationUInt32 class LGitExternalObject LGitLibrary class LGitReadStream LGitStructWithDefaults LIFOQueue LRUCache LabelMorph LabelPresenter LanguageEnvironment class Latin1 class Latin2Environment class Latin9Environment class LayoutFrame LayoutProperties LazyListMorph LazyMorphListMorph LazyMorphTreeNodeMorph LazyTabGroupMorph LessonView ListDialogWindow ListPresenter LiteralVariable class Locale class LoggingProxy LogicalFont class LogicalFontManager LucidaGrandeRegular class MCAncestry MCCacheRepository MCCacheRepository class MCConfiguration MCDataStream class MCDefinitionIndex MCDependencySorter MCDictionaryRepository MCDirectoryRepository MCFileRepositoryInspector MCFileTreeAbstractStWriter MCFileTreeFileSystemUtils class MCFileTreeStCypressWriter class MCGitBasedNetworkRepository class MCGitRemoteRepository MCLazyVersionInfo MCLazyVersionInfo class MCMczWriter MCMethodDefinition class MCMockASubclass class MCMockClassA class MCOldDataStreamExtensions class MCPackageCache MCPackageLoader MCPackageManager MCPackageManager class MCPatchOperation MCRepositoryGroup MCServerRegistry MCSliceInfo MCSliceMaker MCThreeWayMerger MCVersionLoader MCVersionMerger MCVersionSorter MCWorkingCopy MCWorkingCopy class MCWorkingCopyBrowser MD5 MD5NonPrimitive MD5NonPrimitive class MacRomanTextConverter class MailAddressTokenizer class MailMessage MalBfsNode MalCircuitSpanningEdges MalCseEdge MalCyclesCoverage MalDijkstraEdge MalDijkstraNode MalDisjointSetsNextNode MalDominanceNode MalGraphAlgorithm MalGraphReducer MalHalNode MalHits MalKruskal MalLongestPath MalNodeWithNext MalNodeWithPreviousAndNext MalSccEdgeDecomposition MalSccExtractor MalTarjan MalTarjanNode MalTopologicalSorting Margin MarginBorder MczInstaller class MemoryFileSystemDirectory MemoryFileSystemEntry MemoryFileSystemFile MemoryLogger MemoryStore MemoryStore class MenuGroupPresenter MenuItemMorph MenuItemMorph class MenuItemPresenter MenuLineMorph MenuMorph MenuMorph class MenuPresenter MenuRegistration MenuTitleMorph MenubarMorph MenubarMorph class MenubarSeparatorMorph MergeDiffMorph MergeJoinSection MessageBrowser MessageDialogWindow MessageList MessageNotUnderstood MessageTally MetaLink MetaLinkAnonymousClassBuilder MetaLinkInstaller MetaLinkNodesMapper MetaLinkRegistry MetacelloCommonMCSpecLoader MetacelloLoaderPolicy MetacelloMCPartiallyLoadedStatus MetacelloPharoPlatform class MetacelloPlatform class MetacelloVisitedPackages MethodNameEditor MethodToolbar MillerScrollPane MockObjectForEventTests MockSocketStream MockSourceEditor Monitor Morph Morph class MorphExtension MorphHandlingMiddleButton MorphTreeChunkPager MorphTreeColumnButton MorphTreeListManager MorphTreeMorph MorphTreeNavigationBar MorphTreeNodeMorph MorphTreeTransformMorph MorphicEventHandler MorphicTreeAdapter MorphicWindowAdapter MouseOverHandler MultiByteFileStream class MultiCanvas MultistateButtonMorph Mutex NECDetailMorph NECMenuMorph NECPreferences class NECTestClass class NECTestSuperClass NECTestSuperClass class NavigationHistory NetNameResolver class NewHandleMorph NewValueHolder NonInteractiveTranscript NonInteractiveTranscript class NullStream OCASTTranslator OCASTTranslator class OCASTTranslatorTest OCAbstractMethodScope OCInstanceScope OCOpalExamples OCOptimizedBlockScope OCReadOnlyVMWarning OCScopesCollector OCSelfVariable OCSuperVariable OCTempVariable OCThisContextVariable OSButtonState OSEnvironment class OSEvent OSKeySymbols class OSKeyboardEvent OSMouseEvent OSNullWindowHandle OSPlatform class OSSDL2Driver OSSDL2FormRenderer OSSDL2WindowHandle OSStateModifiers OSTextInputEvent OSTouchFingerTracker OSTouchGestureNeedingThresholdDetector OSTouchGestureNeedingThresholdDetector class OSTouchHoldDetector OSTouchHoldDetector class OSTouchOneFingerDoubleTapDetector OSTouchOneFingerDoubleTapDetector class OSTouchPinchDetector OSTouchPinchDetector class OSTouchRotationDetector OSTouchScrollDetector OSTouchScrollDetector class OSTouchStateGestureDetector OSTouchSwipeDetector OSTouchSwipeDetector class OSVMWindowHandle OSWindowAthensRenderer OSWindowAttributes OSWindowAttributes class OSWindowDriver class OSWindowGLAttributes OSWindowGLAttributes class OSWindowGestureHandler OSWindowJoystickExample OSWindowMorphicEventHandler OSWindowMorphicEventHandler class OSWindowRenderThread OSWindowRenderer OSWindowWorldMorph OSWorldRenderer Object class ObjectStringConverter ObservablePoint ObservableValueHolder OkCancelToolbar OkToolbar OmBlockFileStore OmDeferrer class OmFileStore OmFuelEntryReader OmFuelEntryWriter OmSTONEntryWriter OmSessionStore class OmStoreFactory OmStoreFactory class OverflowRowMorph PNGReadWriter class PSMCChangesGrouper PSMCMergeMorph PanelMorph PanelMorphWithSplitters Paragraph ParametrizedTestMatrix PasteUpMorph PasteUpMorph class PathShape PermaLink PharoChangesCondenser PharoCommonTools PharoCommonTools class PharoDarkTheme PharoLightTheme PickListPresenter PlainGroupboxMorph PluggableButtonMorph PluggableButtonMorphExample PluggableDialogWindow PluggableListMorph PluggableSliderMorph PluggableTextFieldMorph PluggableTextMorph PluggableToggleButtonMorph PolygonMorph PoolDefiner class PoolDefiner2 class PopupChoiceDialogWindow PragmaCollector PragmaMenuAndShortcutRegistration PragmaMenuAndShortcutRegistrationItem PragmaMenuBuilder PreDebugAction PreDebugDoesNotUnderstandAction PreDebugResumeDebugAction Process ProcessBrowser ProcessBrowser class ProcessSpecificVariable class ProcessorScheduler class ProgressBarMorph ProgressBarMorph class ProportionalSplitterMorph ProtoObject Protocol ProtocolOrganizer QuotedPrintableMimeConverter RBAbstractClass RBAbstractClass class RBAllAnyNoneSatisfyRule RBApplyClassDeprecationRefactoring RBArrayNode RBAsOrderedCollectionNotNeededRule RBAssignmentInBlockRule RBAssignmentInIfTrueRule RBAssignmentWithoutEffectRule RBAtIfAbsentRule RBBasicDummyLintRuleTest RBBasicLintRule RBBasicLintRuleTestData RBBetweenAndRule RBBlockNode RBBlockReplaceRule RBBooleanPrecedenceRule RBCascadedNextPutAllsRule RBCategoryEnvironment RBClass RBClass class RBClass2 class RBClassEnvironment RBClassRegexRefactoring RBClassTransformation RBCodeCruftLeftInMethodsRule RBCollectionMessagesToExternalObjectRule RBCollectionProtocolRule RBCombinatorVisitor RBCompositeRefactoryChange RBCompositeTransformation RBConsistencyCheckRule RBContainsRule RBDeprecateWithFirstCharacterDownshifted RBDetectContainsRule RBDetectIfNoneRule RBDoNotSendSuperInitializeInClassSideRule RBDummyLintRuleTest RBDumpVisitor RBEmptyExceptionHandlerRule RBEndTrueFalseRule RBEntity RBEqualNilRule RBFileBlocksRule RBFloatEqualityComparisonRule RBGuardingClauseRule RBImplementedNotSentRule class RBIsNilAndConditionalRule RBJustSendsSuperRule RBKeysDoRule RBLintRuleTestData RBLiteralNode RBMatchVisitor RBMethodNode RBMinMaxRule RBModifiesCollectionRule RBMultiEnvironment RBNamespace RBNotEliminationRule RBPackageEnvironment RBParseTreeLintRule RBParseTreeSearcher RBParser RBPlatformDependentUserInteractionRule RBPragmaEnvironment RBPragmaNode RBReadBeforeWrittenTester RBRefactoring class RBRefactoryChange RBRefactoryChangeManager RBRefactoryChangeManager class RBRefactoryTyper RBRegexRefactoring RBRemoveAssignmentWithoutEffectRule RBRenameInstanceVariableRefactoring RBReplaceRule RBReturnInEnsureRule RBReturnNode RBReturnsIfTrueRule RBRuleIfNotEmptyDo RBRuleIfNotNilDo RBScanner class RBSearchingLiteralRule RBSelectorEnvironment RBSequenceNode RBShouldntRaiseErrorRule RBSimpleFormatter RBSimpleFormatter class RBSizeCheckRule RBSlotInitializationNode RBSmalllintChecker RBSmalllintContext RBSmalltalkGlobalsRule RBStringConcatenationRule RBSuperSendsNewRule RBSuperSendsRule RBThemeAPIUpdateRule RBToDoCollectRule RBToDoRule RBToDoWithIncrementRule RBTransformation RBTransformation class RBTransformationRule RBTransformationRule class RBTrueFalseDuplicationRule RBUncommonMessageSendRule RBUnconditionalRecursionRule RBUnderscoreAssignmentRule RBUnoptimizedAndOrRule RBUnoptimizedToDoRule RBUnwindBlocksRule RBUsesTrueRule RBVariableEnvironment RBVariableNode RBWhileTrueRule RFCondition RFMetaContext RGAbstractContainer RGBehavior RGBehaviorDefinition RGChunkImporter RGClassDefinition RGClassDescriptionDefinition RGClassDescriptionStrategy RGClassInstanceVariableDefinition RGClassStrategy RGComment RGContainer RGEnvironment RGEnvironmentBackend RGMetaclassStrategy RGMetaclassTraitV2Strategy RGMethod RGNamespace RGObject RGOrganization RGPackage RGPackageDefinition RGPointerLayout RGReadOnlyImageBackend RGTraitAlias RGTraitComposition RGTraitDescriptionStrategy RGTraitExclusion RGTraitStrategy RGTraitTransformation RGTraitV2DescriptionStrategy RGTraitV2Strategy RGUnknownSlot RPackage RPackage class RPackageOrganizer RPackageOrganizer class RPackageTag RadioButtonGroup RadioButtonGroupExample RadioButtonGroupPresenter RadioButtonPresenter Random RbScriptingSetBeforeModel ReInvocationSequenceRule ReMissingMethodCritique ReNoPrintStringInPrintOnRule class ReNodeMatchRule ReNodeRewriteRule RePropertyAction ReRefactoringCritique ReRuleManager class ReSettings ReSmalllintChecker ReThemeAccess class RealEstateAgent class ReceiverMorph RecentMessageList RecentMessageList class RecursionStopper ReferenceFinder ReflectivityCodeMorph ReflectivityExamples ReflectivitySourceCodeAgroupation RegisterableTranslatorMock ResumeDebugAction RingChunkImporter RoundedBorder RubAbstractTextArea RubAnnotationDisplayer RubCharacterScanner RubCharacterScanner class RubDropListButtonRuler RubEditingMode RubFindReplaceService RubFloatingEditorBuilder RubHoverHighlightSegmentMorph RubParagraph RubPluggableTextMorph RubPrimarySelectionMorph RubScrolledTextExtra RubScrolledTextMorph RubSegmentMorph RubSmalltalkEditor RubTextFieldMorph RubTextScrollPane RubTextSegmentIconDisplayer RubTextSegmentMorph RubTextStopConditions RubWorkspaceBar RubWorkspaceExample RussianEnvironment class RxMatcher class RxParser class RxmBranch RxmLookahaed RxmSubstring RxsPredicate class SDL2AthensDrawingExample SDL2Constants class SDL2ConstantsHint class SDL2SpecialCharacterMapping class SDL2TouchExample SDL2TouchGestureExample SDL2TouchGestureExample2 SDL2TouchStateMachine SDL2TuioObjectStateMachine SDL2Types class SDL_Event SDL_Event class SDL_Renderer SDL_RendererInfo class SDL_Surface SDL_Texture SHA1 class SHPreferences class SHRBTextStyler class SHTextStyler SQSurfaceDispatch STONReader STONStreamWriter STONTestDomainObject STONTestKnownObject STONTestUser STONWriter STONWriter class SUnitTestsCounter SVColorSelectorMorph ScrollBar ScrollBar class ScrollPane ScrollSyncExample SearchMorph SearchableTree SelectEntity SelectPackageBrowser SelectRuleBrowser SelectionMorph SelectionValueHolder SelectorFilter SelfPropagatingLinkDemo SerialPort SessionAccessModeResolver class SessionCategory SessionManager SettingDeclaration SettingDeclaration class SettingDontTranslateDescriptionRule SettingsStonWriter ShAbstractClassChangeDetector ShClassSlotChangeDetector ShLayoutChangeDetector ShLayoutDefinition ShMetaclassChangeDetector ShSharedPoolChangeDetector ShSharedVariablesChangeDetector ShSlotChangeDetector ShSmalltalkGlobalsEnvironment ShSuperclassChangedDetector SharedQueue SharedRandom SharedRandom class ShiftClassBuilder ShiftClassInstaller ShortIntegerArray class ShortcutReminder ShouldTransformedIntoAssert SignalLogger SimpleBalloonMorph SimpleBorder SimpleButtonMorph SimpleHierarchicalListMorph SimpleServiceEntry SimpleSwitchMorph SimplifiedChineseEnvironment class SingleCodeCriticResultList SingleCodeCriticResultList class Slider SliderPresenter Slot class SlotExampleMovie SlotExamplePerson SmallDictionary SmallInteger class SmalllintManifestChecker Socket class SocketStream SoundTheme SourceCodeProRegular class SourceFileArray SourceFileArray class SourceSansProRegular class SpAbstractButtonPresenter SpAbstractFormButtonPresenter SpAbstractListPresenter SpAbstractPresenter SpAbstractSelectionMode SpAbstractTextPresenter SpAbstractTreeSelectionMode SpAbstractWidgetPresenter SpActionBarPresenter SpActionBarPresenterBuilder SpAdapterBindings SpAddContactCommand SpApplicationBackend SpAthensAnimatedPresenter SpAthensStaticPresenter SpBoxConstraints SpBoxLayout SpBoxLayoutExample SpButtonBarPresenter SpButtonPresenter SpCalendarPresenter SpChangePhoneCommand SpCodePresenter SpCollectionListModel SpCompositeTableColumn SpContactBook SpDatePresenter SpDemoFormModel SpDemoFormPresenter SpDemoTablePresenter SpDialogWindow SpDialogWindowPresenter SpDiffPresenter SpDropListItem SpDropListPresenter SpDynamicPresentersListBuilder SpDynamicSpecExample SpDynamicWidgetChange SpEditableListPresenter SpExecutableLayout SpFastTablePresenter SpGridConstraints SpGridLayout SpHeaderCellMorph SpImagePresenter SpIndeterminatedProgressBarMorph SpInspectContactCommand SpKMCategoryBuilder SpLabelPresenter SpLayout SpLayoutAdd SpLayoutConstraints SpLayoutFrame SpLinkPresenter SpListPresenter SpMenuButtonPresenter SpMenuGroupPresenter SpMenuItemPresenter SpMenuPresenter SpMenuPresenterBuilder SpMethodToolbar SpMillerColumnPresenter SpMillerLayout SpMockMenu SpMockMenuPresenter SpModalWindowPresenter SpMorphPresenter SpMorphicBackendForTest SpMorphicGridLayout SpMorphicMillerAdapter SpMorphicStatusBarAdapter SpMorphicTreeAdapter SpMultipleSelectionMode SpNotebookMorph SpNotebookPage SpNotebookPresenter SpNotification SpNumberInputFieldPresenter SpObservablePoint SpOkCancelToolbar SpOkToolbar SpPanedConstraints SpPanedLayout SpPanedResizerMorph SpPanelMorphWithSplitters SpPickListPresenter SpPrepareWindowExample SpPresenter SpPrintContactBookInTranscript SpProgressBarFixed SpProgressBarProgressing SpRadioButtonGroup SpRadioButtonGroupPresenter SpRadioButtonPresenter SpRemoveContactCommand SpRenameContactCommand SpRichTextPresenter SpRubFindReplaceService SpScrollSyncExample SpSearchableTree SpSelectEntity SpSingleSelectionMode SpSliderPresenter SpSpinnerMorph SpSplitterHorizontal SpSplitterVertical SpStringTableColumn SpStyleGeometry SpTSearchable SpTabManagerPresenter SpTabPresenter SpTableColumn SpTablePresenter SpTextInputFieldPresenter SpTextPresenter SpTimeline SpToggleButtonPresenter SpTokenTreeFilter SpToolBarMorph SpToolBarOptionButtonGroup SpToolBarPresenter SpToolBarPresenterBuilder SpToolBarToggleButton SpTransferMorph SpTransferPresenter SpTreeColumnPresenter SpTreeNodePresenter SpTreePresenter SpTreeTablePresenter SpUIThemeDecorator SpValueHolder SpVersatileDialogPresenter SpVerticalAlignment SpWindowPresenter SpecAdapterBindings SpecDemoFormModel SpecDemoFormPresenter SpecDialogWindow SpecFocusOrder SpecLayout SpecLayoutAdd SpecLayoutFrame SpecLayoutProperties SpecSplitterHorizontal SpecSplitterVertical SpecTableLayout SpecTableLayoutAdd SpecTableLayoutAddSpacer SpecTableLayoutProperties SpecTransferMorph SpecWrapperTableLayout StandardWindow StartupPreferencesHandler StartupPreferencesLoader Stdio class StoredSettingsMerger StrikeFont class String class StringMorph StringMorphAttributeScanner SubscriptionRegistry SycRemoveMethodCommand Symbol class SyntaxErrorDebugger SystemAnnouncement SystemNavigation SystemOrganizer SystemProgressMorph SystemProgressMorph class SystemReporter SystemSettingsPersistence class SystemVersion SystemWindow SystemWindow class TTLCache TaSequence TabAction TabBarMorph TabBuildingIconMorph TabExample TabGroupMorph TabLabelMorph TabManagerMorph TabManagerPresenter TabMorph TabMorph class TabPresenter TabSelectorMorph TableLayoutProperties TaskListMorph TaskbarItemMorph TaskbarMorph TaskbarMorph class TemporaryVariable class Termcap TestCase class TestExecutionEnvironment TestFailedByForkedProcess TestInWorldMorph TestResult TestRunner TestSharedPool class TestWorkingSession TextAction TextAction class TextConstants class TextContainer class TextConverter TextDiffBuilder class TextEditor class TextEditorDialogWindow TextHighlightByBounds TextInputFieldPresenter TextMethodLink TextMorph TextMorphForEditView TextPresenter TextStyle class ThemeSettings ThreadSafeTranscript ThreePhaseButtonMorph ThumbnailMorph ThumbnailMorph class TimeMeasuringTest TokenTreeFilter TonelFileSystemUtils class TonelSTONWriter ToolRegistry TraitChange TraitMethodDescription TraitedMetaclass TransferMorph TransferMorph class TransferPresenter TransformMorph TreeColumnPresenter TreeNodePresenter TreePresenter TypingVisitor UIManagerSessionHandler class UITheme UITheme class UIThemeDecorator UTF16TextConverter UUID UUIDGenerator UUIDGenerator class UndefinedSortFunction Unicode class UnsafeAlien class VGTigerDemo VTermOutputDriver VTermOutputDriver2 VTermOutputStyle VTermOutputStyleElement VTermOutputStyles class VersionBrowser WaitfreeQueue Watchpoint WeakAnnouncementSubscription WeakAnnouncementSubscription class WeakArray class WeakRegistry WhereIsDebugAction WideCharacterSet WindowPresenter WorkingSession Workspace WorldMorph WorldState WorldState class WriteBarrierTest class ZdcAbstractSocketStream ZdcByteArrayManager ZdcPluginSSLSession ZdcSecureSMTPClient ZdcSecureSocketStream ZipArchive ZipArchiveMember ZipConstants class ZipDirectoryMember ZipFileConstants class ZipFileMember ZipNewFileMember ZipStore ZipStringMember ZipWriteStream ZipWriteStream class ZnApplicationFormUrlEncodedEntity ZnBase64Encoder ZnBase64Encoder class ZnBasicAuthenticator ZnBufferedReadStream ZnChunkedReadStream ZnChunkedWriteStream ZnClient ZnCommonLogFormat ZnConstants class ZnCookie ZnCrPortableWriteStream ZnDefaultServerDelegate ZnEndianSensitiveUTFEncoder ZnFastLineReader ZnHeaders class ZnLogEvent ZnLogEvent class ZnMimeType class ZnMultiPartFormDataEntity ZnNetworkingUtils ZnNetworkingUtils class ZnNewLineWriterStream ZnPositionableReadStream ZnServer class ZnServerLogEvent ZnServerSession ZnServerSessionManager ZnServerTransactionTiming ZnSimplifiedByteEncoder ZnSimplifiedByteEncoder class ZnSimplifiedClientTransactionEvent ZnSingleThreadedServer ZnSingleThreadedServer class ZnUTF8Encoder class)"

	SystemNavigation default allClassesImplementing: #instanceSide		> "an OrderedCollection(Class ClassDescription Metaclass RBAbstractClass RBClass RGBehaviorDefinition RGBehaviorStrategy RGBehaviorStrategyUser RGClassDefinition RGMetaclassDefinition RGMetaclassStrategy RGMetaclassTraitStrategy RGMetaclassTraitV2Strategy RGMetatraitDefinition RGTraitDefinition RGTraitStrategy)"
	SystemNavigation default allClassesImplementing: #reflectiveMethod  	> "an OrderedCollection(CompiledMethod ReflectiveMethod)"
	SystemNavigation default allClassesImplementing: #reflectiveOperations 	> "an OrderedCollection()"
	SystemNavigation default allClassesImplementing: #reflectiveoperations 	> "an OrderedCollection()"
	SystemNavigation default allClassesImplementing: #overrides:  		> "an OrderedCollection()"

Parcourir toutes les implémentations de #subject, etc.."
Playground >
	SystemNavigation default browseAllImplementorsOf: #subject 		> implementors (7)
	SystemNavigation default browseAllImplementorsOf: #invocationCount 	> implementors (1)

-18 mns - 08:32 25/05/2021 - 08:50 25/05/2021

p. 226 FR 330 EN
"Voici un peu de magie." - "Here comes a bit of magic."
* Aie, aie, aie.

"Nous créons un nouvel objet Point et un nouvel objet LoggingProxy, puis nous demandons au proxy de devenir: l'objet point:"
* Qu'est-ce que c'est cette histoire ? Si ça, ce n'est pas marcher sur la tête alors, je n'ai rien compris.

"Cela a pour effet de permuter toutes les références dans l'image au point de se référer maintenant au proxy, et vice versa. 
Plus important encore, la variable d'instance "subject" du proxy fera désormais référence au point !"
* C'est quoi, c'est conneries ? 
	- Je ne vois pas l'intérêt de "permuter toutes les références" ?
	- Le plus important, c'est de comprendre de moins en moins la référence au point ?
	- C'est un "proxy léger" que vous essayez de faire ou un "proxy à point" limité à 30 klm/h ?

"Cela fonctionne bien dans la plupart des cas, mais il y a quelques lacunes:"
* Tu m'étonnes.
* MDR ! 
* Le Phare est emporté par un tsunami.

-16 mns - 09:20 25/05/2021 - 09:36 25/05/2021

* J'ai lu jusqu'à "Générer des méthodes manquantes" et il s'avère que le "proxy léger" n'existera jamais.
En effet, entre le partage des variables, les tours de magie, les lacunes, des messages interprétés par la VM, 
des messages à des non-booléens, un problème fondamental non surmontable et l'interception des messages par des 
mandataires c'est le pire des projets non aboutis que j'ai pu réaliser.

Playground >
	point := 1@2. "(1@2)"
	LoggingProxy new become: point. "(1@2)"
	point invocationCount
	point + (3@4) "(4@6)"
	point invocationCount

"Nous créons un nouvel objet Point et un nouvel objet LoggingProxy, puis nous demandons au proxy de devenir: l'objet point:"
* Comment fais-tu pour les créer tes nouveaux objets ?

* Dans le cadre d'une entreprise, si tu passes ton temps à interpréter des messages envoyés par Pharo  et que finalement tu n'as pas de "proxy léger",
alors je te laisse imaginer la suite.

* C'est à l'image du reste : erreurs, situation confuse, embrouillée. Quel micmac !

10:10 25/05/2021
Générer des méthodes manquantes - Generating missing methods
--------------------------

* Je me répète : tu passes plus de temps à chercher à comprendre les interrelations qu'à coder.

* C'est barbant, inutile, casse-tête, prise de tête, une perte de temps et d'énergie.

10:18 25/05/2021
14.7 Objets comme wrappers de méthode
-------------------------------------
333-376= 43 pages restantes.

"Définissez une démo de classe vide"
* Très franchement, ça ne donne pas envie.

"La méthode TestRunner >> collectCoverageFor: illustre clairement l'algorithme de vérification de la couverture:"
* Ce qui n'est pas le cas pour le "proxy léger". :-)

"Jetez un œil à ProtoObject >> withArgs: executeMethod: pour voir comment une méthode déplacée de son dictionnaire de méthodes peut être appelée."
* Très franchement, après avoir jeté un oeil dans "proxy léger" ça ne me dit rien d'allé barboter dans "ProtoObject>>withArgs:executeMethod:".

"Les wrappers de méthode peuvent être utilisés pour effectuer tout type de comportement approprié avant ou après
le fonctionnement normal d'une méthode. Les applications typiques sont l'instrumentation (collecte de statistiques
sur les modèles d'appel des méthodes), la vérification des conditions préalables et postérieures facultatives et la
mémorisation (éventuellement la mise en cache des valeurs calculées des méthodes)."

* Ton truc, ça n'a pas servi à grand-chose pour le "proxy léger". Trop de blabla tue le blabla.

10:32 25/05/2021
14.8 Pragmas
------------

* J'arrive bientôt au sommaire, et enfin le chapitre 15.

-25 mns - 10:34 25/05/2021 - 10:59 25/05/2021

Code : 
------

Playground > (Print it)
	(SplitJoinTest class >> #showDocumentation) pragmas. 	> CTRL+P > KeyNotFound: key #showDocumentation not found in MethodDictionary
	(Float>>#+) pragmas					> CTRL+P > KeyNotFound: key #+ not found in MethodDictionary


11:16 25/05/2021
14.9 Résumé du chapitre
------------------------
"RGMethodDefinition est un proxy léger pour une méthode compilée, fournissant des méthodes de commodité
supplémentaires et utilisé par de nombreux outils Pharo."
* Tout ce que je vois, c'est une classe et une liste de méthodes au lieu d'un proxy léger.
* Au final, le "proxy léger" n'est toujours pas opérationnel malgré ton "RGMethodDefinition".
* Trop de blabla, d'embrouille et jusqu'à maintenant la majorité des projets de ce livret ne fonctionne pas, car 
ils sont mal ficelés, incompréhensibles.

* Redemande-moi la commande "SystemNavigation" et je suis sûr qu'elle fait partie des écumes.


D07:16 25/05/2021 - F00:00 - Chapitre 14 - p.226/259 FR 330/376 EN
D07:16 25/05/2021 - F11:27 - Chapitre 14 - p.231/259 FR 338/376 EN
------------------------------------- 11:27 25/05/2021 FIN chapitre 14

------------------------------------- 11:27 25/05/2021 DEBUT chapitre 15
D07:16 25/05/2021 - F11:27 - Chapitre 15 - p.232/259 FR 339/376 EN

Expressions régulières dans Pharo
----------------------------------

"Nous allons développer deux classes,  WebDir  et  WebPage ,"
* Déjà, je me pose la question à savoir le nom du package ?

* Ça commence bien ! :-(

"Figure 15-1 A WebDir instance."
* Je ne sais pas à quoi correspond la capture d'écran.

1. J'ai créér un package "PBE-Didacticiel-HTML

2. Renommer la sous-classe "#NameOfSubclass" par "#WebDir" créant la classe "(c)WebDir"

3. (c)WebDir -> "Inst. side methode" -> setDir: dir home: path webDir := dir. homePath := path -> CTRL+S,
demande la déclaration d'une nouvelle variable ou classe ?
			- x2 j'ai mis variable.
la méthode "setDir:home:" et le protocole "initialization" sont créés.

4. (c)WebDir -> "Class side methode" -> onDir: dir ^ self new setDir: dir home: dir pathString -> CTRL+S,
la méthode "onDir:" et le protocole "asyetunclassified" sont créés. (Le nom du protocole ressort en rouge et n'est pas très lisible)
Message Pharo : Unclassified methods x ?

5. (c)WebDir -> "Class side methode" -> selectHome ^ self onDir: UIManager default chooseDirectory -> CTRL+S,
la méthode "selectHome" et le protocole "asyetunclassified" sont créés. (Le nom du protocole ressort en rouge et n'est pas très lisible)
Messages Pharo : 
	- (WebDir) Messages sent but not implemented x ?
	- (WebDir) Uncommon message send x ?
	- Unclassified methods x ?
	- Methods implemented but not sent x ?

6. Depuis l'onglet "WebDir >> selectHome", se positionner à la dernière ligne de code puis "Print it - CTRL+P",
afin qu'une fenêtre "Choose Directory" apparaisse et propose de choisir un répertoire.
(selectHome ^ self onDir: UIManager default chooseDirectory <- dernière ligne de code)
(répertoire : Pharo\Didacticiel_HTML

"et vous pourrez vérifier que webDir et homePath sont correctement initialisés dans le répertoire 
contenant votre site Web et le chemin complet nom de ce répertoire."
* Où ? Sinon, je n'ai rien trouvé. (dans les méthodes)

"A faire : Ajoutez les méthodes suivantes et essayez-les en inspectant le résultat de 
WebDir onPath: 'chemin vers votre site Web'."
* Cela contredit l'étape précédente, je ne comprends plus rien.

7. (c)WebDir -> "Class side methode" -> onPath: homePath ^ self onPath: homePath home: homePath, CTRL+S,
la méthode "onPath:" a été créée.
Messages Pharo : 
	- Methods implemented but not sent x ?
	- Unclassified methods x ?

8. (c)WebDir -> "Class side methode" -> onPath: path home: homePath ^ self new setDir: path asFileReference home: homePath
la méthode "onPath:home:" a été créée.
Message Pharo : Unclassified methods x ?

9. "A faire : Ajoutez les méthodes suivantes et essayez-les en inspectant le résultat de 
WebDir onPath: 'chemin vers votre site Web'."
Chemin : D:\Liberkeys\MyApps\Pharo\Didacticiel_HTML  > CTRL+S,
|
|-> ^ self onPath:  Variable or expression expected ->D:\Liberkeys\MyApps\Pharo\Didacticiel_HTML home: homePath
|
| * Aucune erreur (?)
|-> ^ self onPath: 'D:\Liberkeys\MyApps\Pharo\Didacticiel_HTML' home: homePath -> CTRL+I - Inspect it -> Declare new temporary variable, Declare new instance variable, Cancel
|
| * (?)
|-> onPath: homePath ^ self onPath: homePath home: homePath

"Fichiers HTML de correspondance de motifs - Jusqu'ici tout va bien."
* Pas vraiment, c'est le flou total.

10. Tests -> "'x' matchesRegex: '.'" and co.
Playground > (CTRL+P - Print it)
	'x' matchesRegex: '.' "true"	
	' ' matchesRegex: '.' "true"
	'xx' matchesRegex: 'x*' "true"
	'y' matchesRegex: 'x*' "false" 

	'.' matchesRegex: '.' "true"
	'x' matchesRegex: '.' "true"
	'.' matchesRegex: '\.' "true"
	'x' matchesRegex: '\.' "false"

11. "Maintenant, vérifions notre regex pour trouver que les fichiers HTML fonctionnent comme prévu."
Playground > (CTRL+P - Print it)
	'index.html' matchesRegex: '.*\.html' "true"
	'foo.html' matchesRegex: '.*\.html' "true"
	'style.css' matchesRegex: '.*\.html' "false"
	'index.htm' matchesRegex: '.*\.html' "false"

12. (c)WebDir -> "Inst. side methode" -> htmlFiles ^ webDir fileNames select: [ :each | each matchesRegex: '.*\.html']
la méthode "htmlFiles" a été créée ainsi que le protocole "asyetunclassified". (Nom de protocole en rouge pas très lisible)

13. "Envoyez "htmlFiles" à une instance "WebDir" ->
Playground >
	(WebDir onPath: '...') htmlFiles > CTRL+P - Printit ->
Message Pharo : 
	- FileException: '/D:/Liberkeys/MyApps/Pharo/...'
		Stack : File class - signalError:for: - Source : signalWith: pathString.

Ajout d'un fichier "index.html" dans le répertoire "D:\Liberkeys\MyApps\Pharo\Didacticiel_HTML"
Playground >
	(WebDir onPath: '...') htmlFiles > CTRL+P - Printit ->
Message Pharo : 
	- FileException: '/D:/Liberkeys/MyApps/Pharo/...'
		Stack : File class - signalError:for: - Source : signalWith: pathString.

* De nouveau, modification de la valeur "WebDir>>onPath:"
	Défaut
	onPath: homePath
	^ self onPath: homePath home: homePath

	Modifié
	onPath: homePath
	^ self onPath: 'D:\Liberkeys\MyApps\Pharo\Didacticiel_HTML' home: homePath

* Fonctionne
Playground >
	(WebDir onPath: '...') htmlFiles > CTRL+P - Printit ->  "#('2018-09-29-UpdatedPharoByExample_EN.html' '2018-09-29-UpdatedPharoByExample_sansimages_EN.html' 'actions-file.html' 'appendix.html' 'config.html' 'configuration.html' 'contact.html' 'copyright.html' 'filter-file.html' 'index.html' 'installation.html' 'introduction.html' 'quickstart.html' 'seealso.html' 'startup.html' 'templates.html' 'whatsnew.html')"

* Recherche t-il que le fichier "index.html ? Non, c'est bon.
Playground >
(WebDir onPath: '...') htmlFiles > CTRL+P > "#('2018-09-29-UpdatedPharoByExample_EN.html' '2018-09-29-UpdatedPharoByExample_sansimages_EN.html')"

* Quelle galère, ton didacticiel n'est pas carré, car il faut décrypter, tester, interpréter, relire, retester.
De plus, j'ai cru qu'il cherchait seulement le fichier "index.html".

* Est-ce que je serais capable de refaire un projet similaire à ce didacticiel ? Non.
Créer un package, une classe et une méthode c'est éventuellement possible, mais créer 
deux méthodes côté instance et quatre côtés classe contenant des codes à répétitions et surtout intervertis c'est impossible. 

----------------------------------------------------Répétitions / Intervertis DEBUT
setDir: dir home: path webDir := dir. homePath := path
onDir: dir ^ self new setDir: dir home: dir pathString
onPath: homePath ^ self onPath: 'D:\Liberkeys\MyApps\Pharo\Didacticiel_HTML' home: homePath
onPath: path home: homePath ^ self new setDir: path asFileReference home: homePath
selectHome^ self onDir: UIManager default chooseDirectory a WebDir
----------------------------------------------------Répétitions / Intervertis FIN

home: path - homePath - path home: 		//Intervertis
home: - homePath - home: - homePath - home: homePath - home: homePath - home: homePath //Répétitions
dir home - dir. - dir ^ - dir pathString	//Répétitions
self - self - self - self			//Répétitions
path - path - path - path			//Répétitions
setDir: - SetDir: - SetDir: 			//Répétitions
onPath: - onPath: - onPath: 			//Répétitions
onDir: - onDir:					//Répétitions
WebDir - WebDir					//Répétitions -> 13:27 25/05/2021
new - new


13:04 25/05/2021
Mise en cache de l'expression régulière - Caching the regex
---------------------------------------



D07:16 25/05/2021 - F00:00 - Chapitre 14 - p.226/259 FR 330/376 EN
D07:16 25/05/2021 - F11:27 - Chapitre 14 - p.231/259 FR 338/376 EN
------------------------------------- 11:27 25/05/2021 FIN chapitre 14

------------------------------------- 11:27 25/05/2021 DEBUT chapitre 15
D07:16 25/05/2021 - F11:27 - Chapitre 15 - p.232/259 FR 339/376 EN
D07:16 25/05/2021 - F13:28 - Chapitre 15 - p.235/259 FR 343/376 EN
-------------------------------------------------------------------------------------------------------25/05/2021 fin



-------------------------------------------------------------------------------------------------------26/05/2021 debut
D11:27 26/05/2021 - F00:00 - Chapitre 15 - p.235/259 FR 343/376 EN
D11:27 26/05/2021 - F13:49 - Chapitre 15 - p.236/259 FR 345/376 EN

-21 mns - 12:35 26/05/2021 - 12:56 26/05/2021

Remarque : 
----------

* Une réflexion m'est apparue hier.
En effet, lors de l'étape "6", il faut choisir un répertoire.
6. Depuis l'onglet de "WebDir >> selectHome", se positionner à la dernière ligne de code puis "Print it - CTRL+P",
afin qu'une fenêtre "Choose Directory" apparaisse et propose de choisir un répertoire.

Tandis que dans l'étape "9", il faut modifier le code et mettre le chemin du répertoire.
9. "A faire : Ajoutez les méthodes suivantes et essayez-les en inspectant le résultat de 
WebDir onPath: 'chemin vers votre site Web'."

C'est à l'étape "6" que Pharo aurait dû prendre en compte le chemin de répertoire.
Or, le répertoire a pu être considéré et interrogé seulement à l'étape "9".



Mise en cache de l'expression régulière - Caching the regex
---------------------------------------

Suite du didacticiel : 2
----------------------

14. (c)WebDir -> "Inst. side methode" -> initialize htmlRegex := '.*\.html' asRegex -> CTRL+S,
"Unknown variable: htmlRegx please correct, or cancel:"
	- Declare new temporary variable
	- Declare new instance variable
	Cancel

"Ajoutez une nouvelle variable d'instance htmlRegex à WebDir et 
initialisez-la en envoyant asRegex à notre chaîne regex."

la méthode "initialize" a été créée.

15. (c)WebDir -> "Inst. side methode" -> htmlFiles ^ webDir fileNames select: [ :each | htmlRegex matches: each ] -> CTRL+S,
la méthode "htmlFiles" a été créée.
messages Pharo : 
	- Methods implemented but not sent x ?
	- Unclassified methods x ?

16. "Maintenant, lister les fichiers HTML devrait fonctionner comme avant, 
sauf que nous réutilisons le même objet regex plusieurs fois."

Playground >
(WebDir onPath: '...') htmlFiles > Printit-CTRL+P > "#('2018-09-29-UpdatedPharoByExample_EN.html' '2018-09-29-UpdatedPharoByExample_sansimages_EN.html')"

Playground > 
initialize
htmlRegex := '.*\.html' asRegex > Inspectit-CTRL+I > Inspector on a RxMatcher
* Aucune allusion à "asRegex" ? 

"sauf que nous réutilisons le même objet regex plusieurs fois."
* Comment je le sais qu'il est utilisé plusieurs fois ? 
	- Est-ce qu'il y a un graphique ?
	- Une carte ?
	- Une fenêtre pour tracer l'objet vivant ?

Playground > 
	asRegex > Implementors-CTRL+M> Implementors of asRegex (1) -> String - asRegex - Regex-Core

* Bon laisse tomber. Suivant

12:15 26/05/2021
Accéder aux pages Web
---------------------

Suite du didacticiel : 3
----------------------

* Contrairement au projet "proxy léger" qui utilisait la classe "protoobject", 
le didacticiel et le serveur web, utilise "object". (?)

"Définissez une classe WebPage avec le chemin des variables d'instance"
* C'est plutôt vague comme création. Est-ce que les noms des Variables d'instance sont les mêmes que Webdir ?
(webDir, homePath htmlRegex)
Ou bien (HTML, homePath) ?

* Pour créer une nouvelle classe, ce n'est pas possible depuis le volet package, ni celui de classe.
L'embrouille, consiste à cliquer sur la classe Webdir afin de faire apparaître à l'opposé (au milieu à droite),
une croix verte permettant la création d'une classe en fait plutôt une "New subclasse".
Pourquoi faire simple quand on peut faire compliquer ?
17. Sélectionner "WebDir", à droite croix verte "New subclasse" -> WebPage
	Defaut
	(c)WebPage
	WebDir subclass: #WebPage
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'PBE-Didacticiel-HTML'

	Modification
	WebDir subclass: #WebPage
	instanceVariableNames: 'HTML homePath'
	classVariableNames: ''
	package: 'PBE-Didacticiel-HTML'

-21 mns - 12:35 26/05/2021 - 12:56 26/05/2021
Message : DuplicatedSlotName: Slot #homePath' appeared twice ni WebPage
* À la suite de ce message, j'efface les variables que j'ai pu mettre.

18. (c)WebPage -> "Inst. side methode" -> initializePath: filePath homePath: dirPath path := filePath. homePath := dirPath > CTRL+S,
"Unknown variable: path please correct, or cancel:
	- Declare new temporary variable 
	- Declare new instance variable X
	Cancel

* Declare new instance variable
	|-> la méthode "initializePath:homePath:" et le protocole "initialization" ont été créés.
Message Pharo : 
	- Methods implemented but not sent x ?

19. (c)WebPage -> "Class side method" -> on: filePath forHome: homePath ^ self new initializePath: filePath homePath: homePath > CTRL+S,
la méthode "on:forHome:" et le le protocole "asyetunclassified" ont été créés. (Le nom du protocole en rouge n'est pas très lisible)

* Ça ne s'arrête jamais les "pit, path, pot, homepath, etc.." ? 


"Une instance WebDir devrait pouvoir renvoyer une liste de toutes les pages Web qu'elle contient.
Pour ce faire, ajoutez la méthode suivante à WebDir et inspectez la valeur de retour pour vérifier 
qu'elle fonctionne correctement."
20. (c)WebDir -> "Inst. side method -> webPages ^ self htmlFiles collect: [ :each | WebPage on: webDir pathString, '/', each forHome: homePath ], CTRL+S,
la méthode "webPages" est créée.

Remarque/Question : 
-------------------
Le code indique ", '/',", comment Pharo va-t-il interroger Windows 10 étant donné qu'il utilise "'\'" ? 

Messages Pharo : 
	- Unclassified methods x ?
	- Methods implemented but not sent x ?

21. Vérification
Playground >
	(WebDir onPath: '...') webPages > Printit-CTRL+P > "an Array(a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage)"
Ancien
(WebDir onPath: '...') htmlFiles > Printit-CTRL+P >

"Une instance WebDir devrait pouvoir renvoyer une liste de toutes les pages Web qu'elle contient."
* Enfin de compte c'est aussi vague que la réponse.
	
TESTS :
------
Playground >
	(WebDir onPath: '...') initialize > Printit-CTRL+P > "a WebDir"
	(WebDir onPath: '...') setDir:home: > Printit-CTRL+P > End of statement list encountered ->
	
	(WebPage onPath: '...') initializePath: filepath homePath: dirPath > Printit-CTRL+P > "a WebPage"

13:32 26/05/2021
Substitutions de chaînes
------------------------

"Ce n'est pas très informatif, alors utilisons une expression régulière pour obtenir le nom de fichier réel de chaque page Web."
* Je ne comprends pas, car l'expression "(WebDir onPath: '...') htmlFiles" affiche les fichiers "html" ?
* De plus, précédemment il était question d'afficher le contenu des fichiers et non encore une fois le nom des fichiers !

Playground >
	'hello' copyWithRegex: '[elo]+' matchesReplacedWith: 'io'  > Printit-CTRL+P > "'hi'"
	'hello' copyWithRegex: '[elo]+' matchesReplacedWith: 'io'  > Printit-CTRL+P > "'hio'"
	'Ahello' copyWithRegex: '[elo]+' matchesReplacedWith: 'ia' > Printit-CTRL+P > "'Ahia'"

22. (c)WebPage -> "Inst. side method" -> fileName ^ path copyWithRegex: '.*/' matchesReplacedWith: '', CTRL+S,
la méthode "fileName" et le protocole "accessing" ont été créés.

23. Vérification
Playground >
	(WebDir onPath: '...') webPages collect: [:each | each fileName ]  	> Printit-CTRL+P > "#('2018-09-29-UpdatedPharoByExample_EN.html' '2018-09-29-UpdatedPharoByExample_sansimages_EN.html' 'coding.html' 'configuration.html' 'index.html' 'installation.html' 'introduction.html' 'quickstart.html' 'seealso.html' 'startup.html' 'templates.html' 'whatsnew.html')"
	
Ancien
(WebDir onPath: '...') htmlFiles 						> Printit-CTRL+P > "#('2018-09-29-UpdatedPharoByExample_EN.html' '2018-09-29-UpdatedPharoByExample_sansimages_EN.html' 'coding.html' 'configuration.html' 'index.html' 'installation.html' 'introduction.html' 'quickstart.html' 'seealso.html' 'startup.html' 'templates.html' 'whatsnew.html')"
(WebDir onPath: '...') webPages > Printit-CTRL+P > "an Array(a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage)"

* Tous ces ajouts pour avoir la même réponse que "(WebDir onPath: '...') htmlFiles". (Lire ci-dessus)
MDR ! MDR ! MDR ! MDR ! MDR ! MDR ! MDR ! MDR ! MDR ! MDR ! MDR ! MDR ! MDR ! MDR ! MDR ! MDR ! MDR ! 

D11:27 26/05/2021 - F13:49 - Chapitre 15 - p.236/259 FR 345/376 EN
-------------------------------------------------------------------------------------------------------26/05/2021 fin




-------------------------------------------------------------------------------------------------------27/05/2021 debut
D08:22 27/05/2021 - F00:00 - Chapitre 15 - p.236/259 FR 345/376 EN
D08:22 27/05/2021 - F09:54 - Chapitre 15 - p.237/259 FR 345/376 EN

-10 mns - 08:35 27/05/2021 - 08:45 27/05/2021
-10 mns - 09:18 27/05/2021 - 09:28 27/05/2021

Remarque : 
----------

Je fais un parallèle entre l'apprentissage du code Pharo et d'un oeuf dur qu'on souhaite décortiquer.
Étant donné que "c'est simple" alors le plus simple lorsqu'on décortique un oeuf dur est de taper celui-ci contre
une surface dure. Alors, la coquille sera brisée en plusieurs minuscules morceaux.
Mais voilà, enlever ces éclats peut se révéler être un véritable calvaire.
Car, comme souvent, les parties de coquilles resteront collées au reste de l'oeuf occasionnant des trous 
et tout en grognant, maudissant ces éclats s'agglutinant sur les doigts, j'aurais le choix de persévérer ou de jeter l'oeuf.


Extraire des correspondances d'expression régulière - Extracting regex matches
---------------------------------------------------

"Notre tâche suivante consiste à extraire le titre de chaque page HTML. 
Nous avons d'abord besoin d'un moyen d'accéder au contenu de chaque page. C'est simple."
* C'est simple quand tu sais en dehors de ça ?

"vous pourriez avoir des problèmes si vos pages Web contiennent des caractères non-ascii,"

24. (c)WebPage -> "Inst. side method" -> contents ^ (FileStream oldFileOrNoneNamed: path) contents, CTRL+S,
la méthode "contents" a été créée.
Message Pharo :
	- Sends a deprecated message to a known global x ?

25. Vérification
Playground >
	(WebDir onPath: '...') webPages first contents > Printit-CTRL+P > ""'<!DOCTYPE html>
<!-- Created by pdf2htmlEX (https://github.com/coolwanglu/pdf2htmlex) -->
<html xmlns=""http://www.w3.org/1999/xhtml"">
<head>
<meta charset=""utf-8""/>
<meta name=""generator"" content=""pdf2htmlEX""/>
<meta http-equiv=""X-UA-Compatible"" content=""IE=edge,chrome=1""/>
<style type=""text/css"">
/*! 
 * Base CSS for pdf2htmlEX xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

	
Ancien
(WebDir onPath: '...') htmlFiles 					> Printit-CTRL+P > "#('2018-09-29-UpdatedPharoByExample_EN.html' '2018-09-29-UpdatedPharoByExample_sansimages_EN.html' 'coding.html' 'configuration.html' 'index.html' 'installation.html' 'introduction.html' 'quickstart.html' 'seealso.html' 'startup.html' 'templates.html' 'whatsnew.html')"
(WebDir onPath: '...') webPages 					> Printit-CTRL+P > "an Array(a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage)"
(WebDir onPath: '...') webPages collect: [:each | each fileName ]  	> Printit-CTRL+P > "#('2018-09-29-UpdatedPharoByExample_EN.html' '2018-09-29-UpdatedPharoByExample_sansimages_EN.html' 'coding.html' 'configuration.html' 'index.html' 'installation.html' 'introduction.html' 'quickstart.html' 'seealso.html' 'startup.html' 'templates.html' 'whatsnew.html')"
	
D08:22 27/05/2021 - F09:54 - Chapitre 15 - p.237/259 FR 345/376 EN
-------------------------------------------------------------------------------------------------------27/05/2021 fin



-------------------------------------------------------------------------------------------------------28/05/2021 debut
D12:43 28/05/2021 - F00:00 - Chapitre 15 - p.237/259 FR 345/376 EN
D12:43 28/05/2021 - F13:28 - Chapitre 15 - p.237/259 FR 346/376 EN

"NB: dans Pharo, le caret est aussi le mot-clé return, que nous écrivons comme ^ . 
Pour éviter toute confusion, nous écrirons  CARET  lorsque nous utiliserons le caret dans les expressions régulières 
pour nier les ensembles de caractères, mais il ne faut pas oublier, ce sont en fait la même chose.)"

Code : 
------

* Sélectionner tout le code et exécuter (CTRL+P) après 'pharo'.
Playground >
	| re |
	re := '([CARETaeiou]+)([aeiou]+)' asRegex.
	re matchesPrefix: 'pharo'		> Printit-CTRL+P > "false"

* Exécution de "Printit" par ligne.
	| re |						> Printit-CTRL+P > "nil"
	re := '([CARETaeiou]+)([aeiou]+)' asRegex.	> Printit-CTRL+P > "a RxMatcher"
	re matchesPrefix: 'pharo'			> Printit-CTRL+P > "false"

Remarque : 
----------
Pourquoi le résultat est-il "false" ?

* Ajout des lettes "ph".
* Second essai, exécution de "Printit".
	| re |						> Printit-CTRL+P > "nil"
	re := '([CARETphaeiou]+)([aeiou]+)' asRegex.	> Printit-CTRL+P > "a RxMatcher"
	re matchesPrefix: 'pharo'			> Printit-CTRL+P > "true"

	| re |						> Printit-CTRL+P > "nil"
	re := '([CARETaeiou]+)([aeiouph]+)' asRegex.	> Printit-CTRL+P > "a RxMatcher"
	re matchesPrefix: 'pharo'			> Printit-CTRL+P > "false"

	| re |						> Printit-CTRL+P > "nil"
	re := '([CARETaeiouph]+)([aeiou]+)' asRegex.	> Printit-CTRL+P > "a RxMatcher"
	re matchesPrefix: 'pharo'			> Printit-CTRL+P > "true"

	| re |						> Printit-CTRL+P > "nil"
	re := '([CARETpaeiouh]+)([aeiou]+)' asRegex.	> Printit-CTRL+P > "a RxMatcher"
	re matchesPrefix: 'pharo'			> Printit-CTRL+P > "true"

	re subexpression: 1 "'pha'"

	| re |						> Printit-CTRL+P > "nil"
	re := '([CARETaeiou]+)([aeiouph]+)' asRegex.	> Printit-CTRL+P > "a RxMatcher"
	re matchesPrefix: 'pharo'			> Printit-CTRL+P > "false"

* Malgré que la réponse ci-dessus soit fausse, il répond "pha" ?
	re subexpression: 1 "'pha'"

	re subexpression: 2 "'ph'"
	re subexpression: 3 "'a'"


"extraire le titre d'un fichier HTML".
26. (c)WebPage -> "Inst. side method" -> title | re | re := '[\w\W]*<title>(.*)</title>' asRegexIgnoringCase.
					^ (re matchesPrefix: self contents) ifTrue: [ re subexpression: 2 ]
					ifFalse: [ '(', self fileName, ' -- untitled)' ]
la méthode "title" a été créée.

27. Vérification
Playground >
	(WebDir onPath: '...') webPages first title > Printit-CTRL+P > 
	Fatal VM error
	Sorry but the Vm has crashed
	Reason: out of memory
	Current byte code: -1
	Primitive index: -1
	This information will be stored in the file D:\Liberkeys\MyApps\Pharo\crash.dmp with a complete stack dump - OK

13:14 28/05/2021 - arrêt début -> Affiche des lignes contenant un code hexadécimale et des noms - exemple :
	0x41b7d88RxmPredicatematchAgainst:
	0x41b7e48RxmBranchmatchAgainst:
	0x41b7ec@RxmPredicatematchAgainst:
	0x41b7f80RxmBranchmatch

13:18 28/05/2021 - Ne répond pas

13:23 28/05/2021 - Pharo Cog Spur Virtual Machine
		Pharo Cog Spur Virtual Machine ne répond pas - Si vous fermez le programme, vous risquez de perdre des informations.
		-> Fermer le programme
		-> Attendre que le programme réponde

Choix 2 = Attendre que le programme réponde = rien
13:27 28/05/2021 - Choix 1 = Fermer le programme

Ancien
(WebDir onPath: '...') htmlFiles 					> Printit-CTRL+P > "#('2018-09-29-UpdatedPharoByExample_EN.html' '2018-09-29-UpdatedPharoByExample_sansimages_EN.html' 'coding.html' 'configuration.html' 'index.html' 'installation.html' 'introduction.html' 'quickstart.html' 'seealso.html' 'startup.html' 'templates.html' 'whatsnew.html')"
(WebDir onPath: '...') webPages 		 			> Printit-CTRL+P > "an Array(a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage)"
(WebDir onPath: '...') webPages collect: [:each | each fileName ]  	> Printit-CTRL+P > "#('2018-09-29-UpdatedPharoByExample_EN.html' '2018-09-29-UpdatedPharoByExample_sansimages_EN.html' 'coding.html' 'configuration.html' 'index.html' 'installation.html' 'introduction.html' 'quickstart.html' 'seealso.html' 'startup.html' 'templates.html' 'whatsnew.html')"
(WebDir onPath: '...') webPages first contents 				> Printit-CTRL+P > ""'<!DOCTYPE html>
<!-- Created by pdf2htmlEX (https://github.com/coolwanglu/pdf2htmlex) -->
<html xmlns=""http://www.w3.org/1999/xhtml"">
<head>
<meta charset=""utf-8""/>
<meta name=""generator"" content=""pdf2htmlEX""/>
<meta http-equiv=""X-UA-Compatible"" content=""IE=edge,chrome=1""/>
<style type=""text/css"">
/*! 
 * Base CSS for pdf2htmlEX xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

D12:43 28/05/2021 - F13:28 - Chapitre 15 - p.237/259 FR 346/376 EN
-------------------------------------------------------------------------------------------------------28/05/2021 fin




-------------------------------------------------------------------------------------------------------29/05/2021 debut
D09:13 29/05/2021 - F00:00 - Chapitre 15 - p.237/259 FR 346/376 EN
D09:13 29/05/2021 - F10:10 - Chapitre 15 - p.237/259 FR 346/376 EN

* Étant donné le bug précédent, je vais laisser qu'un seul fichier HTML : index.html.

27. Vérification bis
Playground >
	(WebDir onPath: '...') webPages first title > Printit-CTRL+P > Instance of WebPage did not understand #title

* Le bug précédent a fait qu'il n'a pas gardé la sauvegarde de la définition de la méthode "title".

Bis
26. (c)WebPage -> "Inst. side method" -> title | re | re := '[\w\W]*<title>(.*)</title>' asRegexIgnoringCase.
					^ (re matchesPrefix: self contents) ifTrue: [ re subexpression: 2 ]
					ifFalse: [ '(', self fileName, ' -- untitled)' ]

27. Vérification bis bis
Playground >
	(WebDir onPath: '...') webPages first title > Printit-CTRL+P > "'OpenClassrooms.com'"
* Lorsqu’un second fichier HTML est mis dans le dossier du site, celui-ci fait planter la VM.

	Fatal VM error
	Sorry but the Vm has crashed
	Reason: out of memory
	Current byte code: -1
	Primitive index: -1
	This information will be stored in the file D:\Liberkeys\MyApps\Pharo\crash.dmp with a complete stack dump - OK

* Puis la méthode "title" qui a bien été enregistrée n'est plus là.

Bisx2 bisx3
26. (c)WebPage -> "Inst. side method" -> title | re | re := '[\w\W]*<title>(.*)</title>' asRegexIgnoringCase.
					^ (re matchesPrefix: self contents) ifTrue: [ re subexpression: 2 ]
					ifFalse: [ '(', self fileName, ' -- untitled)' ]

27. Vérification bis bis bis
Playground >
	(WebDir onPath: '...') webPages first title > Printit-CTRL+P > "'OpenClassrooms.com'"

* La lecture du fichier "2018-09-29-UpdatedPharoByExample_EN.html", fait planter la VM.
	(WebDir onPath: '...') webPages first title > Printit-CTRL+P >

10:34 30/05/2021
* Ce n'est pas le nom du fichier, mais le contenu du fichier qui fait planter la VM, 
car j'ai renommé "2018-09-29-UpdatedPharoByExample_EN.html" par "PharoByExample.html".

	Fatal VM error
	Sorry but the Vm has crashed
	Reason: out of memory
	Current byte code: -1
	Primitive index: -1
	This information will be stored in the file D:\Liberkeys\MyApps\Pharo\crash.dmp with a complete stack dump - OK

Bisx2 bisx3 bisx4
26. (c)WebPage -> "Inst. side method" -> title | re | re := '[\w\W]*<title>(.*)</title>' asRegexIgnoringCase.
					^ (re matchesPrefix: self contents) ifTrue: [ re subexpression: 2 ]
					ifFalse: [ '(', self fileName, ' -- untitled)' ]

27. Vérification bisx2 bisx3 bisx4 bisx5
Playground >
	(WebDir onPath: '...') webPages first title > Printit-CTRL+P > Fatal VM error


149.Pharobyexample5_Chap_15_webpage_first_title.avi

D09:13 29/05/2021 - F10:10 - Chapitre 15 - p.237/259 FR 346/376 EN
-------------------------------------------------------------------------------------------------------29/05/2021 fin




-------------------------------------------------------------------------------------------------------30/05/2021 debut
D09:47 30/05/2021 - F00:00 - Chapitre 15 - p.237/259 FR 346/376 EN
D09:47 30/05/2021 - F13:20 - Chapitre 15 - p.249/259 FR 362/376 EN

-5 mns - 10:12 30/05/2021 - 10:15 30/05/2021
-28 mns - 12:19 30/05/2021 - 12:47 30/05/2021

* Remplacement du fichier "2018-09-29-UpdatedPharoByExample_EN.html" par deux autres fichiers "index.html" et "installation.html".
27. Vérification bisx2 bisx3 bisx4 bisx5 bisx6
Playground >
	(WebDir onPath: '...') webPages first title > Printit-CTRL+P > "'OpenClassrooms.com'"

* Il transmet seulement le titre d'un fichier, mais sans être verrouillé sur le fichier "index.html".
27. Vérification bisx2 bisx3 bisx4 bisx5 bisx6 bisx7
Playground >
	(WebDir onPath: '...') webPages first title > Printit-CTRL+P > "'OpenClassrooms.com'"

09:55 30/05/2021
Plus de substitutions de chaînes - More string substitutions
---------------------------------

trivial : Très courant, très commun.

À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------
"Nous devons seulement faire attention à une chose. 
Étant donné que la variable homePath ne se termine pas par un / , 
nous devons en ajouter un, de sorte que le chemin relatif n'inclut pas de / ."

Code : 
------

* Je ne sais pas où il va chercher cette réponse "/index.html", car j'ai supprimé ce fichier du répertoire de Pharo.

Playground > 
	'/home/testweb/index.html' copyWithRegex: '/home/testweb' matchesReplacedWith: '' > "'/index.html'"

	'/home/testweb/index.html' copyWithRegex: '/home/testweb/'matchesReplacedWith: '' > "'index.html'"

28. (c)WebPage -> "Inst. side method" -> relativePath ^ path copyWithRegex: homePath, '/' matchesReplacedWith: '', CTRL+S,
la méthode "relativePath" et le protocole "as yet unclassified" ont été créés.

29. (c)WebPage -> "Inst. side methode" -> link ^ '<a href="', self relativePath, '">', self title, '</a>', CTRL+S,
la méthode "link" (protocole - accessing) a été créée.

-5 mns - 10:12 30/05/2021 - 10:15 30/05/2021


30. Vérification
Playground >
	(WebDir onPath: '...') webPages first link > Printit-CTRL+P > "'<a href=""D:\Liberkeys\MyApps\Pharo\Didacticiel_Hindex.html"">Privoxy 3.0.24 User Manual</a>'"

* Le retour de la commande est incomplète, car le nom du répertoire est "Didacticiel_HTML" donc "Didacticiel_HTML\PharoByExample.html".

Ancien
(WebDir onPath: '...') htmlFiles 					> Printit-CTRL+P > "#('2018-09-29-UpdatedPharoByExample_EN.html' '2018-09-29-UpdatedPharoByExample_sansimages_EN.html' 'coding.html' 'configuration.html' 'index.html' 'installation.html' 'introduction.html' 'quickstart.html' 'seealso.html' 'startup.html' 'templates.html' 'whatsnew.html')"
(WebDir onPath: '...') webPages 					> Printit-CTRL+P > "an Array(a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage a WebPage)"
(WebDir onPath: '...') webPages collect: [:each | each fileName ]  	> Printit-CTRL+P > "#('2018-09-29-UpdatedPharoByExample_EN.html' '2018-09-29-UpdatedPharoByExample_sansimages_EN.html' 'coding.html' 'configuration.html' 'index.html' 'installation.html' 'introduction.html' 'quickstart.html' 'seealso.html' 'startup.html' 'templates.html' 'whatsnew.html')"
(WebDir onPath: '...') webPages first contents 				> Printit-CTRL+P > ""'<!DOCTYPE html>
<!-- Created by pdf2htmlEX (https://github.com/coolwanglu/pdf2htmlex) -->
<html xmlns=""http://www.w3.org/1999/xhtml"">
<head>
<meta charset=""utf-8""/>
<meta name=""generator"" content=""pdf2htmlEX""/>
<meta http-equiv=""X-UA-Compatible"" content=""IE=edge,chrome=1""/>
<style type=""text/css"">
/*! 
 * Base CSS for pdf2htmlEX xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
(WebDir onPath: '...') webPages first title 				> Printit-CTRL+P > "'OpenClassrooms.com'"

10:53 30/05/2021
* Pour faire suite au plantage de la VM, je suis obligé de recréer "relativePath" et "link".

* Bisx3
28. (c)WebPage -> "Inst. side method" -> relativePath ^ path copyWithRegex: homePath, '/' matchesReplacedWith: '', CTRL+S,
la méthode "relativePath" et le protocole "as yet unclassified" ont été créés.
Message Pharo :
	- Unclassified methods x ?

Bisx3
29. (c)WebPage -> "Inst. side methode" -> link ^ '<a href="', self relativePath, '">', self title, '</a>', CTRL+S,
la méthode "link" (protocole - accessing) a été créée.


30. Vérification
Playground >
	(WebDir onPath: '...') webPages first link > Printit-CTRL+P >  "'<a href=""D:\Liberkeys\MyApps\Pharo\Didacticiel_HOpenClassrooms.html"">OpenClassrooms.com</a>'"

* Le retour de la commande est incomplète, car le nom du répertoire est "Didacticiel_HTML" donc "Didacticiel_HTML\OpenClassrooms.html".


10:58 30/05/2021
Générer le plan du site - Generating the site map 
------------------------

* Attention, la classe est "WebDir" et la méthode "webDirs".

"génération du plan du site,"
31. 'c)WebDir -> Inst. side method -> webDirs ^ webDir directoryNames collect: [ :each | WebDir onPath: webDir pathString, '/', each
home: homePath ]
la méthode "webDirs" a été créée.
Messages Pharo : 
	- (WebDir) Refers to class name instead of "self class" x ?
	- Unclassified methods x ?

"Nous devons générer des listes à puces HTML contenant des liens pour chaque page Web d'un répertoire Web. 
Les sous-répertoires doivent être mis en retrait dans leur propre liste à puces."
32. 'c)WebDir -> Inst. side method -> printTocOn: aStream self htmlFiles ifNotEmpty: [aStream nextPutAll: '<ul>'; cr.
					self webPages do: [:each | aStream nextPutAll: '<li>'; nextPutAll: each link;
					nextPutAll: '</li>'; cr]. self webDirs do: [:each | each printTocOn: aStream].
					aStream nextPutAll: '</ul>'; cr]
la méthode "printTocOn:" a été créée.

"Nous créons un fichier appelé toc.html dans le répertoire Web racine et y vidons le plan du site."
33. (c)WebDir -> Inst side method -> tocFileName ^ 'toc.html'
la méthode "tocFileName" a été créée.
Messages Pharo : 
	- Unclassified methods x ?
	- Methods implemented but not sent x ?

* C'est interminable leur truc là.
34. (c)WebDir -> Inst side method -> makeToc
					| tocStream |
					tocStream := (webDir / self tocFileName) writeStream.
					self printTocOn: tocStream.
					tocStream close.
la méthode "makeToc" a été créée.
Messages Pharo : 
	- Unclassified methods x ?
	- Methods implemented but not sent x ?

"générer une table des matières pour un répertoire Web arbitraire"
35. Playground >
		WebDir selectHome makeToc > Printit - CTRL+P > Choose directory -> Didacticiel_HTML.
	"Instance of FileReference did not understand #a"
		Stack - WebDir class - selectHome
		Source - a (chooseDirectory a WebDir)

* Le répertoire a déjà été renseigné précédemment.
* Je passe mon tour.


11:16 30/05/2021
15.2 Syntaxe Regex - Regex syntax
-------------------

* Tu crois que je vais me souvenir de tous ces opérateurs après lecture ?

À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)


11:25 30/05/2021
Classes de personnages - Character classes
-----------------------

Syntaxe - p. 241 FR 352 EN - résumé de la syntaxe vue jusqu'à présent :

Syntaxe - p. 243 FR 353 EN - Les classes de caractères peuvent également inclure les éléments suivants compatibles grep (1):


* On est loin de la simple syntaxe contenu dans une carte postale.
C'est ce qui s'appelle "recevoir le coup de bâton derrière la tête".


11:32 30/05/2021
Classes de caractères spéciales - Special character classes
--------------------------------


11:36 30/05/2021
Correspondance des limites - Matching boundaries
--------------------------

Syntaxe - p. 244 FR 355 EN - Le dernier groupe d'expressions primitives spéciales ci-après est utilisé pour faire correspondre les limites des chaînes.

* Faut-il imprimer tous ces tableaux syntaxiques ?


11:41 30/05/2021
API Regex
----------

"Jusqu'à présent, nous nous sommes concentrés principalement sur la syntaxe des expressions rationnelles. Nous allons
maintenant examiner de plus près les différents messages compris par les chaînes et les expressions rationnelles."

* Quand il y en a plus, il y en a encore. :-(
* De mon point de vue, c'est de la publicité mensongère que vous faites avaler au lecteur lorsqu'il s'agit
d'une simple syntaxe contenue sur une carte postale.


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

"Le message prefixMatchesRegex: est exactement comme matchesRegex, 
sauf que l'ensemble du récepteur n'est pas censé correspondre à l'expression régulière passée en argument; 
il suffit d'en faire correspondre un seul préfixe."


11:49 30/05/2021
Interface d'énumération
------------------------


11:51 30/05/2021
Remplacement et traduction
--------------------------


11:51 30/05/2021
Interface de niveau inférieur
-----------------------------


* J'ai modifié la valeur "a WebDir" pour enregistrer le fichier "toc.html" = sans résultat.
	- WebDir
	- aWebDir
	- Didacticiel_HTML
	- 'Didacticiel_HTML'
	- Fuck

* La création d'un dossier n'a posé aucun problème.


12:08 30/05/2021
Le Matcher
----------

* Ouais, mais, je n'ai pas envie de créer un matcher à l'aide de l'une des méthodes proposées.

"Ici, nous envoyons  matchesIn:  pour collecter toutes les correspondances trouvées dans une chaîne:"

* Super, amuse-toi.

* Je suis déçue, car aucun commentaire n'a été rattaché à la méthode "subexpressionCount".
		- subexpressionCount	^markerCount // 2

* Est-ce que je suis censé retenir encore toutes ces choses ? 
(subexpressionCount, sous-expression:, subBeginning: et subEnd:)

-28 mns - 12:19 30/05/2021 - 12:47 30/05/2021

* Ce n'est pas le jour, mais le numéro du jour. Nuance.

Code : 
------

| date result |
date :=
'(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d\d?)\s*,\s*19(\d\d)'
asRegex.
result := (date matches: 'Aug 6, 1996')
ifTrue: [{ (date subexpression: 4) .
(date subexpression: 2) .
(date subexpression: 3) } ]
ifFalse: ['no match'].
result
>>> #('96' 'Aug' '6')

Playground >
	| date result |
date := '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d\d?)\s*,\s*19(\d\d)' asRegex.
result := (date matches: 'Aug 6, 1996') ifTrue: [{ (date subexpression: 4) . (date subexpression: 2) . (date subexpression: 3) } ] ifFalse: ['no match'].
result								> Printit-CTRL+P > "#('96' 'Aug' '6')"

* MDR ! En changeant la date, il ne trouve rien.
	| date result |
date := '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d\d?)\s*,\s*19(\d\d)' asRegex.
result := (date matches: 'May 30, 2021') ifTrue: [{ (date subexpression: 4) . (date subexpression: 2) . (date subexpression: 3) } ] ifFalse: ['no match'].
result								> Printit-CTRL+P > "'no match'"

	| date result |
date := '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d\d?)\s*,\s*19(\d\d)' asRegex.
result := (date matches: 'May 29, 1999') ifTrue: [{ (date subexpression: 4) . (date subexpression: 2) . (date subexpression: 3) } ] ifFalse: ['no match'].
result  							> Printit-CTRL+P > "#('99' 'May' '29')"

* À partir de l'année "2000", c'est la fin du monde ! :-)

	| date result |
date := '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d\d?)\s*,\s*19(\d\d)' asRegex.
result := (date matches: 'May 29, 2000') ifTrue: [{ (date subexpression: 4) . (date subexpression: 2) . (date subexpression: 3) } ] ifFalse: ['no match'].
result  							> Printit-CTRL+P > "'no match'"

* Avec un jour de la semaine ? "'no match'"

| date result |
date := '(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+(\d\d?)\s*,\s*19(\d\d)' asRegex.
result := (date matches: 'May Monday, 1998') ifTrue: [{ (date subexpression: 4) . (date subexpression: 2) . (date subexpression: 3) } ] ifFalse: ['no match'].
result 								> Printit-CTRL+P > "'no match'"


12:58 30/05/2021
Dénombrement et remplacement - Enumeration and Replacement
-----------------------------


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

"Il existe également les méthodes suivantes pour parcourir les correspondances dans les flux :
matchesOnStream:, matchesOnStream:do:, matchesOnStream:collect:, copyStream:to:replacingMatchesWith: 
and copyStream:to:translatingMatchesUsing:."

* Super ! 


13:01 30/05/2021
La gestion des erreurs - Error Handling
----------------------

Mouais, super !

Playground >
	['+' asRegex] on: RegexError do: [:ex | ^ ex printString ] > Printit > "'RegexSyntaxError:  nullable closure'"


13:02 30/05/2021
Notes de mise en œuvre de Vassili Bykov - Implementation Notes by Vassili Bykov
---------------------------------------

"Que regarder en premier. 
Dans 90% des cas, la méthode String >> matches-Regex: est tout ce dont vous avez besoin pour accéder au package."

* Faux, c'est la souris, Playground et "Implementors - CTRL+M". 

* C'est à retenir et à ranger dans le bottin ? Parce que sur la carte postale ça ne rentre pas.
(RxParser , RxMatcher)

"avec pas mal de tests supplémentaires ajoutés, donc les chances sont bonnes qu'il n'y ait pas trop de bugs."
* MDR ! "les chances sont bonnes qu'il n'y ait pas trop de bugs".
* Pas trop ! La certitude c'est qu'il va en avoir des bugs.

"quiconque que je n'ai pas encore rencontré ou entendu,
mais qui est d'accord que cela n'a pas été une perte de temps totale."
* Si tu le dis.

* Balancer des commandes et des paragraphes c'est bien beau, 
mais c'est impossible de conceptualiser ces énièmes commandes dans un projet.


13:14 30/05/2021
15.5 Résumé du chapitre - Chapter Summary
-----------------------

de manière triviale : Très courant, très commun. Les actes triviaux de la vie quotidienne.

13:20 30/05/2021 - fin chap. 15

D09:47 30/05/2021 - F13:20 - Chapitre 15 - p.249/259 FR 362/376 EN
-------------------------------------------------------------------------------------------------------30/05/2021 fin




-------------------------------------------------------------------------------------------------------01/06/2021 debut
D08:58 01/06/2021 - F00:00 - Chapitre 16 - p.250/259 FR 363/376 EN
D08:58 01/06/2021 - F13:34 - Chapitre 16 - p.251/259 FR 365/376 EN

-10 mns - 09:53 01/06/2021 - 10:03 01/06/2021
-10 mns - 10:33 01/06/2021 - 10:43 01/06/2021
-7 mns - 12:12 01/06/2021 - 12:19 01/06/2021


Classes et métaclasses 
----------------------

Objet -> instance d'une classe

"Ce modèle objet capture l'essence de la programmation orientée objet et est léger, simple, élégant et uniforme."
* Les pidgins anglais s'enchaînent, entraînés par d'autres relations qui prennent la tête à la rétention, 
se répètent, décrochent vers des destinations incompréhensibles, 
boguent, erreurs, indigestes, complexes, mal mises, informes et disparates.

"Cependant, les implications de cette uniformité peuvent semer la confusion chez les nouveaux arrivants."
* Inverser les rôles en faisant accepter comme vrai cette inégalité organisationnelle simpliste et prise de tête c'est affligeant. 

* Le manque d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.

Définition : implications : Situation d’une personne impliquée dans une affaire fâcheuse. 

"Néanmoins, le but de ce chapitre est double: (1) aller le plus loin possible et (2) montrer qu'il n'y a
ici rien de complexe, de magique ou de spécial: juste des règles simples appliquées uniformément."
* Rien de complexe avec des règles simples appliquées uniformément ! C'est se foutre de la gueule du lecteur. 
Parce qu’à ce stade, je repense à certaines étapes prises de tête en lisant ce livret et la pratique du programme Pharo.
C'est une perte de temps indéniable et la poudre aux yeux ce sont ces règles.

-10 mns - 09:53 01/06/2021 - 10:03 01/06/2021

16.1 Règles pour les classes et les métaclasses
------------------------------------------------

* Dans ce livret beaucoup de règles ont été énoncées : quelles sont-elles déjà ?
 - Les règles restantes ont des sélecteurs qui correspondent aux éléments HTML,
 - Les quelques règles suivantes spécifient les propriétés des en-têtes de second niveau ( h2 ),
 - une feuille de style CSS se compose d'un ensemble de règles qui spécifient comment formater des éléments HTML donnés,
 - en définissant le style de méthode, qui doit renvoyer une chaîne contenant les règles CSS pour ce composant,
 - Les tests qui enfreignent les règles de Feathers peuvent constituer de bons tests d'acceptation,
 - Règles de plumes pour les tests unitaires,
 - Une conséquence de ces règles est que chaque définition de classe et chaque méthode appartient à exactement un package,
 - Pour être précis, les règles pour ce qui se passe dans un package sont les suivantes,
 - Nous allons maintenant examiner un aspect de Pharo qui n'est pas si facilement couvert par nos cinq règles: les variables partagées,
 - Les règles de recherche de méthode que nous présentons ici sont conceptuelles; 
 - mais vous ne devriez jamais être en mesure de détecter qu'ils font quelque chose de différent de nos règles,
 - Le modèle objet est basé sur un ensemble de règles simples qui sont appliquées uniformément, (6.1)
 - des problèmes avec ces règles de priorité, vous pouvez commencer simplement par mettre des parenthèses chaque fois que vous souhaitez distinguer deux messages ayant la même priorité,
 - Le tableau ci-dessus montre les messages envoyés écrits selon les règles et les messages équivalents envoyés si les règles n'existent pas,
 - Ce résultat est peut-être inattendu mais découle directement des règles utilisé pour envoyer des messages.
 - Les règles de composition des messages sont simples mais elles entraînent une incohérence pour l'exécution des envois de messages arithmétiques exprimés en termes de messages binaires,
 - Comme il n'y a pas de priorité parmi les messages binaires, le message le plus à gauche + est évalué en premier même si selon les règles de l'arithmétique, le * doit être envoyé en premier,
 - Malheureusement, les règles sont un peu trop simplistes pour les envois de messages arithmétiques,
 - Comme le montrent ces exemples, les règles de syntaxe de Pharo garantissent généralement que les messages envoyés peuvent être lus de manière naturelle,
 - Ces règles conduisent à un ordre de lecture très naturel. Si vous voulez être sûr que vos messages sont envoyés dans l'ordre que vous souhaitez, vous pouvez toujours ajouter d'autres parenthèses,
 - Quelques règles simples basées sur ces différents messages déterminent l'ordre dans lequel les messages sont envoyés,
 - Ces règles rendent le code Pharo aussi facile à lire que possible. Et la plupart du temps, vous n'avez pas à penser aux règles,
 - Ci-dessous, vous obtenez les commentaires de l'Assistant Qualité: il exécute automatiquement des règles de qualité sur votre code et les signale,
 - 

* pas si facilement couvert par nos règles,
* règles conceptuelles,
* quelque chose de différent de nos règles,
* des problèmes avec ces règles de priorité,
* résultat inattendu mais découle directement des règles utilisé,
* les règles de composition des messages sont simples mais elles entraînent une incohérence,

Rappel : 
--------

6.1 Les règles du modèle

Le modèle objet est basé sur un ensemble de règles simples qui sont appliquées uniformément.
Les règles sont les suivantes :

Règle 1. Tout est objet.
Règle 2. Chaque objet est une instance d'une classe.
Règle 3. Chaque classe a une superclasse.
Règle 4. Tout se passe en envoyant des messages.
Règle 5. La recherche de méthode suit dynamiquement la chaîne d'héritage.


6.1 The rules of the model

The object model is based on a set of simple rules that are applied uniformly.
The rules are as follows:

Rule 1. Everything is an object.
Rule 2. Every object is an instance of a class.
Rule 3. Every class has a superclass.
Rule 4. Everything happens by sending messages.
Rule 5. Method lookup dynamically follows the inheritance chain.
        

----------------------------


16.1 Règles pour les classes et les métaclasses
 
Le modèle d'objet Pharo est basé sur un nombre limité de concepts appliqués uniformément. 
Pour vous rafraîchir la mémoire, voici les règles du modèle d'objet que nous avons exploré dans le chapitre : 
Le modèle d'objet Pharo.
 
Règle 1  Tout est un objet.
Règle 2  Chaque objet est une instance d'une classe. 
Règle 3  Chaque classe a une superclasse.
Règle 4  Tout se passe en envoyant des messages.
Règle 5  La recherche de méthode suit la chaîne d'héritage.


16.1 Rules for classes and metaclasses

The Pharo object model is based on a limited number of concepts applied uniformly. 
To refresh your memory, here are the rules of the object model that we explored in Chapter : 
The Pharo Object Model.

Rule 1 Everything is an object.
Rule 2 Every object is an instance of a class.
Rule 3 Every class has a superclass.
Rule 4 Everything happens by sending messages.
Rule 5 Method lookup follows the inheritance chain.


Question : 
----------
* Dans le paragraphe 16.1, la Règle 5 ne suit plus "dynamiquement" la chaîne d'héritage par rapport à la règle 5 du paragraphe 6.1.


-10 mns - 10:33 01/06/2021 - 10:43 01/06/2021


Remarque / interrogation : 
--------------------------
* Dans le chapitre 6, les "règles du modèle" sont similaires au chapitre 16 des "Règles pour les classes et les métaclasses".
Le contenu est le même, mais l'intitulé du titre change, encore une manière d'embrouiller le lecteur ?


Règle 6  Chaque classe est une instance d'une métaclasse.
Règle 7  La hiérarchie des métaclasses est parallèle à la hiérarchie des classes.
Règle 8  Chaque métaclasse hérite de la classe et du comportement.   
Règle 9  Chaque métaclasse est une instance de métaclasse. 
Règle 10  La métaclasse de Metaclass est une instance de Metaclass. 


Questions / Remarques :
-----------------------

"classe -> instance de métaclasse ->  instance de métaclasse ->  instance de métaclasse". 
* Je ne comprends pas l'intérêt d'ajouter ces wagons, c'est comme le fait d'ajouter "Array with: 1 with: 2 with: 3 with: 4 with: 5 with: 6"
à ce train-là tu peut aller jusqu'à l'infini.

* Lorsque je lance l'inspecteur de "#class", celui-ci m'affiche la "Class Hierarchy" à l'envers de celle du "SystemBrowser" ?
(Interrogation et question déjà posée précédemment)
"Le manque d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes."

* Depuis "SystemBrowser", la lecture s'effectue de bas en haut. (1) à (9)
"Le manque d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes."

SystemBrowser > 
volet package - (pa)Collections-Strings >
	|
volet package - (pa)Base >		(8)								(9)
	|->	volet classe - (c)ProtoObject ------- Inst. side ------- Methods ---> volet protocole > instance side, class membership
		|->	onglet classe >	(c)ProtoObject					|-> -> volet méthode > class
					ProtoObject subclass: #ProtoObject			|-> onglet méthode > class
					instanceVariableNames: ''					|-> class
					classVariableNames: 'DependentsFields'					"Primitive. Answer the object which is the receiver's class. Essential.
* Package change >			package: 'Kernel-Objects'						See Object documentation whatIsAPrimitive."
					ProtoObject superclass: nil						<primitive: 111>
			/|\		(7)									self primitiveFailed
		volet classe - (c)  Object
		|->	onglet classe >	(c)Object
					ProtoObject subclass: #Object
					instanceVariableNames: ''
					classVariableNames: 'DependentsFields'		
* Package change >			package: 'Kernel-Objects'
			/|\		(6)
		volet classe - () Collection
		|->	onglet classe >	(c)Collection
					Object subclass: #Collection
					instanceVariableNames: ''
					classVariableNames: ''		
					package: 'Collections-Abstract-Base'
			/|\		(5)
		volet classe - ()  SequenceableCollection
		|->	onglet classe >	(c)SequenceableCollection
					Collection subclass: #SequenceableCollection
					instanceVariableNames: ''
					classVariableNames: ''		
* Package change >			package: 'Collections-Abstract-Base'
			/|\		(4)
		volet classe - ()   ArrayedCollection
		|->	onglet classe >	(c)ArrayedCollection
					SequenceableCollection subclass: #ArrayedCollection
					instanceVariableNames: ''
					classVariableNames: ''		
					package: 'Collections-Strings-Base'
			/|\		(3)
		volet classe - |   String
		|->	onglet classe >	(c)String
					ArrayedCollection subclass: #String
					instanceVariableNames: ''
					classVariableNames: 'AsciiOrder CSLineEnders CSNonSeparators CSSeparators CaseInsensitiveOrder CaseSensitiveOrder LowercasingTable Tokenish TypeTable UppercasingTable'		
					package: 'Collections-Strings-Base'
			/|\		(2)
		volet classe - |    Symbol
		|->	onglet classe >	 (c)Symbol
					String subclass: #Symbol
					instanceVariableNames: ''
					classVariableNames: 'NewSymbols OneCharacterSymbols SelectorTable SymbolTable'		
					package: 'Collections-Strings-Base'
			/|\		(1)
		volet classe - |     ByteSymbol
		|->	onglet classe > (c)ByteSymbol
					Symbol variableByteSubclass: #ByteSymbol
					instanceVariableNames: ''
					classVariableNames: ''		
					package: 'Collections-Strings-Base'


* Depuis "Inspector", la lecture s'effectue de haut en bas.	
"Le manque d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes."	

Playground > #class -> Inspectit-CTRL+I -> Inspector on a ByteSymbol (#class)
	Meta ->
	Class Hierarchy -> 
	ByteSymbol
	Symbol
	String
	ArrayedCollection
	SequenceableCollection
	Collection
	Object
	ProtoObject		-> Methods -> class - (pr) class membership


* (pr) = protocole
* Le code ci-dessous, "primitive: 111", se lit de gauche à droite et "self primitiveFailde" de droite à gauche. 
class
	"Primitive. Answer the object which is the receiver's class. Essential. See 
	Object documentation whatIsAPrimitive."

	<primitive: 111>
	self primitiveFailed

-7 mns - 12:12 01/06/2021 - 12:19 01/06/2021

Questions :
-----------

* Pourquoi la méthode "class" commence-t-elle à partir de "SortedCollection" dans la Figure 16-1, alors que l'inspecteur 
commence à "ByteSymbol" ? "class" est un message envoyé à "a SortedCollection".

* Depuis Playground comment envoyer un message "class" à la classe miroir "a SortedCollection" ?

251 FR - 364 EN

Figure 16-1 - p.364 EN : ? - Recherche : Fin 13:22 01/06/2021 - test Debut 13:22 01/06/2021 - test Fin 13:32 01/06/2021 
----------------------------------------

10.14 Chapter summary - To sort a collection, send it the message asSortedCollection.

a SortedCollection (couleur rouge) -> Playground > Implementors-CTRL+M -> renvoie vers la classe > SortedCollection du package: 'Collections-Sequenceable-Ordered'
aSortedCollection (couleur rouge) -> Playground > Implementors-CTRL+M -> renvoie vers rien

SortedCollection (couleur blanc) -> Playground > Implementors-CTRL+M -> renvoie vers la classe > SortedCollection du package: 'Collections-Sequenceable-Ordered'

asSortedCollection (couleur rouge) -> Playground > Implementors-CTRL+M -> Collection - asSortedCollection - Collections-Abstract
									> Array2D - asSortedCollection - Collections-Sequenceable

as SortedCollection (couleur rouge) -> Playground > Implementors-CTRL+M -> renvoie vers la classe > SortedCollection du package: 'Collections-Sequenceable-Ordered'

"Le manque d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes."



Rappel : 
---------
Question : 
---------

Si "Object new printString='an Object'" affiche "an" et que "LRUCache new printString='a LRUCache(#0 0/16 [ 1 ] 0%)'" 
affiche "a" qu'est-ce qui les différencie ?
Pourquoi l'un affiche "a" et l'autre "an" ?

Recherche : 
----------
Différence entre "a" et "an" ?

Réponses : 
----------

1. "The default implementation simply writes the class name preceded by a or an."
"L'implémentation par défaut écrit simplement le nom de classe précédé d'un "a" ou d'un "an"."

2. Si la classe commence par une voyelle alors "an" est envoyé à la variable "title" sinon "a".

3. Méthode Object >> printOn: est très probablement l'une des méthodes que vous remplacerez le plus fréquemment. 
Cette méthode prend comme argument un Stream sur lequel sera écrite une représentation String de l'objet. 
L'implémentation par défaut écrit simplement le nom de classe précédé de a ou an. 
Object >> printString renvoie la chaîne qui est écrite.
(p. 133 FR 196 EN - Impression - Printing)

4. Si la classe commence par une voyelle alors 'an' est envoyé à la variable "title" sinon 'a'.
* "fillRectangle" interroge quel "Implementors" ? (fillRectangle: est rattaché à color: donc la méthode "fillRectangle:color:"
est annexé à la classe "Canvas" ou la copie miroir "aCanvas". (classe miroir)


Recherche : 
-----------
"as"

p.133 FR
Par exemple, la classe  OpalCompiler  ne redéfinit pas la méthode printOn: et l'envoi du message  printString 
à une instance exécute les méthodes définies dans  Object.
OpalCompiler new printString >>> 'an OpalCompiler'

p.173 FR
La méthode as-Morph a une implémentation par défaut dans la classe Object class qui crée simplement un StringMorph.

"Le manque d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes."

D08:58 01/06/2021 - F13:34 - Chapitre 16 - p.251/259 FR 365/376 EN
-------------------------------------------------------------------------------------------------------01/06/2021 fin




-------------------------------------------------------------------------------------------------------02/06/2021 debut
D11:00 02/06/2021 - F00:00 - Chapitre 16 - p.251/259 FR 365/376 EN
D11:00 02/06/2021 - F13:55 - Chapitre 16 - p.251/259 FR 365/376 EN

-12 mns - 11:51 02/06/2021 - 12:03 02/06/2021 
-10 mns - 12:46 02/06/2021 - 12:56 02/06/2021

16.2 Revisiter le modèle objet Pharo
	- Règle 1. Puisque tout est un objet, une collection ordonnée dans Pharo est également un objet.

Interrogation : 
---------------

Le paragraphe 16.2 revisite "répète" ce qui a été présenté précédemment (p.218 and Co.), 
ça ne fait pas avancer le lecteur cette histoire.

Rappels : 
---------
p.218 EN
Vous pouvez également créer de nombreuses collections avec withAll: aCollection.
You can also create many collections with withAll: aCollection.
Array withAll: #(7 3 1 3)
>>> #(7 3 1 3)

OrderedCollection withAll: #(7 3 1 3)
>>> an OrderedCollection(7 3 1 3)

SortedCollection withAll: #(7 3 1 3)
>>> a SortedCollection(1 3 3 7)

You can also use message addAll: aCollection to add all elements of one
kind of collection to another kind:
(1 to: 5) asOrderedCollection addAll: '678'; yourself
>>> an OrderedCollection(1 2 3 4 5 6 7 8)

p.221 EN
Conversion It is possible to get an OrderedCollection from an Array (or
any other collection) by sending the message asOrderedCollection:
#(1 2 3) asOrderedCollection
>>> an OrderedCollection(1 2 3)
'hello' asOrderedCollection
>>> an OrderedCollection($h $e $l $l $o)

Figure 10-19 Some collection classes categorized by implementation technique.


"Règle 1. Puisque tout est un objet, une collection ordonnée dans Pharo est également un objet."
OrderedCollection withAll: #(4 5 6 1 2 3)
>>> an OrderedCollection(4 5 6 1 2 3)

* "OrderedCollection, an OrderedCollection, asOrderedCollection", ce n'est pas la classe OrderedCollection qui répond,
mais ça classe miroir ?

Code : Tests
------

* L'argument "#".

Playground >
	OrderedCollection withAll: #(4 5 6 1 2 3) > CTRL+P-Printit >  "an OrderedCollection(4 5 6 1 2 3)" 
	an OrderedCollection withAll: #(4 5 6 1 2 3) > CTRL+P-Printit > #an is missing, and does not understand #OrderedCollection
	asOrderedCollection withAll: #(4 5 6 1 2 3) > CTRL+P-Printit > #aOrderedCollection is missing, and does not understand #withAll:

-12 mns - 11:51 02/06/2021 - 12:03 02/06/2021 

Règle 2. 

Code : Tests
------

Playground >
	(OrderedCollection withAll: #(4 5 6 1 2 3)) class 	> "OrderedCollection"
	(OrderedCollection class withAll: #(4 5 6 1 2 3)) 	> Instance of Metaclass did not understand #withAll:
	(an OrderedCollection withAll: #(4 5 6 1 2 3)) class 	> #an is missing, and does not understand #OrderedCollection
	(asOrderedCollection withAll: #(4 5 6 1 2 3)) class 	> #asOrderedCollection is missing, and does not understand #withAll:


* "asOrderedCollection" est une méthode.
* "OrderedCollection" est une classe.
* "an OrderedCollection" est la classe miroir de "OrderedCollection".


Questions :
-----------
* Pourquoi mettre "class" en fin de code ?
* Pourquoi indiquer "class" alors que "OrderedCollection" est déjà défini en tant que telle ?
* Si "an OrderedCollection" est la classe miroir de "OrderedCollection" pourquoi ne donne-t-elle pas de réponse ? 

	(class OrderedCollection withAll: #(4 5 6 1 2 3))  	> is missing
	class (OrderedCollection withAll: #(4 5 6 1 2 3))  	> is missing

Règle 3. "Chaque classe a une superclasse. 
La superclasse de OrderedCollection est SequenceableCollection et la superclasse de SequenceableCollection est Collection."

Interrogation : 
---------------
C'est maintenant que je réalise et surtout que je comprends cette phrase "chaque classe a une superclasse", alors
que je l'associais seulement à l'héritage.

"Chaque classe a un superclasse".
SystemBrowser >
	Volet classe >
		(c)ProtoObject
		(c)  Object ------------------- La superclasse de la Classe ProtoObject est nil
		()    Collection -------------- La superclasse de la Classe Collection est Object
		()     SequenceableCollection - La superclasse de la Classe SequenceableCollection est Collection
		()      OrderedCollection ----- La superclasse de la Classe OrderedCollection est SequenceableCollection

Code : 
------

Playground >
		OrderedCollection superclass		> Printit > "SequenceableCollection"
		SequenceableCollection superclass 	> Printit > "Collection"
		Collection superclass 			> Printit > "Object"
		Object superclass 			> Printit > "ProtoObject"
		ProtoObject superclass  		> Printit > "nil"
		nil superclass  			> Printit > #superclass was sent to nil

-10 mns - 12:46 02/06/2021 - 12:56 02/06/2021

"Prenons un exemple. 
Lorsque nous envoyons le message asSortedCollection, nous convertissons la collection ordonnée en une collection triée. 
Nous vérifions simplement comme suit :"

Playground >
	(OrderedCollection withAll: #(4 5 6 1 2 3)) asSortedCollection class 	> (OrderedCollection withAll: #(4 5 6 1 2 3)) asSortedCollection class "SortedCollection"
	(withAll: #(4 5 6 1 2 3) OrderedCollection) asSortedCollection class 	> Variable or expression expected ->
	#(4 5 6 1 2 3) asSortedCollection class 				> "SortedCollection"
	
	#(4 5 6 1 2 3) OrderedCollection 					> Instance of Arrary did not understand #OrderedCollection 
	#(4 5 6 1 2 3) SortedCollection						> Instance of Arrary did not understand #SortedCollection 

	#(4 5 6 1 2 3) asOrderedCollection 					> "an OrderedCollection(4 5 6 1 2 3)"
	#(4 5 6 1 2 3) asSortedCollection 					> "a SortedCollection(1 2 3 4 5 6)"

Question / interrogation :
--------------------------

(OrderedCollection withAll: #(4 5 6 1 2 3)) asSortedCollection class 	> (OrderedCollection withAll: #(4 5 6 1 2 3)) asSortedCollection class "SortedCollection"

Je ne comprends pas la réponse du code ci-dessus.
 - Pourquoi créer une collection avec la classe "OrderedCollection" au lieu de la méthode "asOrderedCollection" ?
 - Pourquoi mélanger une classe "OrderedCollection" en l'indiquant avec "class" juste avant une méthode "asSortedCollection" ?

 - Pourquoi ne pas indiquer deux classes ? (OrderedCollection et SortedCollection)
 - Pourquoi ne pas indiquer deux classes du fait qu'il y est indiqué "class" à la fin du code ?

 - Pourquoi ne pas indiquer deux méthodes (asOrderedCollection et asSortedCollection) affichant des résultats contrairement aux classes ?
 - Quel est l'intérêt de mettre "asSortedCollection" si je ne peux pas inverser ce qui est entre parenthèses ?

* Le manque d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.

Règle 4.  
"Tout se passe en envoyant des messages, nous pouvons donc en déduire que withAll: est un message à OrderedCollection 
et asSortedCollection sont des messages envoyés à l'instance de collection commandée, 
et superclass est un message à OrderedCollection et SequenceableCollection, et Collection."

Mise à jour : 09:05 03/06/2021
------------

	(su)SequenceableCollection							 UndefinedObject
		|										?
 	   superclasse									     classe
		|										|
	     message									     message
		|										|
	(OrderedCollection 				withAll: #(4 5 6 1 2 3)) asSortedCollection 				class
 	       /|\ |->(su)SequenceableCollection	\|/			       	       /|\
		|  |->(sc)#OrderedCollection  		 |					|
		|  |->(iVN) 'array			Class side			     Methods
		|	     firstIndex	 		 |					|
		|	     lastIndex'		(pr)instance creation			(pr)converting
		|	        			 |					|	     
		|				(c)ClapContext class			(c)Collection
		|		       	 		 |  |->(iVN)''				| |->(su)Object	
		|		       	 		 |  					| |->(sc)#Collection
		|		       	 		 |  					|
		|		       	 		 |	     				|
		|		       	 		 |	     				|
		|		       	 		 |	    				|
		|		       	 		 |					|
(pa)Collections-Sequenceable-Ordered   	 		 |				(pa)Collections-Abstract-Base		
(pa)Collections-Sequenceable			(pa)Clap-Core				(pa)Collections-Abstract
		|	      	 			 |					|
		|<----------------------------------< message >-------------------------------->|

				Autre proposition
* (pa) = package		(pac)
* (su) = superclasse 		(spc)
* (mt) = métaclasse		(mtc)
* (c) = classe			(c)
* (cm) = classe miroir		(cm)
* (pr) = protocole		(pr)
* (m) = méthode			(m)

* (sc) = sous-classe - subclass (sbc)
* (iVN) = instanceVaraibleNames (iVN)
* (cVN) = classVariableNames	(cVN)
* (v) = variable		(v)

Règle 5.

D11:00 02/06/2021 - F13:55 - Chapitre 16 - p.251/259 FR 365/376 EN
-------------------------------------------------------------------------------------------------------02/06/2021 fin




-------------------------------------------------------------------------------------------------------03/06/2021 debut
D08:39 03/06/2021 - F00:00 - Chapitre 16 - p.251/259 FR 365/376 EN
D08:39 03/06/2021 - F13:38 - Chapitre 16 - p.251/259 FR 365/376 EN

-15 mns - 11:25 03/06/2021 - 11:40 03/06/2021
-3 mns - 11:52 03/06/2021 - 11:55 03/06/2021
-10 mns - 12:23 03/06/2021 - 12:33 03/06/2021


Règle 5. 
La recherche de méthode suit la chaîne d'héritage, donc lorsque nous envoyons le message 'classe' au
résultat de (OrderedCollection withAll: # (4 5 6 1 2 3)) asSortedCollection, 
le message est traité lorsque la méthode correspondante est trouvée dans la classe Object,
comme le montre la figure 16-1.

Method lookup follows the inheritance chain, so when we send the message 'class' to 
the result of (OrderedCollection withAll: #(4 5 6 1 2 3)) asSortedCollection, 
the message is handled when the corresponding method is found in the class Object, 
as shown in Figure 16-1.

-15 mns - 11:25 03/06/2021 - 11:40 03/06/2021
-3 mns - 11:52 03/06/2021 - 11:55 03/06/2021
-10 mns - 12:23 03/06/2021 - 12:33 03/06/2021


"le message est traité lorsque la méthode correspondante est trouvée dans la classe Object" (?????) ->	   (c) Object -> Non
														   |
													   ()   Collection -> Oui
														   |
													   ()    SequenceableCollection -> Non
														   |
													   ()     OrderedCollection -> Non
														   |
										(cm)a SortedCollection ->  (c)     SortedCollection <----------------------------
											       /|\							       /|\
								Recherche de la méthode correspondant à "asSortedCollection"					|								
												|							   	|
Interrogation : Il traite deux réponses avant 'class' et après 'class' ?	"a SortedCollection(1 2 3 4 5 6)" ---->----   class ---> résultat -->  "SortedCollection"
(avant : "a SortedCollection(1 2 3 4 5 6)", après : "SortedCollection")							       /|\			       /|\
											   resultat			    message			    résultat			
	  	----------------------------------------->---------------------------------------			        |
		|					 |					|				|
	(OrderedCollection 				withAll: #(4 5 6 1 2 3))      asSortedCollection		      class
 	        | |->(su)SequenceableCollection	 	 |			       	        |			        |
		| |->(sc)#OrderedCollection  		 |					|				|
		| |->(iVN) 'array			Class side			     Methods			     Methods
		|	    firstIndex	 		 |					|    				|
		|	    lastIndex'		(pr)instance creation			(pr)converting			(pr)class membership
		|	        			 |					|     				|	     
		|				(c)ClapContext class			(c)Collection	   		(c)ProtoObject
		|		       	 		 |  |->(iVN)''				| |->(su)Object			| |->(su)nil
		|		       	 		 |  					| |->(sc)#Collection		| |->(su)ProtoObject
		|		       	 		 |  					|				| |->(sc)#ProtoObject
		|		       	 		 |	     				|				|
		|		       	 		 |	     				|				|
		|		       	 		 |	    				|				|
		|		       	 		 |					|				|
(pa)Collections-Sequenceable-Ordered   	 		 |				(pa)Collections-Abstract-Base		|		
(pa)Collections-Sequenceable			(pa)Clap-Core				(pa)Collections-Abstract	(pa)Kernel-Objets


										
				Autre proposition
* (pa) = package		(pac)
* (su) = superclasse 		(spc)
* (mt) = métaclasse		(mtc)
* (c) = classe			(c)
* (cm) = classe miroir		(cm)
* (pr) = protocole		(pr)
* (m) = méthode			(m)

* (sc) = sous-classe - subclass (sbc)
* (iVN) = instanceVaraibleNames (iVN)
* (cVN) = classVariableNames	(cVN)
* (v) = variable		(v)


Playground > (Printit - CTRL+P)
	ClapContext class superclass 						> "ClapExpression class"
	#Object class 								> "ByteSymbol"
	ByteSymbol class  							> "ByteSymbol class"
	Object class  								> "Object class"
	(OrderedCollection withAll: #(4 5 6 1 2 3)) asSortedCollection class 	> "SortedCollection"
	(OrderedCollection withAll: #(4 5 6 1 2 3)) asSortedCollection 		> "a SortedCollection(1 2 3 4 5 6)"

	* L'inspecteur n'affiche aucune différence entre les deux codes ci-dessous alors que les résultats sont les mêmes.
	(OrderedCollection withAll: #(4 5 6 1 2 3)) asSortedCollection class
	#(4 5 6 1 2 3) asSortedCollection class


Questions / Interrogations :
---------------------------

"lorsque nous envoyons le message 'class' au résultat de (OrderedCollection withAll: # (4 5 6 1 2 3)) asSortedCollection"
						|
					   résultat
						|
				"a SortedCollection(1 2 3 4 5 6)"
						|
		La lecture commence de gauche à droite puis se termine de droite à gauche. (?)
						|
"le message est traité lorsque la méthode correspondante est trouvée dans la classe Object"
						|
		"a SortedCollection" n'est pas une méthode, mais une classe miroir,
			donc la méthode correspondante ? "asSortedCollection"
		Cela signifie qu'il ne traite pas la réponse ( "SortedCollection"), 
		mais le message (class) et le contenu (asSortedCollection). (?)
						|
	1. Le contenu entre parenthèses se trouve à gauche de "asSortedCollection" alors que le résultat est à droite ?
	
	2. Pourquoi s'embêter d'une réponse "a SortedCollection" alors qu’"asSortedCollection(4 5 6 1 2 3)" serait plus simple et logique ?
	
	3. 	#(4 5 6 1 2 3) asSortedCollection "a SortedCollection(1 2 3 4 5 6)"
		asSortedCollection #(4 5 6 1 2 3) > End of statement list encountered ->
		#(4 5 6 1 2 3) SortedCollection > Instance of Array did not understand #SortedCollection
		SortedCollection #(4 5 6 1 2 3) > End of statement list encountered ->
	
	4. Pourquoi afficher une réponse "a SortedCollection(1 2 3 4 5 6)" alors qu'une classe "SortedCollection" existe ?
		
	5. Pourquoi avoir une réponse différente de la méthode "asSortedCollection" utilisé comme outil ?
	
	6. Lorsqu'un singe utilise ces mains (Playground) pour utiliser l'outil cailloux (asSortedCollection) pour casser des noix (1 2 3 4 5 6), 
	pensez-vous qu'il utilisera des baguettes (a SortedCollection) pour manger le contenu de la noix ?
  
						|
	Playground > SortedCollection > Printit > SortedCollection usingMethods  
	> "xxxx Collection>>#asSortedCollection Collection>>#asSortedCollection: xxxx"
						|
		"la méthode correspondante est trouvée dans la classe Object"
						|
		La méthode n'est pas trouvée dans la classe Object, mais Collection. (?)
						|
		De plus, lorsque tu sélectionnes "Object" dans le volet classe 
		et que tu recherches la méthode "asSortedCollection" dans le volet méthode, 
				celle-ci est introuvable.
						|
* Le manque d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.

6. Lorsqu'un singe utilise ces mains (Playground) pour utiliser l'outil cailloux (asSortedCollection) pour casser des noix (1 2 3 4 5 6), 
pensez-vous qu'il utilisera des baguettes (a SortedCollection) pour manger le contenu de la noix ?

Lorsque le Phare (Playground) maintient la lanterne (asSortedCollection) en guise de signal (1 2 3 4 5 6), 
pensez-vous que les bateaux partiront à l'opposé ? 


Question / Interrogation : 
--------------------------

Figure 16-1
Il traite deux réponses avant 'class' et après 'class' ? 
(avant : "a SortedCollection(1 2 3 4 5 6)", après : "SortedCollection")


D08:39 03/06/2021 - F13:38 - Chapitre 16 - p.251/259 FR 365/376 EN
-------------------------------------------------------------------------------------------------------03/06/2021 fin




-------------------------------------------------------------------------------------------------------04/06/2021 debut
D11:20 04/06/2021 - F00:00 - Chapitre 16 - p.251/259 FR 365/376 EN
D11:20 04/06/2021 - F13:50 - Chapitre 16 - p.253/259 FR 367/376 EN

-13 mns - 12:20 04/06/2021 - 12:33 04/06/2021


16.3 Chaque classe est une instance d'une métaclasse - Every class is an instance of a metaclass

"chaque classe a une superclasse"


"Les métaclasses sont implicites"

Définitions :
------------- 
implicites : Qui n’est pas exprimé formellement, mais peut être déduit par le contexte; sous-entendu. 
Clause implicite dans un contrat. Condition implicite à une vente. Réponse implicite.

élidées : S’effacer devant un élément vocalique initial. Dans l’expression l’écolière, le a de l’article la s'élide.

p. 252 FR 365 EN
"Les métaclasses sont créées automatiquement lorsque vous définissez une classe."
"Metaclasses are automatically created when you define a class."
"les classes ordinaires sont nommées, les métaclasses sont anonymes."
"Whereas ordinary classes are named, metaclasses are anonymous."

	superclasse
	   |
	Classe miroir 		   		   -->         ?	-->	?
	   |
	Classe ordinaire : nommés <- création auto. -> qu'une instance <--> métaclasse : anonyme


Playground > (Printit-CTRL+P)
	SortedCollection superclass  	> "OrderedCollection"
	SortedCollection class  	> "SortedCollection class"

	Object class			> "Object class"


Questions / Interrogations : 
--------------------------

1. Il est question ici de deux choses portant des noms différents "classe vs metaclasse".
Lorsque j'interroge une "classe" sur sa "métaclasse", pourquoi utiliser "class" alors qu'il s'agit de "métaclass" ?
Un mollusque est différent d'un requin.

2. Depuis "Playground", lorsque j'ajoute les lettres "meta" à "class" apparaît un menu proposant "metaclass".
Donc, étant donné que cette option est proposée pourquoi utilisée "class" au lieu de "metaclass" ?
(metaclass, metaclass:, metaclassClass, metaclassClass:, metaclassCreated:)

3. Le paragraphe 16.3 concerne la "métaclasse", mais il faut utiliser "class" dans "Playground" pour connaître la liaison entre une classe et une métaclasse.
(Si j'interroge un crabe pour savoir comment décoller un mollusque, alors je ne vais pas me tourner vers le requin.)  

* Le manque d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.

p. 252 FR 366 EN
"En fait, les métaclasses ne sont pas vraiment anonymes, leur nom est déduit de celui de leur instance unique."
"In fact metaclasses are not truly anonymous, their name is deduced from the one of their single instance."
* Donc pour résumer, c'est anonyme sans vraiment l'être. MDR !

Playground >
	SortedCollection class name	> "'SortedCollection class'"
	OrderedCollection class name 	> "'OrderedCollection class'"
	OrderedCollection name 		> "#OrderedCollection"
	OrderedCollection className 	> "'OrderedCollection class'"

	OrderedCollection classOrMetaClass: OrderedCollection	>
	OrderedCollection classOrMetaClass: aClass		>
	OrderedCollection classOrMetaClass: aBehavior 		>

	self styler classOrMetaClass: aBehavior			>


Définition : 
------------
déduit : Retrancher ou rabattre (une certaine somme) d’une somme à acquitter.


* Le manque d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.

* Je considère ces paragraphes comme une perte de temps passé à ne pas programmer.


Questions / Interrogations : 
----------------------------

1. Pourquoi je n'utilise plus "class" pour interroger des "métaclasses", mais "subclasses" ? 

p. 252 FR
"Interroger des métaclasses
Le fait que les classes soient également des objets nous permet de les interroger facilement en envoyant des messages.
Regardons :"

OrderedCollection sous-classes
 
p. 366 EN
"Querying Metaclasses
The fact that classes are also objects makes it easy for us to query them by
sending messages. Let’s have a look:"

OrderedCollection subclasses

-13 mns - 12:20 04/06/2021 - 12:33 04/06/2021

* Depuis SystemBrowser -> OrderedCollection, il faut cliquer sur "Hier." pour afficher les classes du dessous. 

Questions / Interrogations : 
--------------------------

1. Étant donné qu'en dessus d'une classe c'est une superclasse alors en dessous de quoi s'agit-il ?

2. La commande "OrderedCollection subclasses" interroge des "métaclasses", mais le résultat est similaire à celui du volet "classe" 
affichant les classes situées en dessous de la classe "OrderedCollection" ? 


Playground >
	OrderedCollection subclasses  	> "{ObjectFinalizerCollection. SortedCollection. WeakOrderedCollection. OCLiteralList. GLMMultiValue}"
	
	Tests :
	OrderedCollection subclass	> Instance of OrderedCollection class did not understand #subclass
	subclass: #OrderedCollection 	> Variable or expression expected ->
	SortedCollection subclasses 	> "#()"
	SortedCollection. subclasses 	> "nil"
	OrderedCollection. class  	> "nil"
	OrderedCollection. subclasses   > "nil"
		
* 
	package - superclasse
			|
	package -    classe 		- protocole - méthode
			|
		SortedCollection \
			|	 | class (?) metaclass 
			|	 |
			|	 SortedCollection class 
		  metaclasse
			|
		OrderedCollection \
			|	   | subclasses (?) metaclass    
			|	   |
			|	{ObjectFinalizerCollection. SortedCollection. WeakOrderedCollection. OCLiteralList. GLMMultiValue}

		  
* Les figures "16.2" et "16.3" sont similaires.


Question / Interrogation : 
--------------------------

* Je ne comprends pas ce que viennent faire les commandes (allSuperclasses, instVarNames, allInstVarNames, selectors),
alors qu'il s'agit de métaclasse ?

SortedCollection allSuperclasses
>>> an OrderedCollection(OrderedCollection SequenceableCollection Collection Object ProtoObject)

SortedCollection instVarNames
>>> #('sortBlock')

SortedCollection allInstVarNames
>>> #('array' 'firstIndex' 'lastIndex' 'sortBlock')

SortedCollection selectors
>>> #(#indexForInserting: #sort:to: #addAll: #reSort #sortBlock:
#copyEmpty #addFirst: #insert:before: #defaultSort:to: #median
#at:put: #add: #= #collect: #flatCollect: #sort: #join: #sortBlock)

D11:20 04/06/2021 - F13:50 - Chapitre 16 - p.253/259 FR 367/376 EN
-------------------------------------------------------------------------------------------------------04/06/2021 fin




-------------------------------------------------------------------------------------------------------06/06/2021 debut
D10:48 06/06/2021 - F00:00 - Chapitre 16 - p.253/259 FR 367/376 EN
D10:48 06/06/2021 - F13:11 - Chapitre 16 - p.254/259 FR 368/376 EN

Questions / Interrogations : 
--------------------------

Pourquoi la commande "SortedCollection allInstVarNames" affiche-t-elle des noms de variables non listés depuis l'onglet
classe de la classe "SortedCollection" ? (array, firstIndex, lastIndex)

Pourquoi ces variables apparaissent-elles dans le volet protocole alors que ce sont des variables qui ressortent lors de 
la commande "SortedCollection allInstVarNames" ?

Le lecteur doit-il s'attendre à un autre tour de passe-passe quant à ces noms de variables protocolaires ?

SystemBrowser -> Vars -> array, firstIndex, lastIndex
Playground -> Implementors > array (2) -> Var (pr)array - Method (m)array
			   > firstIndex (8) -> Var (pr)firstIndex - Method (m) firstIndex
			   > lastIndex (3) -> Var (pr)lastIndex - Method (m) lastIndex

La classe "MorphTreeChunk" affiche des "Vars" à la fois depuis le volet protocole et son onglet, contrairement à SortedCollection ?


* Le manque de cohérence, d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.


11:36 06/06/2021
16.4 La hiérarchie des métaclasses est parallèle à la hiérarchie des classes - The metaclass hierarchy parallels the class hierarchy
----------------------------------------------------------------------------

"La règle 7 dit que la superclasse d'une métaclasse ne peut pas être une classe arbitraire: elle est contrainte d'être la
métaclasse de la superclasse de l'instance unique de la métaclasse."

* A part être "parallèle" rien n'indique "une classe arbitraire".

Définition : 
------------
arbitraire : Qui est choisi sans règles précises; qui ne relève d’aucune règle. Une quantité arbitraire.


Règle 1  Tout est un objet.
Règle 2  Chaque objet est une instance d'une classe. 
Règle 3  Chaque classe a une superclasse.
Règle 4  Tout se passe en envoyant des messages.
Règle 5  La recherche de méthode suit la chaîne d'héritage.
Règle 6  Chaque classe est une instance d'une métaclasse.
Règle 7  La hiérarchie des métaclasses est parallèle à la hiérarchie des classes.
Règle 8  Chaque métaclasse hérite de la classe et du comportement.   
Règle 9  Chaque métaclasse est une instance de métaclasse. 
Règle 10  La métaclasse de Metaclass est une instance de Metaclass. 

13:39 07/06/2021 - ajout
* Plus d'informations avec la "Figure 16-9 All metaclasses are instances of the class Metaclass, even the metaclass of Metaclass."

Question / interrogation : 
--------------------------

* "classe arbitraire" ?
À force, je m'y perds avec tous ce bordel.

			  					NON
	superclasse	<-instance unique->	metaclasse	classe
								arbitraire		
			classe			metaclasse

Code : 
------
Playground > Printit 
	SortedCollection class superclass		>  "OrderedCollection class"

* Il doit se sentir seul "class", car aucun "allClass" ou de ""allClasses".
Tandis que "superclass", sont équivalent est "allSuperclasses" ?
Mais "superclasses" n'existe pas contrairement à "allSuperclasses".

* Le manque de cohérence, d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.

13:39 07/06/2021 - ajout
* Plus d'informations avec la "Figure 16-9 All metaclasses are instances of the class Metaclass, even the metaclass of Metaclass."

	Tests
	SortedCollection classes superclasses
	SortedCollection Classes
	SortedCollection
	SortedCollection allSuperclasses 		> "an OrderedCollection(OrderedCollection SequenceableCollection Collection Object ProtoObject)"
	SortedCollection selectors class superclass  	> "ArrayedCollection"
	SortedCollection class allSuperclasses  	> "an OrderedCollection(OrderedCollection class SequenceableCollection class Collection class Object class ProtoObject class Class ClassDescription Behavior Object ProtoObject)"

	SortedCollection className  			> "'SortedCollection class'"
	SortedCollection class superclassName 		>
	SortedCollection superclassName 		>

	Object class superclass 			> "ProtoObject class"
	ProtoObject class superclass  			> "Class"
	Class class superclass  			> "ClassDescription class"
	ClassDescription class superclass  		> "Behavior class"
	Behavior class superclass 			> "Object class"
	Object class superclass 			> "ProtoObject class"

	Object superclass class 			> "ProtoObject class"
	ProtoObject superclass class 			> "UndefinedObject"
	UndefinedObject superclass class 		> "Object class"

	Object class superclass class 			> "Metaclass"
	Metaclass superclass class  			> "ClassDescription class"
	ClassDescription class superclass class  	> "Metaclass"
	Metaclass superclass class  			> "ClassDescription class"

	OrderedCollection class superclass class 	> "Metaclass"

	Object class superclass class 			> "Metaclass"
	ProtoObject class superclass class 		> "Class class"
	Class class superclass class 			> "Metaclass"


	a SortedCollection allSuperclasses		> missing
	a SortedCollection instVarName  		> missing
	a SortedCollection allInstVarNames		> missing
	a SortedCollection selectors			> missing
	a SortedCollection class superclass		> missing
	a SortedCollection superclass class		> missing
	'a SortedCollection' class superclass		> "String"
	"a SortedCollection" class superclass		> 
	(a SortedCollection) class superclass		>
	a SortedCollection class			> missing
	
13:39 07/06/2021 - ajout
* Plus d'informations avec la "Figure 16-9 All metaclasses are instances of the class Metaclass, even the metaclass of Metaclass."

Questions / Interrogations : 
--------------------------

1. Pourquoi "ProtoObject class" n'est-il pas une métaclasse, mais une "Class class" ?

2. Pourquoi ne peut-on utiliser "Metaclass", étant donné que c'est la réponse d'"Object class superclass class" ? 

3. Pourquoi "metaclass" ou "metaclasses" ou "allMetaclass" ne peuvent-ils pas être utilisés comme "class", "superclasses", "allSuperclass" ?

4. Pourquoi mettre "a SortedCollection" en premier alors qu'il s'agit d'une classe miroir de la classe "SortedCollection" ? 

5. Pourquoi ne peut-on pas interroger dans "Playground" une "classe miroir" contrairement à une "métaclasse" ?  

6. Pourquoi la Figure 16-3 commence-t-elle par une "classe miroir" qui est censée être en second alors qu'il existe une première classe "SortedCollection" ?

7. Comment créer une "dashboard" qui permettrait de voir les interactions entre tous ces objets visibles, invisibles, partagés, non partagés, etc. ? 
(Une carte similaire à schémas électrique quand celui-ci est actif indique des couleurs de fonctionnements ainsi que le sens du courant.)


Figure 16-3 - p. 367 EN
					Classes					MetaClasses
					ClassDescription -> instance de -> 	ClassDescription class
					Class		-> instance de -> 	Class class
					ProtoObject	 -> instance de ->	ProtoObject class

					Object		 -> instance de ->	Object class
					OrderedCollection -> instance de ->	OrderedCollection class
a SortedCollection -> instance de ->	SortedCollection -> instance de ->	SortedCollection class
 

D10:48 06/06/2021 - F13:11 - Chapitre 16 - p.254/259 FR 368/376 EN
-------------------------------------------------------------------------------------------------------06/06/2021 fin




-------------------------------------------------------------------------------------------------------07/06/2021 debut
D11:02 07/06/2021 - F00:00 - Chapitre 16 - p.254/259 FR 368/376 EN
D11:02 07/06/2021 - F14:17 - Chapitre 16 - p.254/259 FR 368/376 EN

-11 mns - 11:43 07/06/2021 - 11:54 07/06/2021
-6 mns - 12:13 07/06/2021 - 12:19 07/06/2021

Uniformité entre les classes et les objets - Uniformity between Classes and Objects
-------------------------------------------

SystemBrowser > (Hier. - Class side - Methods)

withAll: -> Collection class>>withAll:
				|
			metaclasse
				|-> ()	OrderedCollection class (receveur)

Code : Test - metaclass Collection class - OrderedCollection class
Ex : 
	Object class superclass class 			> "Metaclass"

Tests 
	Collection class superclass class		> "Metaclass"
	OrderedCollection class superclass class	> "Metaclass"


 Autre disposition - Figure 16-4
--------------------------------

13:39 07/06/2021 - ajout
* Plus d'informations avec la "Figure 16-9 All metaclasses are instances of the class Metaclass, even the metaclass of Metaclass."

(c)Class ----------------------------------------> Metaclass
	|						|
(c)ProtoObject ----------------------------------> Class class
	|						|
(c)Object ---------------------------------------> Object class
	|						|
()Collection ------------------------------------> Collection class - Playground > Collection class selectors > "#(#with: #fromSton: #with:with:with:with: #withAll: #with:with: #canonicalArgumentName #with:with:with:with:with: #systemIconName #empty #isAbstract #with:with:with: #approvedSelectorsForMethodFinder #with:with:with:with:with:with:)"
	|						| 	\|/											       \|/
()SequenceableCollection ------------------------> SequenceableCollection class - Playground > SequenceableCollection class selectors > "#(#fromSton: #'<<' #inspectorClass #isAbstract #streamContents: #streamContents:limitedTo: #new:streamContents: #streamSpecies #ofSize:)"
	|						|		\|/										       \|/
chaîne d'héritage				chaîne d'héritage												|
	|						|			\|/ "It returns a new instance of OrderedCollection. p.368 EN"										|
     message					     message													|
	|						|				\|/									|
	>---- Recherche (m)withAll: - metaclass -> OrderedCollection class											|
	|											\|/
Inspectit --> ()OrderedCollection ---------------> (?) an OrderedCollection class (?)		 |								|
	|
()OrderedCollection (m)withAll: #(4 5 6 1 2 3) -->  					"an OrderedCollection(4 5 6 1 2 3)" <----------------------------------<|
	Départ |>---------- classe miroir -------------------(?)-------------------------------->|
	Receveur

"an OrderedCollection" est l'instance de "OrderedCollection".

* Plus d'informations avec la "Figure 16-9 All metaclasses are instances of the class Metaclass, even the metaclass of Metaclass."

Note : 14:14 07/06/2021
------
Ce n'est pas clair entre "()OrderedCollection" et "an OrderedCollection class".
Je perds beaucoup de temps à comprendre ces interrelations qu'à CODER.

-11 mns - 11:43 07/06/2021 - 11:54 07/06/2021
-6 mns - 12:13 07/06/2021 - 12:19 07/06/2021

Autre disposition - Figure 16-4
--------------------------------

()OrderedCollection (m)withAll: #(4 5 6 1 2 3) -> métaclasses -> message -> chaîne d'héritage -> Collection class  -> withAll: -> (4 5 6 1 2 3)
				En parallèle
()OrderedCollection (m)withAll: #(4 5 6 1 2 3) -> classes -> message -> chaîne d'héritage -> Object -> 


14:09 07/06/2021
Codes : 
-------
Playground >
	OrderedCollection withAll: #(4 5 6 1 2 3) > Inspectit-CTRL+I > Inspector on an OrderedCollection (6 items (4 5 6 1 2 3)

	OrderedCollection > Inspectit-CTRL+I > Inspector on an OrderedCollection class (OrderedCollection)
	[???????????) -> an OrderedCollection class


Recherche de "an" - "a" : 
-------------------------

* Je recherche encore une fois l'explication associée à "an" et "a" qui est flou.


Code : tests
----

Color class  "Color class"
Color class superclass  "Object class"
Color selector
Color Selectors  
Color selectors #(#storeArrayOn: #gtInspectorDetailsIn: #raisedColor #privateAlpha #orColorUnlike: #indexInMap: xxxx
Color allClassVarNames #(#DependentsFields #BlueShift #CachedColormaps #ColorRegistry #ComponentMask xxx
Color allClassVarNames #(#DependentsFields #BlueShift #CachedColormaps #ColorRegistry xxxxx
Color allClassVariables an OrderedCollection(#RedShift->20 #CachedColormaps->an Array(an Array(nil xxxx 
Color allClasses 
Color allElements 
Color allEntries 
Color allFilterSelectors
Color allHandlers 
Color allImplementedMessages 
Color allInstVarNames "#(#rgb #cachedDepth #cachedBitPattern #alpha)"
Color allInstanceVariableNames 
Color allInstanceVariables 
Color allInstances (Clor white, black xxx) 
Color allKeys 
Color allLiterals 
Color allManifestClasses
Color allMetaClasses 
Color allMethodSelectors 
Color allMethods (Color#green, xxxxxxx)
Color allMorphs 
Color allNonMetaClasses 
Color allObjects 
Color allOccurrences
Color allPackagesNotRegistered 
Color allPackagesWithSettings 
Color allPathSegments
Color allPoolDictionaryNames 
Color allPosixPermissions
Color allPresentationMethods 
Color allPrimitiveMethods 
Color allProcesses 
Color allProjects
Color allReifications
Color allRemotes 
Color allRemotes 
Color allResolved 
Color allSeen 
Color allSelectedItems 
Color allSentMessages 
Color allSequences 
Color allSettingsState 
Color allSharedPoolNames 
Color allSharedPools  "an OrderedCollection()"
Color allSmartCharacters 
Color allStrategies
Color allSubInstances "an OrderedCollection(color xxxxx)" 
Color allSubbricks
Color allSubclasses  "an OrderedCollection()"
Color allSubclassesKey 
Color allSuperclasses  "an OrderedCollection(Object ProtoObject)"
Color allSuperclassesKey 
Color allSymbols 
Color allSystemHelpPragmas 
Color allSystemPragmas 
Color allTempAccessInstructions
Color allTempNames 
Color allTemporaryVariables 
Color allTemps 
Color allTestSelectors
Color allValidations 


"8.4 Dans Pharo, vous ne pouvez pas perdre de code"
* L'ensemble du projet n'a pas été perdu, mais une infirme partit quand même ce qui a été le cas lors d'un chapitre.

13:39 07/06/2021 - ajout
* Plus d'informations avec la "Figure 16-9 All metaclasses are instances of the class Metaclass, even the metaclass of Metaclass."


Codes : Recherches
-----

* instance-of = la classe (C)anEllipse est une instance de la classe (C)EllipseMorph.

Playground >
anEllipse new openInWorld
EllipseMorph new openInWorld "an EllipseMorph(389318144)"
an EllipseMorph > implementor > ()	EllipseMorph
an EllipseMorph > printit > #an is missing

#anEllipseMorph > implementor > rien
#an EllipseMorph > implementor > rien
#anEllipseMorph > printit > "#anEllipseMorph"

#an EllipseMorph > implementor > ()	EllipseMorph
#an EllipseMorph > printit > #an is missing


OrderedCollection withAll: #(4 5 6 1 2 3) > Inspectit-CTRL+I > Inspector on an OrderedCollection (6 items (4 5 6 1 2 3)

OrderedCollection > Inspectit-CTRL+I > Inspector on an OrderedCollection class (OrderedCollection)
[???????????) -> an OrderedCollection class

Rappel : 
--------
Note : 14:14 07/06/2021
------
Ce n'est pas clair entre "()OrderedCollection" et "an OrderedCollection class".
Je perds beaucoup de temps à comprendre ces interrelations qu'à CODER.

D11:02 07/06/2021 - F14:17 - Chapitre 16 - p.254/259 FR 368/376 EN
-------------------------------------------------------------------------------------------------------07/06/2021 fin




-------------------------------------------------------------------------------------------------------08/06/2021 debut
D09:09 08/06/2021 - F00:00 - Chapitre 16 - p.254/259 FR 368/376 EN
D09:09 08/06/2021 - F12:58 - Chapitre 16 - p.254/259 FR 368/376 EN

-19 mns - 09:50 08/06/2021 - 10:09 08/06/2021
-01 h 20 mns - 10:23 08/06/2021 - 11:43 08/06/2021
-6 mns - 12:00 08/06/2021 - 12:06 08/06/2021

Codes : test suite 
------
Color -> OrderedCollection

OrderedCollection classABooleanMethods 
OrderedCollection classDescriptionsMap
OrderedCollection classGroup
OrderedCollection classGroupSelection
OrderedCollection classHierarchy
OrderedCollection classInstaller  "ShiftClassInstaller"
OrderedCollection classLayout  "a FixedLayout"
OrderedCollection className  "'OrderedCollection class'"
OrderedCollection classPool  "a Dictionary()"
OrderedCollection classSampleWhichHasGroup 
OrderedCollection classScopeForMethods 
OrderedCollection classScopeOfSelectedItems
OrderedCollection classSearch 
OrderedCollection classSearchField 
OrderedCollection classSelected 
OrderedCollection classSelection
OrderedCollection classSelector
OrderedCollection classSelectorDictionary
OrderedCollection classSelectorMorph
OrderedCollection classSide  "OrderedCollection class"
OrderedCollection classTag 
OrderedCollection classToPackage
OrderedCollection classToUse
OrderedCollection classVarNames  "#()"
OrderedCollection classVarRefs 
OrderedCollection classVariable
OrderedCollection classVariableNames
OrderedCollection classVariablesString  "''"
OrderedCollection classVariablesString  "''"
OrderedCollection mapClass 
OrderedCollection classIsMeta 
OrderedCollection meta class 
OrderedCollection class meta
OrderedCollection class metaClassSelectorDictionary 
OrderedCollection class metaObject 
OrderedCollection class metaSuperclass 
OrderedCollection metaObject
OrderedCollection metaSuperclass 
Color metaObject
Object metaObject
OrderedCollection metaclass  
OrderedCollection metaclassClass 
OrderedCollection metaSuperclass
OrderedCollection metacelloPackageNames 
OrderedCollection metacelloVersion 
OrderedCollection metaclass 
OrderedCollection metadata 
OrderedCollection methodDict > a MethodDictionary(#add:->OrderedCollection>>#add: #add:after:->OrderedCollection>>#add:after: 
OrderedCollection method 
OrderedCollection methodCategory 
OrderedCollection methodClass 
OrderedCollection methodClassName 
OrderedCollection methodHeader 
OrderedCollection methodList 
OrderedCollection methodNotUsesGlobal 
OrderedCollection methodScope 
OrderedCollection methodUsesGlobal 
OrderedCollection methodView 
OrderedCollection methodVisibilityProvider 

-19 mns - 09:50 08/06/2021 - 10:09 08/06/2021

* En ajoutant "superclass" au code, ça remonte "Vue SystemBrowser" de superclasse en superclasse jusqu'à "ProtoObject class" et plus encore.


Question / Interrogation : 
--------------------------

1. Lorsque je mets "class" à la suite d'une classe, ça m'affiche le résultat d'une métaclasse et ce n'est pas logique.


Codes : 
-------

Playground > (PrintIt-CTRL+P)
SortedCollection class superclass 					"OrderedCollection class"
SortedCollection class superclass superclass 					"SequenceableCollection class"
SortedCollection class superclass superclass superclass  				"Collection class"
SortedCollection class superclass superclass superclass superclass 				"Object class"
SortedCollection class superclass superclass superclass superclass superclass  				"ProtoObject class"
SortedCollection class superclass superclass superclass superclass superclass superclass  			"Class"
SortedCollection class superclass superclass superclass superclass superclass superclass superclass  			"ClassDescription"
SortedCollection class superclass superclass superclass superclass superclass superclass superclass superclass  		"Behavior"
SortedCollection class superclass superclass superclass superclass superclass superclass superclass superclass superclass		"Object"
SortedCollection class superclass superclass superclass superclass superclass superclass superclass superclass superclass superclass  		"ProtoObject"
SortedCollection class superclass superclass superclass superclass superclass superclass superclass superclass superclass superclass superclass  	"nil"
SortedCollection class superclass superclass superclass superclass superclass superclass superclass superclass superclass superclass superclass superclass	#superclass was sent to nil
 
-01 h 20 mns - 10:23 08/06/2021 - 11:43 08/06/2021

SortedCollection superclass  			"OrderedCollection"
SortedCollection superclass superclass  		"SequenceableCollection"
SortedCollection superclass superclass superclass  		"Collection"
SortedCollection superclass superclass superclass superclass  		"Object"
SortedCollection superclass superclass superclass superclass superclass 	"ProtoObject"
SortedCollection superclass superclass superclass superclass superclass superclass  	"nil"
SortedCollection superclass superclass superclass superclass superclass superclass superclass 	#superclass was sent to nil

SortedCollection class "SortedCollection class"
SortedCollection class class  "Metaclass"
SortedCollection class class class  "Metaclass class"
SortedCollection class class class class  "Metaclass"
SortedCollection class class class class class  "Metaclass class"
SortedCollection class class class class class class "Metaclass"
SortedCollection class class class class class class class  "Metaclass class"
SortedCollection class class class class class class class class "Metaclass"
SortedCollection class class class class class class class class class  "Metaclass class"
SortedCollection class class class class class class class class class class "Metaclass"
SortedCollection class class class class class class class class class class class  "Metaclass class"

SortedCollection superclass class  "OrderedCollection class"
SortedCollection superclass class class  "Metaclass"
SortedCollection superclass class class class  "Metaclass class"
SortedCollection superclass class class class class "Metaclass"
SortedCollection superclass class class class class class "Metaclass class"
SortedCollection superclass class class class class class class  "Metaclass"
SortedCollection superclass class class class class class class class  "Metaclass class"
SortedCollection superclass class class class class class class class class  "Metaclass"
SortedCollection superclass class class class class class class class class class  "Metaclass class"
SortedCollection superclass class class class class class class class class class class  "Metaclass"

aSortedCollection class "UndefinedObject"
aSortedCollection class superclass  "Object"
aSortedCollection class superclass superclass  "ProtoObject"
aSortedCollection class superclass superclass superclass  "nil"
aSortedCollection class superclass superclass superclass superclass #aSortedColleciton is missing, and does not understand #superclass

-6 mns - 12:00 08/06/2021 - 12:06 08/06/2021

anOrderedCollection class  "UndefinedObject"
anOrderedCollection class class  "UndefinedObject class"
anOrderedCollection class class class "Metaclass"
anOrderedCollection class class class class  "Metaclass class"
anOrderedCollection class class class class class  "Metaclass"
anOrderedCollection class class class class class class  "Metaclass class"
anOrderedCollection class class class class class class class "Metaclass"
anOrderedCollection class class class class class class class class  "Metaclass class"
anOrderedCollection class class class class class class class class class "Metaclass"


Mise à jour : D09:12 09/06/2021 - F11:42 09/06/2021

Commandes principales : (package, IVN, CVN, sous-classe, superclasse, metaclasse, classe, protocole, méthode)
-----------------------

C = Commande

Package
Cpackage - C package
Playground > (Printit-ctrl+p)
SortedCollection package "a RPackage(Collections-Sequenceable)"


InstVarNames
CIVN - civn - instance variables names - noms variables d'instance - noms des variables d'instance 
* Affiche seulement les noms des variables d'instance de la classe en cours.
Playground > (Printit-ctrl+p)
SortedCollection instVarNames "#(#sortBlock)"


AllInstVarNames
CIVN all - civn all - all instance variables names - all noms des variables d'instance
* Affiche tous les noms de variables d'instance.
Les trois premiers Noms des Variables d'instance sont rattachés à "OrderedCollection" et le dernier à "SortedCollection".
Playground > (Printit-ctrl+p)
SortedCollection allInstVarNames  "#(#array #firstIndex #lastIndex #sortBlock)"

Note InstVarNames - AllInstVarNames : 
-------------------------------------
Il aurait fallu qu'il affiche "OrderedCollection>>#array.", similaire au retour de la commande "SortedCollection methods".
Car on ne sait pas qu'elle est sa relation principale entre "#array" et "SortedCollection" ou " "? - OrderedCollection" ou "? - Object".


ClassVarNames
CCVN - ccvn - classe variables names - noms variables classe - noms des variables de classe
* Affiche seulement les noms des variables de classe de la classe en cours.
Playground > (Printit-ctrl+p)
SortedCollection classVarNames "#()"


AllClassVarNames
CCVN all - ccvn all - all classe variables names - all noms variables classe -  all noms des variables de classe
* Affiche tous les Noms des Variables de Classe et celle du dessous est rattachée à la classe "Object".
Playground > (Printit-ctrl+p)
SortedCollection allClassVarNames "#(#DependentsFields)"

Note ClassVarNames - AllClassVarNames : 
---------------------------------------
Il aurait fallu qu'il affiche "Object>>#DependentsFields.", similaire au retour de la commande "SortedCollection methods".
Car on ne sait pas qu'elle est sa relation principale entre "#DependentsFields" et "SortedCollection" ou "? - Object".


Subclasses = SystemBrowser -> Hier.
Csubclasses - C subclasses
* Affiche la/les sous-classes de la classe en cours.
Playground > (Printit-ctrl+p)
OrderedCollection subclasses "{ObjectFinalizerCollection. SortedCollection. WeakOrderedCollection. OCLiteralList. GLMMultiValue}"

Note Subclasse : 
----------------
Pharo propose "subclass", "subclasses" et "allSubclasses".

p.97 FR 142 EN - "Hier. = Hiérarchie" 
"sélectionner une classe particulière d'intérêt, tels que ImageMorph puis cliquez sur le bouton hiérarchie (Hier.).
Vous verrez alors dans le second volet une hiérarchie de classes affichant toutes les superclasses et sous-classes de la classe sélectionnée."


Superclass = SystemBrowser -> Hier.
Csuperclass - C superclass
* Affiche la classe du dessus de celle en cours autrement dit la superclasse.
Playground > (Printit-ctrl+p)
SortedCollection superclass "OrderedCollection"

Notes Superclass : 
------------------
Celle du dessus est "superclasse" tandis que celle du dessous ?
Comment interroger les classes du dessous ? Sous-classes - allSubclasses 
C'est la confusion entre "superclass" et "allSuperclasses".


Metaclasse
Cclass - C class
* Affiche la métaclasse de la classe en cours.			Classe				Metaclasse
Playground > (Printit-ctrl+p)					SortedCollection instance de ->	SortedCollection class
SortedCollection class  "SortedCollection class"


Classe = SystemBrowser -> Hier. |  = SystemBrowser -> Volet méthode -> Inheritance
* Affiche la liste des classes héritées de la classe en cours. 
Playground > (Printit-ctrl+p)
SortedCollection allSuperclasses "an OrderedCollection(OrderedCollection SequenceableCollection Collection Object ProtoObject)"
OrderedCollection allSuperclasses "an OrderedCollection(		 SequenceableCollection Collection Object ProtoObject)"

Sous-classe = SystemBrowser -> Hier.
SortedCollection allSubclasses "an OrderedCollection()"
OrderedCollection allSubclasses "an OrderedCollection(ObjectFinalizerCollection SortedCollection WeakOrderedCollection OCLiteralList GLMMultiValue)"


Notes Classe : 
--------------
Cela aurait été plus simple de mettre "metaclass" plutôt que "class", comme le démontre "package". ("selectors" et "metaclass" ont le même nombre de lettres.)
Ça manque de cohérence.
C'est la confusion entre "allSuperclasses" et "superclass".
p.97 FR 142 EN - "Hier. = Hiérarchie" 
"sélectionner une classe particulière d'intérêt, tels que ImageMorph puis cliquez sur le bouton hiérarchie (Hier.).
Vous verrez alors dans le second volet une hiérarchie de classes affichant toutes les superclasses et sous-classes de la classe sélectionnée."


Protocole
Cprotocols - C protocols
* Affiche les protocoles
Playground > (Printit-ctrl+p)
SortedCollection protocols "#(#enumerating #adding #accessing #copying #'math functions' #comparing #splitjoin #sorting #private)"
OrderedCollection protocols "#(#enumerating #sorting #converting #adding #splitjoin #copying #'*Fuel-Core' #initialization #accessing #removing #private)"

Note Protocole : 
----------------
Pharo propose protocol, protocoles, allProtocol, allProtocols, allProtocolsNames, seule la seconde proposition donne une réponse. 


Methode
Cmethods - C methods - Cselectors - C selectors
* Affiche les méthodes rattachés à la classe en cours.
Playground > (Printit-ctrl+p)
SortedCollection methods 	"{SortedCollection>>#add:. SortedCollection>>#sort:to:. etc.
SortedCollection selectors 	"#(#add: #sort:to: #= #join: #sortBlock: #addFirst: etc.

Note Méthode : 
--------------
Les méthodes affichées par "Playground" ne sont pas par ordre alphabétique comme sous "SystemBrowser" du volet méthode.
C'est le bazar.


D09:09 08/06/2021 - F12:58 - Chapitre 16 - p.254/259 FR 368/376 EN
-------------------------------------------------------------------------------------------------------08/06/2021 fin




-------------------------------------------------------------------------------------------------------09/06/2021 debut
D09:11 09/06/2021 - F00:00 - Chapitre 16 - p.254/259 FR 368/376 EN
D09:11 09/06/2021 - F14:28 - Chapitre 16 - p.257/259 FR 373/376 EN

-10 mns 09:18 09/06/2021 - 09:28 09/06/2021
-4mns - 10:58 09/06/2021 - 11:02 09/06/2021
-12 mns - 12:24 09/06/2021 - 12:36 09/06/2021

Mise à jour : D09:12 09/06/2021 - F11:42 09/06/2021

Commandes principales : (package, IVN, CVN, sous-classe, classe, protocole, méthode)
-----------------------

Liste ci-dessus du 08/06/2021
-10 mns 09:18 09/06/2021 - 09:28 09/06/2021
-4mns - 10:58 09/06/2021 - 11:02 09/06/2021

p. 254 FR 368 EN
Une seule recherche de méthode - Only one method lookup
--------------------------------
	Inspecter des objets et des classes - Inspecting objects and classes
	-----------------------------------

1. Inspection d'une instance de OrderedCollection,
2. la classe OrderedCollection elle-même.

Playground >
	OrderedCollection avec All: # (4 5 6 1 2 3) 	> Inspector on an OrderedCollection (6 items) (4 5 6 1 2 3)
	OrderedCollection 				> Inspector on an OrderedCollection class (OrderedCollection) 

Questions / Interrogations : 
---------------------------
1. Si "OrderedCollection" est la classe et "OrderedCollection class" une métaclasse puis "an OrderedCollection" une classe miroir alors 
c'est quoi "an OrderedCollection class" ? Une métaclasse miroir ?

2. La fenêtre de l'inspecteur sur l'instance de "OrderedCollection" est plus cohérente que la seconde. (Figure 16-5)
Sur la barre de titre est indiqué "Inspector on an OrderedCollection (6 items) (4 5 6 1 2 3)",
sous la barre de titre "an OrderedCollection (6 items) (4 5 6 1 2 3)",
depuis l'onglet "Raw" "an OrderedCollection(4 5 6 1 2 3)". 


12:10 09/06/2021
"Cela peut être un peu déroutant, car la barre de titre de l'inspecteur nomme la classe de l'objet inspecté."
"This can be a bit confusing, because the title bar of the inspector names the class of the object being inspected."

* Le manque de cohérence, d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.

Ou est défini "new" ?

Playground >
new class  "UndefinedObject"
UndefinedObject class "UndefinedObject class"
UndefinedObject class class  "Metaclass"
UndefinedObject class class class  "Metaclass class"
UndefinedObject class class class class  "Metaclass"

new class superclass  "Object"
new class superclass superclass  "ProtoObject"
new class superclass superclass superclass  "nil"
new class superclass superclass superclass superclass #new is missing, and does not understand #superclass

new superclass 						#new is missing, and does not understand #superclass

-12 mns - 12:24 09/06/2021 - 12:36 09/06/2021

nil class  "UndefinedObject"
UndefinedObject class "UndefinedObject class"
UndefinedObject class class  "Metaclass"
UndefinedObject class class class  "Metaclass class"
UndefinedObject class class class class  "Metaclass"

nil class superclass  "Object"
nil class superclass superclass  "ProtoObject"
nil class superclass superclass superclass  "nil"
nil class superclass superclass superclass superclass #nil is missing, and does not understand #superclass

nil superclass 

self class  "UndefinedObject"
UndefinedObject class "UndefinedObject class"
UndefinedObject class class  "Metaclass"
UndefinedObject class class class  "Metaclass class"
UndefinedObject class class class class  "Metaclass"

self class superclass  "Object"
self class superclass superclass  "ProtoObject"
self class superclass superclass superclass  "self"
self class superclass superclass superclass superclass #self is missing, and does not understand #superclass

self superclass 

new subclasses  "{ProtoObject}"
nil subclasses  "{ProtoObject}"
self subclasses  "{ProtoObject}"


UndefinedObject class  "UndefinedObject class"
UndefinedObject class class  "Metaclass"
UndefinedObject class class class  "Metaclass class"
UndefinedObject class class class class  "Metaclass"
UndefinedObject class class class class class  "Metaclass class"

UndefinedObject class superclass  "Object class"
UndefinedObject class superclass superclass  "ProtoObject class"
UndefinedObject class superclass superclass superclass  "Class"
UndefinedObject class superclass superclass superclass superclass "ClassDescription"
UndefinedObject class superclass superclass superclass superclass superclass  "Behavior"
UndefinedObject class superclass superclass superclass superclass superclass superclass  "Object"
UndefinedObject class superclass superclass superclass superclass superclass superclass superclass  "ProtoObject"
UndefinedObject class superclass superclass superclass superclass superclass superclass superclass superclass  "nil"
UndefinedObject class superclass superclass superclass superclass superclass superclass superclass superclass superclass #superclass was sent to nil

UndefinedObject allSubInstances  "an OrderedCollection(nil)"
UndefinedObject allInstances  "#(nil)"
UndefinedObject methods {UndefinedObject>>#asRingDefinition. UndefinedObject>>#veryDeepCopyWith:. UndefinedObject>>#addSubclass:. xxxxx
UndefinedObject selectors #(#asRingDefinition #veryDeepCopyWith: #addSubclass: #subclassDefinerClass #setProject:withInMetacelloConfig: #asCollectionElement #at:put: xxxxx
UndefinedObject protocols 
 "#(#'*OpalCompiler-Core' #printing #'*UnifiedFFI' #'dependents access' #'*opalcompiler-core' #'bottom context' #'*Alien-Core' #'*Glamour-Morphic-Brick' #'*GT-InspectorExtensions-Core' #testing #'class hierarchy' #'*Ring-Definitions-Core' #accessing #'sets support' #'*metacello-core' #'*Fuel-Core' #copying #'*ston-core' #'reflective operations')"
UndefinedObject allSubclasses  "an OrderedCollection()"
UndefinedObject subclasses  "#()"
UndefinedObject allSuperclasses  "an OrderedCollection(Object ProtoObject)"
UndefinedObject class "UndefinedObject class"
UndefinedObject superclass  "Object"
UndefinedObject allClassVarNames  "#(#DependentsFields)"
UndefinedObject classVarNames  "#()"
UndefinedObject allInstVarNames  "#()"
UndefinedObject instVarNames  "#()"	
UndefinedObject package  "a RPackage(Kernel)"	


Questions / Interrogations : 
--------------------------

1. "le message new est envoyé à une classe, il est recherché dans sa chaîne de métaclasses et finalement dans ses superclasses Class, 
ClassDescription et Behavior comme le montre la figure 16-7."

Sauf que ce n'est pas cohérent encore une fois puisqu'une métaclasse c'est un nom de classe suivie de class, 
tandis que Class, ClassDescription et Behavior ce n'est pas le cas.

* Le manque de cohérence, d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.

2. Comment déterminer s'il s'agit de la classe "Behavior" et la métaclasse "Behavior" étant donné qu'ils ont les mêmes noms ?
"new est d'abord défini dans la classe Behavior"

* Plus ça va plus, et ça part en couille.

3. "Maintenant, quand un nouveau message est envoyé à une classe, il est recherché, comme d'habitude, dans la métaclasse de cette classe,
en continuant la chaîne de superclasse jusqu'à la classe Behavior, s'il n'a pas été redéfini en cours de route."
S'il n'a pas été redéfini en cours de route, c'est comme avoir un chapeau de magicien on ne sait pas à quoi s'attendre.

Playground >
	Behavior > Implementors >
			SystemBrowser > Volet méthode "new" > Inheritance > Implementors of new (167)
								- Behavior
								- Metaclass
								- Boolean class etc.

* Le manque de cohérence, d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.


Code : 
-----
Playground > (printit-ctrl+p)
	SortedCollection new class	> ctrl-p	> "SortedCollection"


Question / Interrogation : 
--------------------------
"Par exemple, Array new: 4 crée un tableau de 4 éléments. 
Vous ne trouverez pas cette méthode définie dans Array ou l'une de ses superclasses. 
Au lieu de cela, vous devriez regarder dans la classe Array et ses superclasses, car c'est là que la recherche commencera (voir Figure  16-7)."

Playground > 
	new: > Implementors of news: (38) 	> Alien class - new: - Alien-Core
						> Array class - new: - Collections-Sequenceable
						> Array2D class
						> Bag class
						> Behavior - new: - Kernle

	Array > Implementors > SystemBrowser > () Array > Volet méthode (Inst. side) > recherche new: = introuvable
							> Volet méthode (Class side) > recherche new: = new: 

Recomposition
--------------
Recomposition pour plus de clarté, malgré une incohérence.

Vous ne trouverez pas cette méthode définié dans la classe Array ou l'une de ses superclasses.

Note : Car, il s'agit bien d'une classe Array étant donné qu'elle est dans le volet classe du Systembrowser.

Au lieu de cela, vous devriez regarder du côté Classe de la classe Array et ses superclasses.

Note : Du coup, lorsque le lecteur met l'option "Class side" apparaît "Array class" et la méthode "new:".


Vous ne trouverez pas cette méthode définié dans la classe Array ou l'une de ses superclasses.
Au lieu de cela, vous devriez regarder du côté Classe de la classe Array et ses superclasses.


Questions / Interrogations : 
--------------------------

1. Depuis SystemBrowser, lorsqu'on met la classe "Array" "côté Class" = "Array class", est-ce que cela correspond à la métaclasse "Array class" ?
Parce étant donné que l'on traite l'affichage des méthodes (côté instance ou côté classe) depuis la classe "Array", c'est donc dans les deux
cas, les méthodes de la classe "Array".

SystemBrowser : 
	1.a 	Classe
		Array
	      /        \
 côté instance          côté classe


SystemBrowser :
	1.b	Classe			Metaclasse
		Array			Array class
		  |		  	     |
	    côté instance		côté classe = métaclasse (?)  (<- erreur côté métaclasse)

* 14:05 09/06/2021 - Effectuer une recherche pour revoir la description et la différence entre "côté instance" et "côté classe" du Systembrowser.
Parce que c'est confus, incohérent et je m'emmerde avec ces conneries au lieu de CODER.


2. Des méthodes différentes et équivalentes sont disponibles dans la classe et la métaclasse ? (Array, Array class, SortedCollection, SortedCollection class) 
(SortedCollection selectors = #sortBlock: ; SortedCollection class selectors = #sortBlock:

Playground > (printit-ctrl-p)

Array selectors "#(#isArray #printAsSelfEvaluatingFormOn: #printOn: #asTestMatrix #elementsForwardIdentityTo:copyHash: #copyWithDependent: #printAsLiteralFormOn: #asTraitComposition #hasLiteralSuchThat: #asArray #isSelfEvaluating #fuelReplacement #atWrap: #hasLiteral: #fuelAccept: #asLayoutFrame #'+*' #storeOn: #preMultiplyByMatrix: #elementsForwardIdentityTo: #asSpLayout #elementsExchangeIdentityWith: #literalEqual: #replaceFrom:to:with:startingAt: #gtInspectorFastPrintOn: #atWrap:put: #settingStoreOn: #isLiteral #shouldBePrintedAsLiteral #preMultiplyByArray: #generateSpec)"
Array class selectors "#(#braceWith:with:with: #braceStream: #empty #new: #braceWith: #braceWith:with: #braceWithNone #braceWith:with:with:with:)"

SortedCollection selectors "#(#add: #sort:to: #= #join: #sortBlock: #addFirst: #defaultSort:to: #flatCollect: #indexForInserting: #insert:before: #sort: #median #addAll: #at:put: #copyEmpty #, #sortBlock #collect: #groupedBy: #reSort)"
SortedCollection class selectors "#(#sortBlock: #sortUsing:)"



Mise à jour : D06:50 10/06/2021 - F08:00 10/06/2021 - p. 256 FR 371 EN (Behavior, classdescription, class, commandes, rappels)
-------------


BEHAVIOR
--------
"Behavior fournit l'état minimum nécessaire pour les objets qui ont des instances, qui comprend : "
	- un lien de superclasse,
	- un dictionnaire de méthodes,
	- format de classe (entier qui encode distinction pointeur/non-poiteur, classe compacte/non-compacte, taille de base des instances)

Behavior hérites de l'"Object".

* i.e. = c'est à dire.

Behavior est également l'interface de base du compilateur.
	- fournit des méthodes pour la création d'un dictionnaire de la méthode, (déjà signalé plus haut)
	- la compilation des méthodes,
	- la création d'instances (i.e., new, basicNew, new:, and basicNew:),
	- la manipulation de la classe "hierarchy" (i.e., superclass:, addSubclass:), (implementors of hierarchy (6)
	- l'accès à des méthodes (i.e., selectors, allSelectors, compiledMethodAt:), 
	- accès aux instances et aux variables (i.e., allInstances, instVarNames...), 
	- l' accès à la hiérarchie des classes (i.e., superclasse, subclasses),
	- l'interrogation (i.e., hasMethods, includesSelector, canUnderstand:, InheritsFrom:,isVariable).


Code : Tests
------
Playground > (printit-ctrl-p)
	Object superclass class 					"ProtoObject class"
	ProtoObject class superclass 					"Class"
	ProtoObject class superclass superclass  			"ClassDescription"
	ProtoObject class superclass superclass superclass  		"Behavior"
	ProtoObject class superclass superclass superclass superclass  	"Object"
	Class hasMethods 						"true"
	ClassDescription hasMethods 					"true"
	Behavior methods 						{Behavior>>#browse. Behavior>>#shouldNotBeRedefined. Behavior>>#allSubclassesWithLevelDo:startingLevel:. Behavior>>#allMethodsAccessingSlot:. 
	Class methods 							{Class>>#sharedPoolsDo:. Class>>#instanceSide. Class>>#criticTheNonMetaclassClass. Class>>#gtInspectorMethodsIn:. 
	ClassDescription methods 					{ClassDescription>>#instanceSide. ClassDescription>>#banLevelCandidates. ClassDescription>>#selectorsInProtocol:. ClassDescription>>#isInstanceSide. ClassDescription>>#theMetaClass. 


CLASSDESCRIPTION
----------------
"ClassDescription est une classe abstraite qui fournit les installations nécessaires à ses deux sous-classes directes,  
Class et Metaclass." (Figure 16-8 - p.372 EN)
 - ajoute un certain nombre de fonctionnalités à la base fournie par Behavior :
	- des variables d'instance nommées,
	- catégorisation des méthodes en protocoles, 
	- maintenance des ensembles de modifications,
	- journalisation des modifications,
	- la plupart des mécanismes nécessaires pour classer les modifications.

CLASS
-----
Class représente le comportement commun de toutes les classes.
	- fournit un nom de classe, 
	- des méthodes de compilation, 
	- un stockage de méthode et des variables d'instance.

Il propose une représentation concrète pour les noms de : 
	- variables de classe et variables de pool partagée. (addClassVarName:, addSharedPool:, initialize)

Puisqu'une métaclasse est une classe pour sa seule instance (i.e, la non-méta-classe), 
toutes les métaclasses héritent finalement de Class (comme le montre la Figure 16-9).


"Les instances de la classe Metaclass sont les métaclasses anonymes, chacune ayant exactement une instance, qui est une classe."
* Les métaclasses ne sont pas anonymes, étant donné que "Chaque classe est nommée par une variable globale".
Lire les "Rappels" ci-dessous.


Recherche : anonyme, définissez une classe, une classe, La pratique recommandée est de limiter strictement l'utilisation de variables globales
-----------

Rappels : 07:50 10/06/2021
--------
p.86 FR 124 EN
"Les variables globales sont accessibles partout. Chaque classe est nommée par une variable globale."

p.86 124 EN
"La pratique recommandée est de limiter strictement l'utilisation de variables globales."

p.87 FR 125 EN
"La pratique recommandée est de limiter strictement l'utilisation de variables globales."
Tu sais qu'à chaque fois qu'une classe est créée, s'associe une variable globale, 
mais tu dois limiter "strictement" son utilisation.
Ce qui veut dire que si tu n'en utilises jamais (variable globale), alors tu vas perdre du temps 
à faire quelque chose pour cette variable.

p.94 FR 136 EN
"La création d'une classe crée également une variable globale qui fait référence à la classe"

p. 252 FR 365 EN
"Les métaclasses sont créées automatiquement lorsque vous définissez une classe."
"Metaclasses are automatically created when you define a class."
"les classes ordinaires sont nommées, les métaclasses sont anonymes."
"Whereas ordinary classes are named, metaclasses are anonymous."

p. 252 FR 366 EN
"En fait, les métaclasses ne sont pas vraiment anonymes, leur nom est déduit de celui de leur instance unique."
"In fact metaclasses are not truly anonymous, their name is deduced from the one of their single instance."
* Donc pour résumer, c'est anonyme sans vraiment l'être. MDR !


Commandes :
-----------

manipulating the class hierarchy (i.e., superclass:, addSubclass:), 

accessing methods (i.e., selectors,allSelectors, compiledMethodAt:), 

accessing instances and variables (i.e.,allInstances, instVarNames...), 

accessing the class hierarchy (i.e., superclass, subclasses) and 

querying (i.e., hasMethods, includesSelector, canUnderstand:, inheritsFrom:, isVariable).

representation for class variable names and shared pool variables (addClassVarName:, addSharedPool:, initialize). 

Since a metaclass is a class for its sole instance (i.e., the non-meta class),
 
all metaclasses ultimately inherit from Class



Questions / Interrogations : 
----------------------------

1. Pourquoi la "Class" n'a t'elle pas de "Class class" dans la "Figure 16-8" alors que "Class clas class" donne le résultat "Metaclass" ?
(Figure 16-8)

Class class  "Class class"
Class class class  "Metaclass"
Collection class  "Collection class"
Collection class class "Metaclass"


2. "The final question to be answered is: what is the class of Metaclass class? 
The answer is simple: it is a metaclass, so it must be an instance of Metaclass,"

"La dernière question à laquelle il faut répondre est : quelle est la classe de la classe Metaclass ?
La réponse est simple : c'est une métaclasse, donc ce doit être une instance de  Metaclass,"

La réponse n'est pas une "Metaclass" mais une "Metaclass class" une instance de "Metaclass".

Playground > 
	Metaclass class  "Metaclass class"
	Metaclass class class  "Metaclass"


* Franchement, si tu dis à une personne que "Toutes les métaclasses sont des instances de la classe Metaclass, même la métaclasse de Metaclass.",
elle va te prendre pour un fou. 

D09:11 09/06/2021 - F14:28 - Chapitre 16 - p.257/259 FR 373/376 EN
-------------------------------------------------------------------------------------------------------09/06/2021 fin




-------------------------------------------------------------------------------------------------------10/06/2021 debut
D06:41 10/06/2021 - F00:00 - Chapitre 16 - p.257/259 FR 373/376 EN
D06:41 10/06/2021 - F12:13 - Chapitre 16 - p.257/259 FR 373/376 EN

-10 mns - 08:04 10/06/2021 - 08:14 10/06/2021
-6 mns - 09:05 10/06/2021 - 09:11 10/06/2021

Mise à jour : D06:50 10/06/2021 - F08:00 10/06/2021 - p. 256 FR 371 EN (Behavior, classdescription, class, commandes, rappels 07:50 10/06/2021)
-------------

Code : 
------

Playground > (printit-ctrl-p)
	Collection superclass  					> "Object" //Listing 6-10 - déjà fait et rererere..............fait

-10 mns - 08:04 10/06/2021 - 08:14 10/06/2021

* Crochets ??? Qu'est-ce que c’est ce code ?	
	[[[testcase=true Object class superclass superclass 	> ']' expected ->

	
	testcase=true Object class superclass superclass 	> Instance of True did not understand #Object

* Certaines fois, je me demande s'il ne s'agit pas tout simplement d'un perroquet.
	[[[testcase=true Object class] superclass] superclass] 	> "[ [ [ testcase = true Object class ] superclass ] superclass ]"
	[[[testcase=false Object class] superclass] superclass] > "[ [ [ testcase = false Object class ] superclass ] superclass ]"

	[[[testcase=false]]] Object class superclass superclass	> Instance of BlockClosure did not understand #Object


Question / Interrogation : 
--------------------------

Rappels : 07:50 10/06/2021 
 |-> Quelles sont les commandes permettant de connaître les statues de partages des variables, classes, métaclasses, etc. ?


Organigramme : 
--------------

SystemBrowser : Behavior 
	|
	|--->	Classes					
		(c)ProtoObject
		(c) Object
		(c)  Behavior
		(c)   ClassDescription
		(c)    Class
		(c)	Trait
		(c)    Metaclass

-6 mns - 09:05 10/06/2021 - 09:11 10/06/2021


Organigramme : SortedCollection
--------------

Mise à jour : D09:19 11/06/2021 - F12:17 11/06/2021 - Organigramme : SortedCollection
Mise à jour : D09:08 13/06/2021 - F10:05 13/06/2021 - Organigramme : SortedCollection


SystemBrowser : SortedCollection
 |
 |------>	Classes	------------------- > Playground -------------- > Métaclasses 
	   	\|/				\|/			   \|/ 
 --------------------------------------------------------------------------------------------------
 
 		 -------------------------- Instance de ---------------------
 		 |							    |
 		/|\							   \|/	
 
 		nil ------------------- > nil superclass -------------- > #superclass was sent to nil
 
   |<--------- Object -------------------------------------<|
   |							    |
   |	      	nil ------------------- > nil class superclass
   |		 
|<-| < ------- Metaclass ----------------------------------<|
|  |							    |		
|  |		nil ------------------- > nil class class class
|  |		 	      									      
|  |	      	nil ------------------- > nil class class > ----------- > UndefinedObject class ---->|
||<| < ------- Class --------------------------------------------------< ProtoObject class -----<|  |
|| | |< ------ UndefinedObject ---------------<|						  |  |
|| | |	      	 				|						  |  |
|| | |	     	nil ------------------- > nil class 	 					  |  |
|| | |	      	 |										  |  |
|| | |	      	nil < ---------------------------------------<|					  |  |	 < - nil ---------------------------------------------------------------- nil -----------------------------------------<| 
|| | |	         |					      |					  |  |																|
|| | |	(c)ProtoObject ----------------	> ProtoObject superclass				  |  |																|
|| | |	(c)ProtoObject ----------------	> ProtoObject class -----------	> "ProtoObject class" -- >|  |	 < - ProtoObject class ---------------------------------<| < ----------- ProtoObject --------------------------<|	|
|| | |		 |	   							|		     |								 |						 	|	|
|| |>|>|(c)  Object ------------------- > Object class ---------------- > "Object class" < -------<| |	 < - Object class -----------------------<| < ---------  | < -------- Object ------------------<|		|	|
|| | |   	 |								|		   | |						  |		 |					|		|	|
|| | |->(c) UndefinedObject ----------- > UndefinedObject class ------- > "UndefinedObject class" <-<|						  |		 |					|		|	|
|| |     	 										   |   						  |		 |					|		|	|
|| |<-- (c)  Behavior ----------------- > Behavior class -------------- > "Behavior class" ------->|  	 < - Behavior class --------------------- | < ---------  | < ----- Behavior -------------<|	|		|	|
|| |		 |								|		      						  |		 |				  |	|		|	|
|| |  |>(c)   ClassDescription -------- > ClassDescription class ------ > "ClassDecription class" < -<|	 < - ClassDecription class -------------- | < ---------  | < --- ClDes <|		  |	|		|	|
|| |  |	   	 |								|		      |						  |		 |		|		  |	|		|	|
||>|->| (c)   Class -------------------	> Class class ----------------- > "Class class"		      |	 < - Class class ------------------------ | < ---------  | < --<|Class	|		  |	|		|	|
|  |  |	   	 	 									      |						  |	   	 |	|	|		  | 	|		|	|
|>-|  |<(c)  Metaclass ---------------- > Metaclass class ------------- > "Metaclass class" <> -- ><|>|						  |		 |	|	|		  |	|		|	|
|  |	    	 	 								   	    |						  |		 |	|	|		  |	|		|	|
|  |< - ()    Collection --------------	> Collection class ------------ > "Collection class"	    |	 < - Collection class ----------------<|  |		 |	|	|		  |	|		|	|
|		 |								|		    |					       |  |		 |	|	|		  |	|		|	|
|	()     SequenceableCollection -	> SequenceableCollection class -> "SequenceableCollection class" < - SequenceableCollection class <|   |  |		 |	|	|		  |	|		|	|
|		 |								|		    |					   |   |  |		 |	|	|		  |	|		|	|
|	()      OrderedCollection -----	> OrderedCollection class -----	> "OrderedCollection class" |	 < - OrderedC.cl. <|		   |   |  |		 |	|	|		  |	|		|	|
|		 |								|		    |			   |		   |   |  |		 |	|	|		  |	|		|	|
|	        /|\						       	       /|\		    |			   |		   |   |  |		 |	|	|		  |	|		|	|
|	()	 SortedCollection -----	> SortedCollection class ------	> "SortedCollection class"  |	 		   |		   |   |  |		 |	|	|		  |	|		|	|
|						|						    |			   |		   |   |  |		 |	|	|		  |	|		|	|
|	Classes	----------------------- > Playground ------------------ >  Metaclasses		    |			   |		   |   |  |		 |	|	|		  |	|		|	|
|					       \|/					            |			   |		   |   |  |		 |	|	|		  |	|		|	|
| < ---------- Metaclass --------------- < Xxxxxxxxxx class class				    |			   |		   |   |  |		 |	|	|		  |	|		|	| 
 					 Xxxxxxxxxx class class class - > Metaclass class -------- >|			   |		   |   |  |		 |	|	|		  |	|		|	|					
 						|									   |		   |   |  |		 |	|	|		  |	|		|	|
 					  Playground									   |		   |   |  |		 |	|	|		  |	|		|	|
  					       \|/									   |		   |   |  |		 |	|	|		  |	|		|	| 
 					        |-> Playground > SortedCollection class superclass > "OrderedCollection class"		   |   |  |		 |	|	|		  |	|		|	|
  						|-> Playground > SortedCollection superclass superclass class  "SequenceableCollection class"  |  |		 |	|	|		  |	|		|	|
 						|-> Playground > SortedCollection class superclass superclass > "SequenceableCollection class" |  |		 |	|	|		  |	|		|	|
 						|-> Playground > SortedCollection class superclass superclass superclasse    > "Collection class" |		 |	|	|		  |	|		|	|		
 						|-> Playground > SortedCollection class superclass superclass superclass superclass >  "Object class"		 |	|	|		  |	|		|	|
 						|-> Playground > SortedCollection class superclass superclass superclass superclass superclass > "ProtoObject class"	|	|		  |	|		|	|
 						|-> Playground > SortedCollection class superclass  superclass  superclass  superclass  superclass  superclass	 > "Class"	|		  |	|		|	|
 						|-> Playground > SortedCollection class superclass superclass superclass superclass superclass superclass superclass > "ClassDescription"	  |	|		|	|
 						|-> Playground > SortedCollection class superclass  superclass   superclass   superclass  superclass  superclass  superclass  superclass > "Behavior"	|		|	|
 						|-> Playground > SortedCollection class superclass  superclass  superclass  superclass  superclass  superclass  superclass  superclass superclass > "Object"		|	|	
 						|-> Playground > SortedCollection class superclass  superclass  superclass  superclass  superclass  superclass  superclass  superclass superclass superclass > "ProtoObject"	|
 						|-> Playground > SortedCollection class superclass  superclass   superclass   superclass  superclass  superclass  superclass  superclass superclass  superclass  superclass  "nil" 
 



D06:41 10/06/2021 - F12:13 - Chapitre 16 - p.257/259 FR 373/376 EN
-------------------------------------------------------------------------------------------------------10/06/2021 fin




-------------------------------------------------------------------------------------------------------11/06/2021 debut
D09:17 11/06/2021 - F00:00 - Chapitre 16 - p.257/259 FR 373/376 EN
D09:17 11/06/2021 - F12:17 - Chapitre 16 - p.257/259 FR 373/376 EN

-18 mns - 09:41 11/06/2021 - 09:59 11/06/2021
-10 mns - 11:29 11/06/2021 - 11:39 11/06/2021


Mise à jour : D09:19 11/06/2021 - F12:17 11/06/2021 - Organigramme : SortedCollection

"(En fait, vous verrez que nous avons dit un mensonge blanc - Object class superclass --> ProtoObject class, pas Class. 
Dans Pharo, nous devons aller une superclasse plus haut pour atteindre Class.)"

"(Actually, you will see that we told a white lie — Object class superclass --> ProtoObject class, not Class. 
In Pharo, we must go one superclass higher to reach Class.)

* Ça ne répond pas à mon interrogation ci-dessous.

Questions / Interrogations :
--------------------------

1. C'est incohérent, car depuis "SystemBrowser", volet classe, "Hier.", la hiérarchie des classes est : 

	- ProtoObject
	- Object
	- Behavior
	- ClassDescription
	- Class
	
Tandis qu'avec la commande "ProtoObject class superclass", cela fournit un classement inverse : 

	- "Class"
	- "ClassDescription"
	- "Behavior"
	- "Object"
	- "ProtoObject"

2. De plus, la liaison entre "ProtoObject class -> métaclasse" et "Class -> classe" est complètement incohérent : 

							Classes			Métaclasses

	- "OrderedCollection class"			OrderedCollection	"OrderedCollection class"
	- "SequenceableCollection class"		SequenceableCollection	"SequenceableCollection class"
	- "Collection class"				Collection		"Collection class"
	- "Object class"				Object			"Object class"
	- "ProtoObject class"				ProtoObject		"ProtoObject class"
	- "Class"					Class			"Class class"
	- "ClassDescription"				ClassDescription	"ClassDescription class"
	- "Behavior"					Behavior		"Behavior class"
	- "Object"					
	- "ProtoObject"

* Le manque de cohérence, d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.


3. La réponse à la commande "nil class class" ou "nil class class class" est décalée.

Playground >
	nil class  "UndefinedObject"				Object class "Object class"			
	nil class class   "UndefinedObject class"		Object class class  "Metaclass"
	nil class class class  "Metaclass"			Object class class class  "Metaclass class"
	nil class class class class  "Metaclass class"		Object class class class class  "Metaclass"

* Le manque de cohérence, d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.

-18 mns - 09:41 11/06/2021 - 09:59 11/06/2021


----------------------------------------------------------------CLASS_SUPERCLASS DEBUT
Playground >

1 class
2 class superclass

3 superclass
4 superclass class


Behavior class  "Behavior class"
Behavior class class  "Metaclass"
Behavior class class class  "Metaclass class"


Class class  "Class class"
Class class class "Metaclass"
Class class class class  "Metaclass class"

Class superclass  "ClassDescription"
Class class superclass  "ClassDescription class"


Metaclass class class "Metaclass"
Metaclass class class class  "Metaclass class"

nil class superclass  "Object"
nil class superclass superclass  "ProtoObject"

nil superclass #superclass was sent to nil

nil superclass class was sent to nil

nil class  "UndefinedObject"
nil class class   "UndefinedObject class"
nil class class class  "Metaclass"
nil class class class class  "Metaclass class"

Object class "Object class"
Object class class  "Metaclass"
Object class class class  "Metaclass class"
Object class class class class  "Metaclass"

Object class superclass  "ProtoObject class"

Object superclass "ProtoObject"


OrderedCollection class class "Metaclass"


ProtoObject class "ProtoObject class"
ProtoObject class class  "Metaclass"
ProtoObject class class class "Metaclass class"

ProtoObject class superclass  "Class" 

ProtoObject superclass  "nil"
ProtoObject superclass superclass was sent to nil

ProtoObject superclass class  "UndefinedObject"
ProtoObject superclass class class "UndefinedObject class"


SortedCollection class  "SortedCollection class"
SortedCollection class class  "Metaclass"
SortedCollection class class class  "Metaclass class"

SortedCollection class superclass  "OrderedCollection class"
SortedCollection class superclass  superclass  superclass  superclass  superclass  superclass  superclass  superclass superclass superclass superclass  "nil"

SortedCollection superclass class  class  class  class  class  class  class  class class class "Metaclass"
SortedCollection superclass class  class  class  class  class  class  class  class class  "Metaclass class"
SortedCollection superclass class  class  class  class  class  class  class  class  "Metaclass"
SortedCollection superclass class  class  class  class  class  class  class "Metaclass class"

SortedCollection superclass superclass class  "SequenceableCollection class"


UndefinedObject class "UndefinedObject class"
UndefinedObject class class  "Metaclass"
UndefinedObject class class class "Metaclass class"

UndefinedObject class superclass  "Object class"
----------------------------------------------------------------CLASS_SUPERCLASS FIN


Note : 
------

* Après avoir tapé toutes ces commandes et créé un organigramme pour bien comprendre, 
je pense qu'il aurait été plus simple de produire une "Dashboard - carte" dynamique.

"Une image vaut mille mots".

-10 mns - 11:29 11/06/2021 - 11:39 11/06/2021

D09:17 11/06/2021 - F12:17 - Chapitre 16 - p.257/259 FR 373/376 EN
-------------------------------------------------------------------------------------------------------11/06/2021 fin




-------------------------------------------------------------------------------------------------------13/06/2021 debut
D09:02 13/06/2021 - F00:00 - Chapitre 16 - p.257/259 FR 373/376 EN
D09:02 13/06/2021 - F11:53 - Chapitre 16 - p.258/259 FR 375/376 EN

Mise à jour : D09:08 13/06/2021 - F10:05 13/06/2021 - Organigramme : SortedCollection

10:07 13/06/2021
16.8 Résumé du chapitre
"Ce chapitre a donné un examen approfondi du modèle d'objet uniforme et une explication plus approfondie de l'organisation des classes."


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------
"vous devez toujours vous rappeler que le passage de message est la clé: vous recherchez la méthode dans la classe du receveur."
"you should always remember that message passing is the key: you look for the method in the class of the receiver."

1. "Les métaclasses sont implicites."
Définition : implicites - Qui n’est pas exprimé formellement, mais peut être déduit par le contexte; sous-entendu. 

2. "Une métaclasse est simplement une classe dont l'instance unique est une classe."
Cela reste tout de même différend étant donné que ces deux entités ont des méthodes différentes.

Playground >
	Metaclass class  selectors 	> "#(#fromSton:)"
	Metaclass selectors		> "#(#innerBindingOf: #soleInstance #veryDeepCopyWith: #uses: #asRingDefinition #addSubclass: #removeSlot: #instanceSide #criticTheNonMetaclassClass #asEpiceaRingDefinition #asRingMinimalDefinitionIn: #classVariables #isAnonymous #oldDefinition #subclassesDo: #baseLocalMethods #stonName #definitionWithoutSlots #newAnonymousSubclass #compilerClass #definition #wantsChangeSetLogging #fileOutOn: #isObsolete #obsoleteSubclasses #setTraitComposition: #new #sourceCodeTemplate #addObsoleteSubclass: #initializeFrom: #addInstVarNamed: #subclasses #isUsed #name #fileOutInitializerOn: #uses:instanceVariableNames: #sharedPools #isMetaclassOfClassOrNil #definitionWithSlots #compiler #slots: #initializeBasicMethods #addSlot: #isClass #fileOutOn:initializing: #acceptsLoggingOfCompilation #isSelfEvaluating #isMeta #postCopy #nonTrivial #stonOn: #fuelAccept: #hasClassSide #category #canonicalArgumentName #binding #classSide #removeSubclass: #environment #instanceVariableNames: #classPool #possibleVariabl					esFor:continuedFrom: #asFullRingDefinition #adoptInstance:from: #bindingOf: #uses:slots: #classVarNames #visibleMethods)"

* Le manque de cohérence, d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.


3. "La hiérarchie des métaclasses est parallèle à la hiérarchie des classes."
"The metaclass hierarchy parallels the class hierarchy."
C'est faux.

La superclass d'"Object class - Figure 16-9 " ou "ProtoObject class - Pharo 8.0.0 " sont la classe "Class", 
donc la hiérarchie des métaclasses n'est pas parallèle à la hiérarchie des classes.
Dans ces conditions, faire croire qu'on puisse avaler un requin devient une tâche difficile.

* Le manque de cohérence, d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.

4. "La recherche de méthode pour les classes est parallèle à la recherche de méthode pour les objets ordinaires et 
suit la chaîne de superclasses de la métaclasse."
Un "object ordinaire" ? Tout est objet, mais ces deux mots suggèrent qu'il y a des objects ordinaires, peu ordinaires et extraordinaires ! 

Recherche dans les notes, example FR et EN : object ordinaire - ordinary objects

"Figure 16-4 La recherche de messages pour les classes est la même que pour les objets ordinaires."

1. Cela sous-entend-il que les "métaclasses" sont des "objects ordinaires" ?
2. En partant d'une réponse positive, tout est objet, mais il y a des catégories d'objet ?


5. "Chaque métaclasse hérite de Class and Behavior."
Faux.
J'ai interrogé les "68 méthodes" de la classe "Metaclass" et elles n'héritent pas de la class "Class".

Recherche : hérite - inheritance
----------
Rappel : 
--------
Règle 5. 
La recherche de méthode suit la chaîne d'héritage, donc lorsque nous envoyons le message 'classe' au
résultat de (OrderedCollection withAll: # (4 5 6 1 2 3)) asSortedCollection, 
le message est traité lorsque la méthode correspondante est trouvée dans la classe Object,
comme le montre la figure 16-1.

Method lookup follows the inheritance chain, so when we send the message 'class' to 
the result of (OrderedCollection withAll: #(4 5 6 1 2 3)) asSortedCollection, 
the message is handled when the corresponding method is found in the class Object, 
as shown in Figure 16-1.

Playground >
	Metaclass > Implementors-ctrl+m > SystemBrowser > (c)Metaclass
								|
							Volet méthode inheritance >
							- binding > Metaclass > Behavior
							- classSide > Metaclass > ClassDescription
							- classvarnames > Metaclass > Behavior
							- classVariables > Metaclass
							- definition > MetaclassForTraits > TraitedMetaclass > Metaclass > ClassDescription
							- fuelAccept: > Metaclass > Ojbect


	Metaclass selectors size  "68"	
	Metaclass inheritance
	Metaclass selectors inheritance
	Metaclass selectors inheritance binding
	Metaclass inheritance selectors binding
	Metaclass inheritance binding
	inheritance binding
	#binding inheritance

* Pourquoi, faire compliquer, quand on peut faire simple ?

	Metaclass inheritance self selectedClass ifNotNil: [ :class | self selectedMethod ifNotNil: [ :selector | systemNavigation new methodHierarchyBrowserForClass: class selector: selector ] ]
	Metaclass systemNavigation new methodHierarchyBrowserForClass: class selector: selector
	Metaclass inheritance systemNavigation new methodHierarchyBrowserForClass: class selector: selector
	Metaclass inheritance new methodHierarchyBrowserForClass: class selector: selector
	inheritance new methodHierarchyBrowserForClass: class selector: selector Metaclass
	inheritance new methodHierarchyBrowserForClass: Metaclass
	inheritance Metaclass


Notes améliorations : 
---------------------
1. Depuis le volet méthode, le raccourcie "CTRL+H -> inheritance" ne fonctionne pas. (Pharo 8.0.0 - Windows)

2. Cela aurait été plus simple en tapant "Metaclass inheritance" dans Playground que d'interroger toutes les méthodes de la classe "Metaclass".
(Ça prouve combien j'ai confiance dans tout ce méli-mélo.)								

3. Aucun raccourice pour la fermeture d'une fenêtre dans l'espace Pharo.
 Exemple : 
	Volet méthode > binding > Inheritance (CTRL+H - Raccourcie clavier HS) > fermeture de la fenêtre > X Close the window
		      > classside > Inheritance (CTRL+H - Raccourcie clavier HS) > fermeture de la fenêtre > X Close the window
		      > etc.....

Enfin !

J'ai réussi jusqu'au bout et ça n'a pas été une mince affaire.

Finalement, est-ce que je sais programmer ? Non
Est-ce que je peux faire un projet en autonomie ? Non
Est-ce que j'ai perdu énormément de temps à essayer de comprendre ces concepts filandreux, contradictoires et inutiles ? Oui

Est-ce que je me suis pris la tête ? Oui
Est-ce que je me suis pris la tête plusieurs fois ? Oui

Est-ce qu’une bonne pizza m'a permis de tenir jusqu'au bout ? Oui
Est-ce que SmallTalk Pharo m'a permis de tenir jusqu'au bout ? Non

Est-ce que je souhaite refaire le jeu "LightOut" ? Non, je n'ai pas envie de me reprendre la tête.

Je repense au problème de "Numéros d'urgence : quand l'état ne répond plus.
"La technologie est de plus en plus pointue, mais paradoxalement nous rend de plus en plus fragiles".


Je tire mon chapeau à celles et ceux qui se lancent dans la programmation avec smalltalk Pharo, parce que c'est incohérent, 
ça manque d'uniformité et contribue à de grandes confusions.

Par conséquent, je ne suis pas étonné du manque de programmeur qui fait le choix de manger une bonne pizza quatre fromages 
en haut d'un phare plutôt que de se prendre la tête.


D09:02 13/06/2021 - F11:53 - Chapitre 16 - p.258/259 FR 375/376 EN
-------------------------------------------------------------------------------------------------------13/06/2021 fin




-------------------------------------------------------------------------------------------------------/06/2021 debut



-------------------------------------------------------------------------------------------------------/06/2021 fin




-------------------------------------------------------------------------------------------------------/06/2021 debut



-------------------------------------------------------------------------------------------------------/06/2021 fin

Mise à jour du Fichier "Ph_chap.6.png". (D:\Documents de user\Documents\INFORMATIQUE\PROGRAMMATION\Pharo)

Note : 
------
Exemple capture camstudio -> 149.Pharobyexample5_Chap_15_webpage_first_title.avi = 32.00Mo -> conversion swf formatfactory -> 
Conversion : gif 4,76Mo en vidéo = 3gp 4,16Mo ou swf 4,23Mo (reste à régler le flou de l'image).


À retenir : (Heu ! Qu'est-ce que c'était les précédents ?)
-----------

* Le manque de cohérence, d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.
* Le manque d'uniformité contribue à de grandes confusions et les nouveaux arrivants s'en rendent comptes.





--------------------------------------------------------------------------------------------------------------NOTES DEBUT

Remarque : 
----------

Je fais un parallèle entre l'apprentissage du code Pharo et d'un oeuf dur qu'on souhaite décortiquer.
Étant donné que "c'est simple" alors le plus simple lorsqu'on décortique un oeuf dur est de taper celui-ci contre
une surface dure. Alors, la coquille sera brisée en plusieurs minuscules morceaux.
Mais voilà, enlever ces éclats peut se révéler être un véritable calvaire.
Car, comme souvent, les parties de coquilles resteront collées au reste de l'oeuf occasionnant des trous 
et tout en grognant, maudissant ces éclats s'agglutinant sur les doigts, j'aurais le choix de persévérer ou de jeter l'oeuf.



(Situation confuse, embrouillée. Quel micmac !)

"L'avantage de ceci est que vous voyez la méthode que vous écrivez car elle sera exécutée, 
avec des paramètres réels dans le contexte d'exécution réel."


p.46 FR - accesseur
"Un getter a toujours le même nom que la variable correspondante et un setter est nommé de même, mais avec une fuite « : », d' où 
mouseAction  et  mouseAction: . Collectivement, setters et getters sont appelés  accesseur méthodes et par Conven tion , ils
doivent être placés dans l'  Accès   protocole. Dans Pharo, toutes les variables d'instance sont privées de l'objet qui les possède,
donc le seul moyen pour un autre objet de lire ou d'écrire ces variables est d'utiliser des méthodes d'accesseur comme celle-ci. En
fait, les variables d'instance sont également accessibles dans les sous-classes."


p. 53 FR 75 EN - syntaxe
Chapitre 4 - La syntaxe en bref - Syntax in a nutshell

self :	pseudo-variable - self est un mot clé qui fait référence à l'objet à l'intérieur duquel la méthode actuelle s'execute.
	Nous l'appelon "le récepteur" parce que cet objet a reçu le message qui a entrainé l'exécution de la méthode.
	self est appelé une "pseudo-variable" car nous ne pouvons pas l'assigner.


p.73 FR - accesseur
"Toutes les méthodes sont publiques et virtuelles (c'est-à-dire recherchées dynamiquement). 
Les méthodes sont regroupées en protocoles qui indiquent leur intention. 
Certains noms de protocole communs ont été établis par convention, par exemple, 
l'accès pour toutes les méthodes d'accesseur et l'initialisation 
pour établir un état initial cohérent pour l'objet."

p.73 FR - accesseur
"Certains développeurs préfèrent accéder aux variables d'instance uniquement via des accesseurs. 
Cette pratique a une certaine valeur, mais elle encombre également l'interface de vos classes, 
et pire, elle expose son état privé au monde."

p.76 FR - accesseur
"Important  Une classe n'a pas accès aux variables d'instance de ses propres instances. Une instance d'une classe n'a pas
accès aux variables d'instance de classe de sa classe."

p.76 FR - accesseur
"Pour cette raison, les méthodes d'initialisation d'instance doivent toujours être définies côté instance, 
le côté classe n'a pas accès aux variables d'instance et ne peut donc pas les initialiser ! 
Tout ce que la classe peut faire est d'envoyer des messages d'initialisation, 
à l'aide d'accesseurs, aux instances nouvellement créées."

p.77 FR - accesseur
"Une note sur l'initialisation paresseuse. N'utilisez pas trop le modèle d'initialisation paresseux. La définition des valeurs
initiales pour les instances d'objets appartient généralement à la méthode d' initialisation. 
Placer les appels d'initialisation uniquement dans initialize aide du point de vue de la lisibilité - 
vous n'avez pas à parcourir toutes les méthodes
d'accesseur pour voir quelles sont les valeurs initiales. 
Bien qu'il puisse être tentant d'initialiser à la place des variables d'instance dans leurs méthodes d' accès respectives 
(en  utilisant ifNil:  checks), évitez cela à moins que vous n'ayez une bonne raison."

p.88 FR - accesseur
"Cela implique que nous devons utiliser l'accesseur tout le temps et ne jamais utiliser directement la variable de classe."

p.86 FR 124 EN - variables
"Les variables globales sont accessibles partout. Chaque classe est nommée par une variable globale."
p.86 124 EN
"La pratique recommandée est de limiter strictement l'utilisation de variables globales."

Protocole > "Instance side" = côté instance - "Class side" = côté classe


WEEK 2 - /07/2020 - ?
-------
20072020 - 11:40 - D 11:40 - F 12:18 (creation sommaire) - DEBUT W2
http://mooc.pharo.org/
(11:40 - 12:18 Approxiation des liens, slides, videos, subtiles, exercises)

http://mooc.pharo.org/#week2



--------------------------------------------------------------------------------------------------------------NOTES FIN



--------------------------------------------------------------------------------------------------------------COMMANDES DEBUT
14:12 09/06/2021

Commandes :
-----------

manipulating the class hierarchy (i.e., superclass:, addSubclass:), 

accessing methods (i.e., selectors,allSelectors, compiledMethodAt:), 

accessing instances and variables (i.e.,allInstances, instVarNames...), 

accessing the class hierarchy (i.e., superclass, subclasses) and 

querying (i.e., hasMethods, includesSelector, canUnderstand:, inheritsFrom:, isVariable).

representation for class variable names and shared pool variables (addClassVarName:, addSharedPool:, initialize). 

Since a metaclass is a class for its sole instance (i.e., the non-meta class),
 
all metaclasses ultimately inherit from Class 



11:41 09/06/2021

Commandes principales : (package, IVN, CVN, sous-classe, superclasse, metaclasse, classe, protocole, méthode)
-----------------------

C = Commande

Package
Cpackage - C package
Playground > (Printit-ctrl+p)
SortedCollection package "a RPackage(Collections-Sequenceable)"


InstVarNames
CIVN - civn - instance variables names - noms variables d'instance - noms des variables d'instance 
* Affiche seulement les noms des variables d'instance de la classe en cours.
Playground > (Printit-ctrl+p)
SortedCollection instVarNames "#(#sortBlock)"


AllInstVarNames
CIVN all - civn all - all instance variables names - all noms des variables d'instance
* Affiche tous les noms de variables d'instance.
Les trois premiers Noms des Variables d'instance sont rattachés à "OrderedCollection" et le dernier à "SortedCollection".
Playground > (Printit-ctrl+p)
SortedCollection allInstVarNames  "#(#array #firstIndex #lastIndex #sortBlock)"

Note InstVarNames - AllInstVarNames : 
-------------------------------------
Il aurait fallu qu'il affiche "OrderedCollection>>#array.", similaire au retour de la commande "SortedCollection methods".
Car on ne sait pas qu'elle est sa relation principale entre "#array" et "SortedCollection" ou " "? - OrderedCollection" ou "? - Object".


ClassVarNames
CCVN - ccvn - classe variables names - noms variables classe - noms des variables de classe
* Affiche seulement les noms des variables de classe de la classe en cours.
Playground > (Printit-ctrl+p)
SortedCollection classVarNames "#()"


AllClassVarNames
CCVN all - ccvn all - all classe variables names - all noms variables classe -  all noms des variables de classe
* Affiche tous les Noms des Variables de Classe et celle du dessous est rattachée à la classe "Object".
Playground > (Printit-ctrl+p)
SortedCollection allClassVarNames "#(#DependentsFields)"

Note ClassVarNames - AllClassVarNames : 
---------------------------------------
Il aurait fallu qu'il affiche "Object>>#DependentsFields.", similaire au retour de la commande "SortedCollection methods".
Car on ne sait pas qu'elle est sa relation principale entre "#DependentsFields" et "SortedCollection" ou "? - Object".


Subclasses = SystemBrowser -> Hier.
Csubclasses - C subclasses
* Affiche la/les sous-classes de la classe en cours.
Playground > (Printit-ctrl+p)
OrderedCollection subclasses "{ObjectFinalizerCollection. SortedCollection. WeakOrderedCollection. OCLiteralList. GLMMultiValue}"

Note Subclasse : 
----------------
Pharo propose "subclass", "subclasses" et "allSubclasses".

p.97 FR 142 EN - "Hier. = Hiérarchie" 
"sélectionner une classe particulière d'intérêt, tels que ImageMorph puis cliquez sur le bouton hiérarchie (Hier.).
Vous verrez alors dans le second volet une hiérarchie de classes affichant toutes les superclasses et sous-classes de la classe sélectionnée."


Superclass = SystemBrowser -> Hier.
Csuperclass - C superclass
* Affiche la classe du dessus de celle en cours autrement dit la superclasse.
Playground > (Printit-ctrl+p)
SortedCollection superclass "OrderedCollection"

Notes Superclass : 
------------------
Celle du dessus est "superclasse" tandis que celle du dessous ?
Comment interroger les classes du dessous ? Sous-classes - allSubclasses 
C'est la confusion entre "superclass" et "allSuperclasses".


Metaclasse
Cclass - C class
* Affiche la métaclasse de la classe en cours.			Classe				Metaclasse
Playground > (Printit-ctrl+p)					SortedCollection instance de ->	SortedCollection class
SortedCollection class  "SortedCollection class"


Classe = SystemBrowser -> Hier. |  = SystemBrowser -> Volet méthode -> Inheritance
* Affiche la liste des classes héritées de la classe en cours. 
Playground > (Printit-ctrl+p)
SortedCollection allSuperclasses "an OrderedCollection(OrderedCollection SequenceableCollection Collection Object ProtoObject)"
OrderedCollection allSuperclasses "an OrderedCollection(		 SequenceableCollection Collection Object ProtoObject)"

Sous-classe = SystemBrowser -> Hier.
SortedCollection allSubclasses "an OrderedCollection()"
OrderedCollection allSubclasses "an OrderedCollection(ObjectFinalizerCollection SortedCollection WeakOrderedCollection OCLiteralList GLMMultiValue)"


Notes Classe : 
--------------
Cela aurait été plus simple de mettre "metaclass" plutôt que "class", comme le démontre "package". ("selectors" et "metaclass" ont le même nombre de lettres.)
Ça manque de cohérence.
C'est la confusion entre "allSuperclasses" et "superclass".
p.97 FR 142 EN - "Hier. = Hiérarchie" 
"sélectionner une classe particulière d'intérêt, tels que ImageMorph puis cliquez sur le bouton hiérarchie (Hier.).
Vous verrez alors dans le second volet une hiérarchie de classes affichant toutes les superclasses et sous-classes de la classe sélectionnée."


Protocole
Cprotocols - C protocols
* Affiche les protocoles
Playground > (Printit-ctrl+p)
SortedCollection protocols "#(#enumerating #adding #accessing #copying #'math functions' #comparing #splitjoin #sorting #private)"
OrderedCollection protocols "#(#enumerating #sorting #converting #adding #splitjoin #copying #'*Fuel-Core' #initialization #accessing #removing #private)"

Note Protocole : 
----------------
Pharo propose protocol, protocoles, allProtocol, allProtocols, allProtocolsNames, seule la seconde proposition donne une réponse. 



Methode
Cmethods - C methods - Cselectors - C selectors
* Affiche les méthodes rattachés à la classe en cours.
Playground > (Printit-ctrl+p)
SortedCollection methods 	"{SortedCollection>>#add:. SortedCollection>>#sort:to:. etc.
SortedCollection selectors 	"#(#add: #sort:to: #= #join: #sortBlock: #addFirst: etc.

Note Méthode : 
--------------
Les méthodes affichées par "Playground" ne sont pas par ordre alphabétique comme sous "SystemBrowser" du volet méthode.
C'est le bazar.
--------------------------------------------------------------------------------------------------------------COMMANDES FIN DEBUT



--------------------------------------------------------------------------------------------------------------CODES DEBUT
10:55 03/06/2021

Playground > (c)LoggingProxy
LoggingProxy allSuperclasses 
select: [ :each | | subject | subject := (each instVarNamed: 'subject'). own isNotNil and: [ subject doesNotUnderstand: ] ] > Variable or expression expected ->

LoggingProxy allSuperclasses 
select: [ :each | | own | own := (each instVarNamed: 'superclass'). own isNotNil and: [ own doesNotUnderstand:  ] ] > Variable or expression expected ->

LoggingProxy allSuperclasses 
select: [ :each | | initialize | initialize := (each instVarNamed: 'subject'). initialize isNotNil and: [ initialize doesNotUnderstand:  ] ]  > Variable or expression expected ->

LoggingProxy allSuperclasses 
select: [ :each | | initialize | initialize := (each instVarNamed: 'invocationCount'). initialize isNotNil and: [ initialize doesNotUnderstand:  ] ] > Variable or expression expected ->

LoggingProxy whichSelectorsAccess: 'x' > "#()"

Playground > (c)LoggingProxy
	LoggingProxy allClassVarNames  		> "#()"
	LoggingProxy allInstVarNames  		> "#(#subject #invocationCount)"
	LoggingProxy allMethods  		>  "{ProtoObject>>#primitiveFailed:. ProtoObject>>#rfIsEqual:. ProtoObject>>#'=='. ProtoObject>>#mustBeBooleanDeOptimizeIn:. ProtoObject>>#glamourValueWithArgs:. ProtoObject>>#becomeForward:copyHash:. ProtoObject>>#ifNotNil:ifNil:. ProtoObject>>#largeIdentityHash. ProtoObject>>#gtDebuggerPresentationsIn:inContext:. ProtoObject>>#flag:. ProtoObject>>#instVarsInclude:. ProtoObject>>#withArgs:executeMethod:. LoggingProxy>>#doesNotUnderstand:. ProtoObject>>#gtInspectorActionBrowse. ProtoObject>>#fuelPointsTo:. ProtoObject>>#nextInstance. ProtoObject>>#executeMethod:. ProtoObject>>#gtInspectorPresentationsFromPragmas:In:inContext:. ProtoObject>>#ifNil:. ProtoObject>>#allSelectorsToTestInMethodFinder. ProtoObject>>#cannotInterpret:. ProtoObject>>#gtInspectorIcon. LoggingProxy>>#invocationCount. ProtoObject>>#gtDebuggerEvaluatorIn:. ProtoObject>>#become:. ProtoObject>>#modificationForbiddenFor:index:value:. ProtoObject>>#asGlamorousMultiValue. ProtoObject>>#gtInspectorRawIn:. ProtoObject>>#gtInspectorMetaIn:. ProtoObject>>#pointersTo. ProtoObject>>#isNil. ProtoObject>>#basicIdentityHash. ProtoObject>>#pointsTo:. ProtoObject>>#mustBeBooleanCompileExpression:andCache:. ProtoObject>>#becomeForward:. ProtoObject>>#glamourValue:. ProtoObject>>#gtInspectorPresentationsIn:inContext:. ProtoObject>>#gtDebuggerRawIn:. ProtoObject>>#'~~'. LoggingProxy>>#initialize. ProtoObject>>#gtInspectorActions. ProtoObject>>#rearmOneShot. ProtoObject>>#ifNotNil:. ProtoObject>>#pointersToExcept:. ProtoObject>>#asGlamorousArray. ProtoObject>>#rFwithArgs:executeMethod:. ProtoObject>>#class. ProtoObject>>#primitiveFailed. ProtoObject>>#doOnlyOnce:. ProtoObject>>#primitiveFail. ProtoObject>>#modificationForbiddenFor:value:. ProtoObject>>#mustBeBoolean. ProtoObject>>#metaLinkOptions. ProtoObject>>#identityHash. ProtoObject>>#nextObject. ProtoObject>>#mustBeBooleanIn:. ProtoObject>>#tryPrimitive:withArgs:. ProtoObject>>#ifNil:ifNotNil:}"

	LoggingProxy allSelectors  		> "an IdentitySet(#primitiveFailed: #rfIsEqual: #'==' #mustBeBooleanDeOptimizeIn: #glamourValueWithArgs: #becomeForward:copyHash: #ifNotNil:ifNil: #largeIdentityHash #gtDebuggerPresentationsIn:inContext: #flag: #instVarsInclude: #withArgs:executeMethod: #doesNotUnderstand: #gtInspectorActionBrowse #fuelPointsTo: #nextInstance #executeMethod: #gtInspectorPresentationsFromPragmas:In:inContext: #ifNil: #allSelectorsToTestInMethodFinder #cannotInterpret: #gtInspectorIcon #invocationCount #gtDebuggerEvaluatorIn: #become: #modificationForbiddenFor:index:value: #asGlamorousMultiValue #gtInspectorRawIn: #gtInspectorMetaIn: #pointersTo #isNil #basicIdentityHash #pointsTo: #mustBeBooleanCompileExpression:andCache: #becomeForward: #glamourValue: #gtInspectorPresentationsIn:inContext: #gtDebuggerRawIn: #'~~' #initialize #gtInspectorActions #rearmOneShot #ifNotNil: #pointersToExcept: #asGlamorousArray #rFwithArgs:executeMethod: #class #primitiveFailed #doOnlyOnce: #primitiveFail #modificationForbiddenFor:value: #mustBeBoolean #metaLinkOptions #identityHash #nextObject #mustBeBooleanIn: #tryPrimitive:withArgs: #ifNil:ifNotNil:)"	

	LoggingProxy allSharedPools  		> "an OrderedCollection()"

	LoggingProxy allSuperclasses  		> "an OrderedCollection(Object ProtoObject)"
	LoggingProxy allSubclasses  		> "an OrderedCollection()"
	LoggingProxy allSubInstances  		> "an OrderedCollection()"


	LoggingProxy basicIdentityHash  	> "9454"
	LoggingProxy classVarNames  		> "#()"
	LoggingProxy dependentClasses 		> "{ProtoObject. LoggingProxy}"

	LoggingProxy isVariable  		> "false"
	LoggingProxy instVarNames  		> "#(#subject #invocationCount)"

	LoggingProxy protocols  		> "#(#'reflective operations' #accessing #initialization)"
	LoggingProxy properties    		> "nil"

	LoggingProxy realClass  		> "LoggingProxy"

	LoggingProxy subclassDefinerClass  	> "OpalCompiler"
	LoggingProxy superclass  		> "ProtoObject"
	LoggingProxy startUp  			> "LoggingProxy"
	LoggingProxy spaceUsed  		> "187"
	LoggingProxy sourceCodeTemplate  	> "'messageSelectorAndArgumentNames
	""comment stating purpose of instance-side message""
	""scope: class-variables  &  instance-variables""	
			
	| temporary variable names |
	statements'"
	
	LoggingProxy slots			> "{#subject => InstanceVariableSlot. #invocationCount => InstanceVariableSlot}"

	LoggingProxy sharedPoolNames 		> "an OrderedCollection()"
	LoggingProxy selectors  		> "#(#initialize #doesNotUnderstand: #invocationCount)"

	LoggingProxy typeOfClass		> "#normal"
	LoggingProxy usingMethods  		> "an OrderedCollection()"

	LoggingProxy whichClassIncludesSelector: #inspect 	> "nil"
	LoggingProxy whichClassIncludesSelector: #subject 	> "nil"
	LoggingProxy whichClassIncludesSelector: #invocationCount > "LoggingProxy"
	LoggingProxy withAllSubclasses  	> "an OrderedCollection(LoggingProxy)"
	LoggingProxy withAllSuperAndSubclasses	> "an OrderedCollection(ProtoObject LoggingProxy)"

"SystemNavigation est une façade qui prend en charge diverses méthodes utiles pour interroger et parcourir 
le code source du système. La valeur par défaut de SystemNavigation renvoie une instance que vous pouvez utiliser 
pour naviguer dans le système."
Playground >
	SystemNavigation default allClassesImplementing: #subject	  	> "an OrderedCollection(AthensSimpleTreeNode CDTraitCompositionNode ClassOrganization MailMessage RGTraitTransformation TaSingleComposition ZnServerGenericLogEvent)"
	SystemNavigation default allClassesImplementing: #invocationCount 	> "an OrderedCollection(LoggingProxy)"
	SystemNavigation default allClassesImplementing: #LoggingProxy		> "an OrderedCollection()"
	SystemNavigation default allClassesImplementing: #doesNotUnderstand 	>  "an OrderedCollection()"
	SystemNavigation default allClassesImplementing: #initialize		>
	SystemNavigation default allClassesImplementing: #instanceSide		> "an OrderedCollection(Class ClassDescription Metaclass RBAbstractClass RBClass RGBehaviorDefinition RGBehaviorStrategy RGBehaviorStrategyUser RGClassDefinition RGMetaclassDefinition RGMetaclassStrategy RGMetaclassTraitStrategy RGMetaclassTraitV2Strategy RGMetatraitDefinition RGTraitDefinition RGTraitStrategy)"
	SystemNavigation default allClassesImplementing: #reflectiveMethod  	> "an OrderedCollection(CompiledMethod ReflectiveMethod)"
	SystemNavigation default allClassesImplementing: #reflectiveOperations 	> "an OrderedCollection()"
	SystemNavigation default allClassesImplementing: #reflectiveoperations 	> "an OrderedCollection()"
	SystemNavigation default allClassesImplementing: #overrides:  		> "an OrderedCollection()"

Parcourir toutes les implémentations de #subject, etc.."
Playground >
	SystemNavigation default browseAllImplementorsOf: #subject 		> implementors (7)
	SystemNavigation default browseAllImplementorsOf: #invocationCount 	> implementors (1)

---------------------------------------------------------------------------------------------------------------CODES FIN

---------------------------------------------------------------------------------------------------------------SPOTTER DEBUT
11:12 06/06/2021

"Pharo by example 5" - Utilisation de Spotter - Using Spotter -  2.18 -  p. 29 FR 39 EN
Les autres catégories sont le menu, les packages, 

Pourquoi "#implementor plutôt que "#methode" ?
#implementor 	la méthode
		
#example	les exemples		
#pragma		le pragma		 
#sender		les expéditeurs 

Pourquoi "#reference" plutôt que "#classe" ?
#reference	les références de classe

Affiche l'historique de certaines commandes.
#playground	terrain de jeu		

Exemples : pharobyexample5 - spotter - page 40/376
----------

Donnera toute la référence à la classe Point.
#ref Point  			

Affichera tous les implementors de "printString".
#imple printString
		
	
KEYS
#player 
#previous 
#close 
#goOn: 
#helpBrowserWindow 
#go 
#tutorial:lesson: 
#showCurrentLesson 
#open 
#lessonView 
#next 
#player: 
#tutorialPositionString 
#last 
#tutorialSizeString 
#tutorial:lessonAt: 
#first 
#lessonView:

---------------------------------------------------------------------------------------------------------------SPOTTER FIN



---------------------------------------------------------------------------------------------------------------PROFSTEF DEBUT
11:11 06/06/2021
ProfStef Debugger 28/29
Playground> PharoSyntaxTutorial new divideTwoByZero.

Playground (CTRL+O+W)> ProfStef go
Transcript (CTRL+O+T)> ProfStef go
ProfStef next. (CTRL+D) leçon suivante)
ProfStef previous. (CTRL+D) leçon précédente - antérieur)
ProfStef previous. 	//Revenir en arrière (exercice précédent)
(CTRL + Z) 		//Revenir en arrière (exercice précédent) ou rappeler les modifications de l'exercice en cours)


ProfStef goToNextLesson 19
ProfStef goToNextLesson 24/29.
ProfStef goToNextLesson Iterators.
ProfStef next 24 @ 29.
ProfStef perform: #next.
[ProfStef next] value.
[ProfStef next] value:Iterators.
ProfStef next Iterators (24/29).
ProfStef next value:Iterators (24/29).
ProfStef next Basic types: Iterators.
ProfStef next Basic types: Iterators(24/29).
ProfStef next Basic types: Iterators (24/29).
ProfStef Iterators (24/29) go

Pharobyexample 5 FR page 32/259, EN page 44/376.
ProfStef : Aller à une page précise ? (ci-dessous rien ne fonctionne)
ProfStef nextPage:29.
ProfStef nextPage:29/29.
ProfStef nextPage:(29/29).
ProfStef nextLink: 29.
ProfStef nextLink: 29/29.
ProfStef nextLink: (29/29).
ProfStef nextId 29/29.
ProfStef nextId (29/29).
ProfStef nextNumber 29.
ProfStef nextNumber 29/29.
ProfStef nextNumber (29/29).
ProfStef nextNumber: 29.
ProfStef nextNumber: 29/29.
ProfStef nextNumber: (29/29).
ProfStef nextNumber: 29 put: .
ProfStef next: 29 into: 29 startingAt: 29/29 .
ProfStef Reflection 26/29
ProfStef default executeMethod: (ProfStef lookupSelector:#next).
ProfStef goToNextLesson.
---------------------------------------------------------------------------------------------------------------PROFSTEF FIN



---------------------------------------------------------------------------------------------------------------RACCOURCIS DEBUT

+ Utilisés
----------
ALT + K 	= Playground 
CTRL + M 	= System Browser (13:18 13/11/2020 playground> classe)
CTRL + B	= System Browser
CTRL + O + P	= Montecillo Browser
Shift + Entrée 	= Spotter

Désinformer
-----------
ATL + T 	= Transcript ([Spotter] Exception in filter <GTFilterSubstring>: Prim....
ATL + K 	= Playground
ATL + B 	= System Browser


CTRL + U 	= Spotter search (Fenêtre : Question "MessageTally the UI process one cycle - Yes No)
CTRL + P 	= Monticello Browser
CTRL + I 	= Repositories

Shift + Entrée	= Spotter search

WIN + U 	= Spotter search (Fenêtre : Question "MessageTally the UI process one cycle - Yes No)
WIN + M 	= Réductions de toutes les fenêtres
WIN + D 	= Réductions de toutes les fenêtres
WIN + , 	= Affiche le bureau

System Browser	= CTRL + [lettre] + [lettre]
----------------
CTRL + F	= Find method (depuis le volet class cherche une class)				
CTRL + F	= Find method (depuis le volet method cherche une method)

NOTE :
------
Lire fichier "NPharo_negatifs_positifs.txt" -> 99. Chap.7 - p.100 FR 146 EN - Playground auto-complete

Playground	= CTRL + [lettre] + [lettre]
GTPlayground
----------------
CTRL + B	= System Browser 			(classe) 		exemple : OrderedCollection
CTRL + B	= "Variable or expression expected" 	(classe>>method)	exemple : OrderedCollection>>removeAt:
CTRL + B	= "Variable or expression expected" 	(method)		exemple : removeAt:

CTRL + M	= System Browser 			(classe) 		exemple : OrderedCollection
CTRL + M	= Implementors 				(classe>>method)	exemple : OrderedCollection>>removeAt:
CTRL + M	= Implementors 				(method)		exemple : removeAt:
		
CTRL + N	= Senders			
CTRL + H + j	= Jump to test method	
CTRL + R	= Rename			
CTRL + X	= Remove

ProfSteph
---------
Playground (CTRL+O+W)> ProfStef go
Transcript (CTRL+O+T)> ProfStef go
ProfStef next. (CTRL+D) leçon suivante)
ProfStef previous. (CTRL+D) leçon précédente - antérieur)			

Snapshot Browser= ALT  + [lettre]
------------------------- 
ALT + B		= Browse full		
ALT + H		= Browse hierarchy	
ALT + O		= FileOut			
ALT + C		= Copy selector		
ALT + N		= Browse senders		
ALT + M		= Browse implementors	
ALT + I		= Inheritance		
ALT + V		= Versions	
	
---------------------------------------------------------------------------------------------------------------RACCOURCIS FIN


